//
//  ContentView.swift
//  newDiary
//
//  Created by WangPuma on 2025/3/18.
//

/*
 é‡æ§‹å»ºè­°:
 1. ValueTransformer é¡åˆ¥ (WeatherTypeTransformer, CategoryTypeTransformer) å¯èƒ½ä¸éœ€è¦ï¼Œå› ç‚º SwiftData å·²èƒ½è™•ç† enum çš„ç·¨ç¢¼è§£ç¢¼
 2. MainDiaryForm çµæ§‹é«”èˆ‡ NewDiaryView åŠŸèƒ½é‡è¤‡ï¼Œå¯ä»¥åˆªé™¤å…¶ä¸­ä¸€å€‹
 3. åµŒå¥—çš„ Form/Section çµæ§‹éå¤šï¼Œç‰¹åˆ¥æ˜¯åœ¨ WeatherAndThoughtsView åŠå…¶å­è¦–åœ–ä¸­ï¼Œå¯ä»¥ç°¡åŒ–å±¤æ¬¡
 4. @AppStorage è®Šæ•¸åœ¨å¤šå€‹è¦–åœ–ä¸­é‡è¤‡å®£å‘Šï¼Œå»ºè­°å‰µå»ºä¸€å€‹å…±äº«çš„è¨­å®šç’°å¢ƒç‰©ä»¶
 5. å¤šé¤˜çš„ padding å’Œä¸å¿…è¦çš„å®¹å™¨åµŒå¥—å¯ä»¥ç²¾ç°¡
 */

import SwiftUI
import SwiftData
import Foundation
import LocalAuthentication
import CoreLocation
import UniformTypeIdentifiers

// MARK: - å¤©æ°£é¡å‹å®šç¾©
/// å®šç¾©æ‰€æœ‰å¯ç”¨çš„å¤©æ°£é¡å‹
enum WeatherType: String, Codable, CaseIterable {
    case sunny = "æ™´å¤©"
    case cloudy = "å¤šé›²"
    case rainy = "ä¸‹é›¨"
    case storm = "æš´é›¨"
    case windy = "åˆ®é¢¨"
    case foggy = "éœ§å¤©"
    case snow = "ä¸‹é›ª"
    
    /// æ¯ç¨®å¤©æ°£å°æ‡‰çš„ SF Symbols åœ–æ¨™åç¨±
    var icon: String {
        switch self {
        case .sunny: return "sun.max.fill"      // å¤ªé™½åœ–æ¨™
        case .cloudy: return "cloud.fill"       // é›²æœµåœ–æ¨™
        case .rainy: return "cloud.rain.fill"   // ä¸‹é›¨åœ–æ¨™
        case .storm: return "cloud.bolt.rain.fill" // æš´é›¨åœ–æ¨™
        case .windy: return "wind"              // é¢¨åœ–æ¨™
        case .foggy: return "cloud.fog.fill"    // éœ§å¤©åœ–æ¨™
        case .snow: return "snow"               // ä¸‹é›ªåœ–æ¨™
        }
    }
}

// MARK: - åˆ†é¡é¡å‹å®šç¾©
/// å®šç¾©æ‰€æœ‰å¯ç”¨çš„è¨˜éŒ„åˆ†é¡
enum CategoryType: String, Codable, CaseIterable {
    case expense = "æ”¯å‡º"
    case exercise = "é‹å‹•"
    case sleep = "ç¡çœ "
    case work = "å·¥ä½œ"
    case relationship = "é—œä¿‚"
    case study = "å­¸ç¿’"
    
    /// æ¯ç¨®åˆ†é¡å°æ‡‰çš„ SF Symbols åœ–æ¨™åç¨±
    var icon: String {
        switch self {
        case .expense: return "dollarsign.circle.fill"    // é‡‘éŒ¢åœ–æ¨™
        case .exercise: return "figure.run.circle.fill"   // é‹å‹•åœ–æ¨™
        case .sleep: return "bed.double.circle.fill"      // ç¡çœ åœ–æ¨™
        case .work: return "briefcase.circle.fill"        // å·¥ä½œåœ–æ¨™
        case .relationship: return "person.2.circle.fill"  // é—œä¿‚åœ–æ¨™
        case .study: return "book.circle.fill"            // å­¸ç¿’åœ–æ¨™
        }
    }
    
    /// æ¯ç¨®åˆ†é¡çš„é å®šç¾©é¸é …
    var predefinedCategories: [String] {
        switch self {
        case .expense:
            return ["é£²é£Ÿ(æ—©)", "é£²é£Ÿ(ä¸­)", "é£²é£Ÿ(æ™š)", "å®¶åº­ç”¨å“", "å€‹äººç”¨å“", 
                   "ç¨…é‡‘", "æ°´é›»ç“¦æ–¯è²»", "è´ˆäºˆ", "ç´…ç™½åŒ…", "äº¤é€šè²»"]
        case .exercise:
            return ["è‚©", "èƒŒ", "èƒ¸", "è…¿", "æ‰‹", "æ ¸å¿ƒ"]
        case .work:
            return ["èŒæª¢", "å„€æ ¡", "ä»£å·¥", "å”åŠ©", "è¡›ç”Ÿæª¢æŸ¥", "æ•™è‚²è¨“ç·´"]
        case .relationship:
            return ["è¦–è¨Š", "çŸ­ä¿¡", "æœƒé¢", "èšé¤", "æ¢è¦–"]
        case .study:
            return ["æ›¸ç±", "é›»åª’", "èªè¨€", "å¥èº«", "ä¿®é¤Š"]
        case .sleep:
            return []
        }
    }
}

// MARK: - å¤©æ°£ API ç›¸é—œçµæ§‹
/// OpenWeatherMap API è¿”å›æ•¸æ“šçš„çµæ§‹å®šç¾©
struct WeatherResponse: Codable {
    let main: MainWeather    // ä¸»è¦å¤©æ°£æ•¸æ“šï¼ˆæº«åº¦ç­‰ï¼‰
    let weather: [Weather]   // å¤©æ°£ç‹€æ³æè¿°
    
    struct MainWeather: Codable {
        let temp: Double     // ç•¶å‰æº«åº¦
        let temp_min: Double // æœ€ä½æº«åº¦
        let temp_max: Double // æœ€é«˜æº«åº¦
    }
    
    struct Weather: Codable {
        let main: String        // ä¸»è¦å¤©æ°£ç‹€æ³
        let description: String // å¤©æ°£æè¿°
    }
}

/// å¤©æ°£æœå‹™é¡ï¼Œè™•ç†èˆ‡ OpenWeatherMap API çš„äº¤äº’
class WeatherService: NSObject, CLLocationManagerDelegate {
    private let apiKey: String        // API å¯†é‘°
    private let locationManager = CLLocationManager()
    private var locationCompletion: ((Result<CLLocation, Error>) -> Void)?
    
    init(apiKey: String) {
        self.apiKey = apiKey
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters
    }
    
    /// è«‹æ±‚ä½ç½®æ¬Šé™ä¸¦ç²å–ä½ç½®
    private func requestLocation() async throws -> CLLocation {
        // æª¢æŸ¥ä½ç½®æœå‹™æ˜¯å¦å¯ç”¨
        guard CLLocationManager.locationServicesEnabled() else {
            throw NSError(domain: "WeatherService", code: 1, userInfo: [NSLocalizedDescriptionKey: "ä½ç½®æœå‹™æœªå•Ÿç”¨"])
        }
        
        return try await withCheckedThrowingContinuation { continuation in
            locationCompletion = { result in
                switch result {
                case .success(let location):
                    continuation.resume(returning: location)
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }
            
            // æ ¹æ“šæˆæ¬Šç‹€æ…‹è«‹æ±‚ä½ç½®
            let status = locationManager.authorizationStatus
            switch status {
            case .authorizedWhenInUse, .authorizedAlways:
                locationManager.requestLocation()
            case .notDetermined:
                locationManager.requestWhenInUseAuthorization()
            case .denied, .restricted:
                continuation.resume(throwing: NSError(domain: "WeatherService", code: 2, userInfo: [NSLocalizedDescriptionKey: "è«‹åœ¨ç³»çµ±è¨­å®šä¸­å…è¨±æ‡‰ç”¨ç¨‹åºä½¿ç”¨ä½ç½®æœå‹™"]))
            @unknown default:
                continuation.resume(throwing: NSError(domain: "WeatherService", code: 2, userInfo: [NSLocalizedDescriptionKey: "æœªçŸ¥çš„æˆæ¬Šç‹€æ…‹"]))
            }
        }
    }
    
    // CLLocationManagerDelegate æ–¹æ³•
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        if let location = locations.first {
            locationCompletion?(.success(location))
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        locationCompletion?(.failure(error))
    }
    
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        switch status {
        case .authorizedWhenInUse, .authorizedAlways:
            locationManager.requestLocation()
        case .denied, .restricted:
            locationCompletion?(.failure(NSError(domain: "WeatherService", code: 2, userInfo: [NSLocalizedDescriptionKey: "ä½ç½®æ¬Šé™æœªæˆäºˆ"])))
        case .notDetermined:
            locationManager.requestWhenInUseAuthorization()
        @unknown default:
            locationCompletion?(.failure(NSError(domain: "WeatherService", code: 2, userInfo: [NSLocalizedDescriptionKey: "æœªçŸ¥çš„æˆæ¬Šç‹€æ…‹"])))
        }
    }
    
    /// å¾ API ç²å–å¤©æ°£æ•¸æ“š
    func fetchWeather() async throws -> (WeatherType, String) {
        // ç²å–ç•¶å‰ä½ç½®
        let location = try await requestLocation()
        
        // æ§‹å»º API è«‹æ±‚ URLï¼ˆä½¿ç”¨ç¶“ç·¯åº¦ï¼‰
        let urlString = "https://api.openweathermap.org/data/2.5/weather?lat=\(location.coordinate.latitude)&lon=\(location.coordinate.longitude)&appid=\(apiKey)&units=metric&lang=zh_tw"
        guard let url = URL(string: urlString) else {
            throw URLError(.badURL)
        }
        
        // ç™¼é€è«‹æ±‚ä¸¦ç²å–æ•¸æ“š
        let (data, httpResponse) = try await URLSession.shared.data(from: url)
        
        // æ‰“å° API éŸ¿æ‡‰ç‹€æ…‹å’Œæ•¸æ“šï¼ˆç”¨æ–¼èª¿è©¦ï¼‰
        if let httpResponse = httpResponse as? HTTPURLResponse {
            print("HTTP Status Code: \(httpResponse.statusCode)")
        }
        if let jsonString = String(data: data, encoding: .utf8) {
            print("API Response: \(jsonString)")
        }
        
        // è§£æ API è¿”å›çš„æ•¸æ“š
        let weatherResponse = try JSONDecoder().decode(WeatherResponse.self, from: data)
        
        // å°‡ API è¿”å›çš„å¤©æ°£é¡å‹è½‰æ›ç‚ºæ‡‰ç”¨å…§çš„å¤©æ°£é¡å‹
        let weatherType = self.convertToWeatherType(weatherResponse.weather.first?.main ?? "")
        
        // ä½¿ç”¨åœ°ç†ç·¨ç¢¼å™¨ç²å–åœ°é»åç¨±
        let geocoder = CLGeocoder()
        let placemarks = try await geocoder.reverseGeocodeLocation(location)
        let locationName = placemarks.first?.locality ?? "ç•¶å‰ä½ç½®"
        
        // æ ¼å¼åŒ–æº«åº¦é¡¯ç¤ºå­—ç¬¦ä¸²
        let minTemp = Int(round(weatherResponse.main.temp_min))
        let maxTemp = Int(round(weatherResponse.main.temp_max))
        let currentTemp = Int(round(weatherResponse.main.temp))
        
        // è¼¸å‡ºèª¿è©¦ä¿¡æ¯
        print("å¤©æ°£æ•¸æ“š: ç•¶å‰æº«åº¦=\(currentTemp)Â°C, æœ€ä½=\(minTemp)Â°C, æœ€é«˜=\(maxTemp)Â°C")
        
        // æ ¹æ“šOpenWeatherMap APIæ–‡æª”ï¼Œcurrent weather APIä¸­çš„temp_minå’Œtemp_maxé€šå¸¸èˆ‡tempç›¸åŒï¼Œ
        // ä¸¦ä¸ä»£è¡¨ä¸€å¤©çš„æœ€é«˜/æœ€ä½æº«åº¦ï¼Œå› æ­¤é¡¯ç¤ºç•¶å‰æº«åº¦æ›´åˆé©
        let temperatureString = "\(locationName) \(currentTemp)Â°C \(weatherResponse.weather.first?.description ?? "")"
        
        // è¼¸å‡ºæœ€çµ‚çš„æº«åº¦å­—ç¬¦ä¸²
        print("é¡¯ç¤ºçš„æº«åº¦å­—ç¬¦ä¸²: \(temperatureString)")
        
        return (weatherType, temperatureString)
    }
    
    /// å°‡ OpenWeatherMap çš„å¤©æ°£é¡å‹è½‰æ›ç‚ºæ‡‰ç”¨å…§çš„å¤©æ°£é¡å‹
    private func convertToWeatherType(_ openWeatherMain: String) -> WeatherType {
        switch openWeatherMain.lowercased() {
        case "clear": return .sunny
        case "clouds": return .cloudy
        case "rain": return .rainy
        case "thunderstorm": return .storm
        case "snow": return .snow
        case "mist", "fog": return .foggy
        default: return .sunny
        }
    }
}

// MARK: - ä¸»è¦æ•¸æ“šæ¨¡å‹
/// æ—¥èªŒæ¢ç›®æ¨¡å‹
@Model
final class DiaryEntry {
    @Attribute(.unique) var id: UUID  // å”¯ä¸€æ¨™è­˜ç¬¦
    var date: Date                    // æ—¥æœŸ
    var weatherRaw: String            // å¤©æ°£ï¼ˆåŸå§‹å­—ç¬¦ä¸²ï¼‰
    var thoughts: String              // å¿ƒå¾—
    var temperature: String = ""      // æº«åº¦è³‡è¨Š
    
    /// å¤©æ°£é¡å‹çš„è¨ˆç®—å±¬æ€§
    var weather: WeatherType {
        get { WeatherType(rawValue: weatherRaw) ?? .sunny }
        set { weatherRaw = newValue.rawValue }
    }
    
    // å„ç¨®åˆ†é¡çš„æ¢ç›®é›†åˆ
    @Relationship(deleteRule: .cascade) var expenses: [CategoryEntry] = []      // æ”¯å‡ºè¨˜éŒ„
    @Relationship(deleteRule: .cascade) var exercises: [CategoryEntry] = []     // é‹å‹•è¨˜éŒ„
    @Relationship(deleteRule: .cascade) var sleeps: [CategoryEntry] = []        // ç¡çœ è¨˜éŒ„
    @Relationship(deleteRule: .cascade) var works: [CategoryEntry] = []         // å·¥ä½œè¨˜éŒ„
    @Relationship(deleteRule: .cascade) var relationships: [CategoryEntry] = [] // é—œä¿‚è¨˜éŒ„
    @Relationship(deleteRule: .cascade) var studies: [CategoryEntry] = []       // å­¸ç¿’è¨˜éŒ„
    
    /// åˆå§‹åŒ–æ–¹æ³•
    init(date: Date = Date(), weather: WeatherType = .sunny, thoughts: String = "", temperature: String = "") {
        self.id = UUID()
        self.date = date
        self.weatherRaw = weather.rawValue
        self.thoughts = thoughts
        self.temperature = temperature
    }
}

// MARK: - åˆ†é¡æ¢ç›®æ¨¡å‹
/// åˆ†é¡è¨˜éŒ„æ¢ç›®æ¨¡å‹
@Model
final class CategoryEntry {
    @Attribute(.unique) var id: UUID  // å”¯ä¸€æ¨™è­˜ç¬¦
    var typeRaw: String               // åˆ†é¡é¡å‹ï¼ˆåŸå§‹å­—ç¬¦ä¸²ï¼‰
    var name: String                  // åç¨±/å“è³ª/å§“å
    var category: String              // é¡åˆ¥/æ™‚é–“
    var number: Double                // é‡‘é¡/çµ„æ•¸/é†’ä¾†æ¬¡æ•¸/æ™‚é•·
    var notes: String                 // å‚™æ³¨
    
    /// åˆ†é¡é¡å‹çš„è¨ˆç®—å±¬æ€§
    var type: CategoryType {
        get { CategoryType(rawValue: typeRaw) ?? .expense }
        set { typeRaw = newValue.rawValue }
    }
    
    /// åˆå§‹åŒ–æ–¹æ³•
    init(type: CategoryType, name: String = "", category: String = "", number: Double = 0.0, notes: String = "") {
        self.id = UUID()
        self.typeRaw = type.rawValue
        self.name = name
        self.category = category
        self.number = number
        self.notes = notes
    }
}

// MARK: - WeatherTypeTransformer & CategoryTypeTransformer å¯èƒ½é‡è¤‡ä¸å¿…è¦çš„è½‰æ›å™¨
// WeatherType è½‰æ›å™¨ - é€™äº›è½‰æ›å™¨ä¼¼ä¹èˆ‡ SwiftData çš„ç·¨ç¢¼è§£ç¢¼åŠŸèƒ½é‡è¤‡ï¼Œå¯ä»¥è€ƒæ…®åˆªé™¤
class WeatherTypeTransformer: ValueTransformer {
//    override class func transformedValueClass() -> AnyClass {
//        return NSString.self
//    }
//    
//    override class func allowsReverseTransformation() -> Bool {
//        return true
//    }
//    
//    override func transformedValue(_ value: Any?) -> Any? {
//        guard let type = value as? WeatherType else { return nil }
//        return type.rawValue
//    }
//    
//    override func reverseTransformedValue(_ value: Any?) -> Any? {
//        guard let string = value as? String else { return nil }
//        return WeatherType(rawValue: string)
//    }
}

// è¨»å†Š WeatherType è½‰æ›å™¨
extension WeatherTypeTransformer {
//    static let name = NSValueTransformerName("WeatherTypeTransformer")
//    
//    static func register() {
//        let transformer = WeatherTypeTransformer()
//        ValueTransformer.setValueTransformer(transformer, forName: name)
//    }
}

// CategoryType è½‰æ›å™¨
class CategoryTypeTransformer: ValueTransformer {
//    override class func transformedValueClass() -> AnyClass {
//        return NSString.self
//    }
//    
//    override class func allowsReverseTransformation() -> Bool {
//        return true
//    }
//    
//    override func transformedValue(_ value: Any?) -> Any? {
//        guard let type = value as? CategoryType else { return nil }
//        return type.rawValue
//    }
//    
//    override func reverseTransformedValue(_ value: Any?) -> Any? {
//        guard let string = value as? String else { return nil }
//        return CategoryType(rawValue: string)
//    }
}

// è¨»å†Š CategoryType è½‰æ›å™¨
extension CategoryTypeTransformer {
//    static let name = NSValueTransformerName("CategoryTypeTransformer")
//    
//    static func register() {
//        let transformer = CategoryTypeTransformer()
//        ValueTransformer.setValueTransformer(transformer, forName: name)
//    }
}

// MARK: - ä¸»è¡¨å–®è¦–åœ–èˆ‡ NewDiaryView åŠŸèƒ½é‡è¤‡
struct MainDiaryForm: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var modelContext
    @State private var date = Date()
    @State private var selectedWeather = WeatherType.sunny.rawValue
    @State private var thoughts = ""
    
    // æ·»åŠ å­—ä½“é¢œè‰²è®¾ç½®
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    var body: some View {
        NavigationStack {
            Form {
                // ä½¿ç”¨è‡ªå®šä¹‰æ—¥æœŸé€‰æ‹©å™¨
                HStack {
                    Text("æ—¥æœŸ")
                        .font(.system(size: 20))
                    Spacer()
                    CustomDatePickerView(
                        selectedDate: $date,
                        titleFontColor: titleFontColor,
                        contentFontColor: contentFontColor
                    )
                    .help("é¸æ“‡è¦æŸ¥çœ‹çš„æ—¥æœŸ")
                }
                .padding(.vertical, 5)
                
                Section("å¤©æ°£") {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 15) {
                            ForEach(WeatherType.allCases, id: \.self) { weather in
                                VStack {
                                    Image(systemName: weather.icon)
                                        .font(.system(size: 22))
                                        .foregroundColor(selectedWeather == weather.rawValue ? .blue : .gray)
                                        .padding(8)
                                        .background(
                                            Circle()
                                                .fill(selectedWeather == weather.rawValue ? Color.blue.opacity(0.2) : Color.clear)
                                        )
                                    Text(weather.rawValue)
                                        .font(.system(size: 20))
                                }
                                .onTapGesture {
                                    selectedWeather = weather.rawValue
                                }
                            }
                        }
                    }
                    .frame(height: 80)
                }
                
                Section(header: Text("å¿ƒå¾—")) {
                    TextEditor(text: $thoughts)
                        .frame(height: 100)
                }
            }
            .navigationTitle("æ–°å¢æ—¥èªŒ")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("å–æ¶ˆ") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("ä¿å­˜") {
                        let newDiary = DiaryEntry(date: date, weather: WeatherType(rawValue: selectedWeather) ?? .sunny, thoughts: thoughts)
                        modelContext.insert(newDiary)
                        dismiss()
                    }
                }
            }
        }
    }
}

struct CategoryEntryForm: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var modelContext
    let type: CategoryType
    let diary: DiaryEntry
    var editingEntry: CategoryEntry? = nil
    
    @State private var name = ""
    @State private var category = ""
    @State private var number: Double = 0
    @State private var numberString = "0"
    @State private var notes = ""
    @State private var showNumberError = false
    @State private var showingCategoryPicker = false
    @FocusState private var isCategoryFocused: Bool
    
    // æ–°å¢çš„ç‹€æ…‹è®Šæ•¸ï¼Œç”¨æ–¼è‡ªå‹•å®ŒæˆåŠŸèƒ½
    @State private var suggestions: [String] = []
    @State private var showingSuggestions = false
    @State private var selectedSuggestionIndex = 0
    @Query private var allDiaries: [DiaryEntry]
    
    init(type: CategoryType, diary: DiaryEntry, editingEntry: CategoryEntry? = nil) {
        self.type = type
        self.diary = diary
        self.editingEntry = editingEntry
        
        let initialName = editingEntry?.name ?? ""
        let initialCategory = editingEntry?.category ?? ""
        let initialNumber = editingEntry?.number ?? 0
        let initialNotes = editingEntry?.notes ?? ""
        
        _name = State(initialValue: initialName)
        _category = State(initialValue: initialCategory)
        _number = State(initialValue: initialNumber)
        
        // å¦‚æœæ˜¯æ™‚é–“ç›¸é—œé …ç›®ï¼Œæ ¼å¼åŒ–ç‚ºh:mmæ ¼å¼
        if  editingEntry != nil,
           (type == .exercise || type == .sleep || type == .work || type == .relationship || type == .study) {
            _numberString = State(initialValue: formatMinutesToTimeString(Int(initialNumber)))
        } else {
            _numberString = State(initialValue: String(format: "%.0f", initialNumber))
        }
        
        _notes = State(initialValue: initialNotes)
    }
    
    private func validateAndUpdateNumber(_ newValue: String) {
        if let parsedNumber = Double(newValue.replacingOccurrences(of: ".", with: "")) {
            if parsedNumber >= 0 && parsedNumber <= 999999 {
                number = parsedNumber
                numberString = String(format: "%.0f", parsedNumber)
                showNumberError = false
            } else {
                showNumberError = true
            }
        } else {
            showNumberError = true
        }
    }
    
    // ç²å–ä»¥å‰è¼¸å…¥éçš„åç¨±åˆ—è¡¨
    private func getPreviousNames() -> [String] {
        var names = Set<String>()
        
        for diary in allDiaries {
            let entries: [CategoryEntry]
            switch type {
            case .expense:
                entries = diary.expenses
            case .exercise:
                entries = diary.exercises
            case .sleep:
                entries = diary.sleeps
            case .work:
                entries = diary.works
            case .relationship:
                entries = diary.relationships
            case .study:
                entries = diary.studies
            }
            
            for entry in entries {
                if !entry.name.isEmpty {
                    names.insert(entry.name)
                }
            }
        }
        
        return Array(names).sorted()
    }
    
    // æ ¹æ“šè¼¸å…¥ç”Ÿæˆå»ºè­°
    private func updateSuggestions() {
        if name.isEmpty {
            showingSuggestions = false
            return
        }
        
        let allNames = getPreviousNames()
        suggestions = allNames.filter { $0.localizedCaseInsensitiveContains(name) && $0 != name }
        
        showingSuggestions = !suggestions.isEmpty
        selectedSuggestionIndex = 0
    }
    
    // é¸æ“‡å»ºè­°
    private func selectSuggestion(_ suggestion: String) {
        name = suggestion
        showingSuggestions = false
    }
    
    // è™•ç†Tabéµè‡ªå‹•å®Œæˆ
    private func handleTabKey() {
        if showingSuggestions && !suggestions.isEmpty {
            name = suggestions[selectedSuggestionIndex]
            showingSuggestions = false
        }
    }
    
    var body: some View {
        NavigationStack {
            Form {
                NameSectionWithAutocomplete(
                    type: type,
                    name: $name,
                    suggestions: suggestions,
                    showingSuggestions: $showingSuggestions,
                    selectedSuggestionIndex: $selectedSuggestionIndex,
                    onNameChanged: updateSuggestions,
                    onSuggestionSelected: selectSuggestion,
                    onTabPressed: handleTabKey
                )
                CategorySection(type: type, category: $category)
                NumberSection(
                    type: type,
                    numberString: $numberString,
                    number: $number,
                    showNumberError: $showNumberError,
                    validateAndUpdateNumber: validateAndUpdateNumber
                )
                NotesSection(notes: $notes)
            }
            .formStyle(.grouped)
            .navigationTitle(editingEntry == nil ? "æ–°å¢\(type.rawValue)è¨˜éŒ„" : "ç·¨è¼¯\(type.rawValue)è¨˜éŒ„")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("å–æ¶ˆ") { dismiss() }
                        .font(.system(size: 20))
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("ä¿å­˜") {
                        if let editingEntry = editingEntry {
                            editingEntry.name = name
                            editingEntry.category = category
                            editingEntry.number = number
                            editingEntry.notes = notes
                        } else {
                            let entry = CategoryEntry(type: type, name: name, category: category, number: number, notes: notes)
                            switch type {
                            case .expense: diary.expenses.append(entry)
                            case .exercise: diary.exercises.append(entry)
                            case .sleep: diary.sleeps.append(entry)
                            case .work: diary.works.append(entry)
                            case .relationship: diary.relationships.append(entry)
                            case .study: diary.studies.append(entry)
                            }
                        }
                        try? modelContext.save()
                        dismiss()
                    }
                    .disabled(showNumberError)
                    .font(.system(size: 20))
                }
            }
            .onAppear {
                updateSuggestions()
            }
        }
        .frame(minWidth: 300, minHeight: 200)
    }
}

// MARK: - CategoryEntryForm Subviews
private struct NameSection: View {
    let type: CategoryType
    @Binding var name: String
    
    var nameLabel: String {
        switch type {
        case .expense: return "åç¨±"
        case .exercise: return "åç¨±"
        case .sleep: return "å“è³ª"
        case .work: return "åç¨±"
        case .relationship: return "å§“å"
        case .study: return "åç¨±"
        }
    }
    
    var body: some View {
        Section {
            HStack {
                Image(systemName: type.icon)
                    .foregroundColor(.blue)
                    .font(.system(size: 20))
                Text(nameLabel)
                    .foregroundColor(.secondary)
                    .font(.system(size: 20))
                Spacer()
                TextField("", text: $name)
                    .textFieldStyle(.plain)
                    .font(.system(size: 20))
                    .multilineTextAlignment(.trailing)
            }
        }
    }
}

private struct CategorySection: View {
    let type: CategoryType
    @Binding var category: String
    @FocusState private var isCategoryFocused: Bool
    @State private var showingSuggestions = false
    @State private var suggestions: [String] = []
    @State private var selectedSuggestionIndex = 0
    @Query private var allDiaries: [DiaryEntry]
    
    // æ ¹æ®åˆ†ç±»ç±»å‹æ˜¾ç¤ºä¸åŒçš„æ ‡ç­¾æ–‡æœ¬
    var categoryLabel: String {
        switch type {
        case .expense: return "é¡åˆ¥"
        case .exercise: return "é‹å‹•é¡å‹"
        case .sleep: return "é†’ä¾†æ¬¡æ•¸"
        case .work: return "å·¥ä½œé¡å‹"
        case .relationship: return "é—œä¿‚é¡å‹"
        case .study: return "å­¸ç¿’é¡å‹"
        }
    }
    
    // ç²å–ä»¥å‰è¼¸å…¥éçš„é¡åˆ¥åˆ—è¡¨
    private func getPreviousCategories() -> [String] {
        var categories = Set<String>()
        
        // æ·»åŠ é å®šç¾©çš„é¡åˆ¥
        for category in type.predefinedCategories {
            categories.insert(category)
        }
        
        // æ·»åŠ ä»¥å‰ä½¿ç”¨éçš„é¡åˆ¥
        for diary in allDiaries {
            let entries: [CategoryEntry]
            switch type {
            case .expense:
                entries = diary.expenses
            case .exercise:
                entries = diary.exercises
            case .sleep:
                entries = diary.sleeps
            case .work:
                entries = diary.works
            case .relationship:
                entries = diary.relationships
            case .study:
                entries = diary.studies
            }
            
            for entry in entries {
                if !entry.category.isEmpty {
                    categories.insert(entry.category)
                }
            }
        }
        
        return Array(categories).sorted()
    }
    
    // æ ¹æ“šè¼¸å…¥ç”Ÿæˆå»ºè­°
    private func updateSuggestions() {
        if category.isEmpty {
            showingSuggestions = false
            return
        }
        
        let allCategories = getPreviousCategories()
        suggestions = allCategories.filter { $0.localizedCaseInsensitiveContains(category) && $0 != category }
        
        showingSuggestions = !suggestions.isEmpty
        selectedSuggestionIndex = 0
    }
    
    // é¸æ“‡å»ºè­°
    private func selectSuggestion(_ suggestion: String) {
        category = suggestion
        showingSuggestions = false
    }
    
    // è™•ç†Tabéµè‡ªå‹•å®Œæˆ
    private func handleTabKey() {
        if showingSuggestions && !suggestions.isEmpty {
            category = suggestions[selectedSuggestionIndex]
            showingSuggestions = false
        }
    }
    
    var body: some View {
        Section {
            if type != .sleep {
                HStack {
                    Image(systemName: "tag.fill")
                        .foregroundColor(.blue)
                        .font(.system(size: 20))
                    Text(categoryLabel)
                        .foregroundColor(.secondary)
                        .font(.system(size: 20))
                    Spacer()
                    
                    // ç§»é™¤æ¡ä»¶åˆ¤æ–­ï¼Œå§‹ç»ˆæ˜¾ç¤ºè¾“å…¥æ¡†
                    VStack(alignment: .trailing, spacing: 0) {
                        HStack {
                            TextField("", text: $category)
                                .textFieldStyle(.plain)
                                .font(.system(size: 20))
                                .multilineTextAlignment(.trailing)
                                .focused($isCategoryFocused)
                                .onChange(of: category) { oldValue, newValue in
                                    updateSuggestions()
                                }
                                .onSubmit {
                                    showingSuggestions = false
                                }
                                .onKeyPress(.tab) {
                                    handleTabKey()
                                    return .handled
                                }
                                .help("è¼¸å…¥é¡åˆ¥ï¼ŒæŒ‰Tabå¯è‡ªå‹•å¡«å¯«")
                        }
                        
                        if showingSuggestions && isCategoryFocused {
                            ScrollView {
                                LazyVStack(alignment: .trailing, spacing: 8) {
                                    ForEach(Array(suggestions.enumerated()), id: \.element) { index, suggestion in
                                        Text(suggestion)
                                            .font(.system(size: 18))
                                            .padding(.vertical, 4)
                                            .padding(.horizontal, 8)
                                            .frame(maxWidth: .infinity, alignment: .trailing)
                                            .background(index == selectedSuggestionIndex ? Color.blue.opacity(0.2) : Color.clear)
                                            .cornerRadius(4)
                                            .contentShape(Rectangle())
                                            .onTapGesture {
                                                selectSuggestion(suggestion)
                                            }
                                            .onHover { isHovered in
                                                if isHovered {
                                                    selectedSuggestionIndex = index
                                                }
                                            }
                                            .customCursor(.pointingHand)
                                    }
                                }
                            }
                            .frame(maxHeight: 150)
                            .background(Color(NSColor.windowBackgroundColor))
                            .overlay(
                                RoundedRectangle(cornerRadius: 5)
                                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                            )
                            .padding(.top, 4)
                        }
                    }
                    
                    // æ³¨é‡Šæ‰ä¸‹æ‹‰èœå•éƒ¨åˆ†
                    /*
                    } else {
                        Menu {
                            ForEach(type.predefinedCategories, id: \.self) { predefinedCategory in
                                Button(predefinedCategory) {
                                    category = predefinedCategory
                                }
                                .font(.system(size: 20))
                            }
                            
                            Divider()
                            
                            Button("è‡ªå®šç¾©...") {
                                isCustomizing = true
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                    isCategoryFocused = true
                                    updateSuggestions()
                                }
                            }
                        } label: {
                            Text(category.isEmpty ? "é¸æ“‡é¡åˆ¥" : category)
                                .foregroundColor(category.isEmpty ? .secondary : .primary)
                                .font(.system(size: 20))
                            Image(systemName: "chevron.down")
                                .font(.system(size: 16))
                                .foregroundColor(.secondary)
                        }
                        .menuStyle(.borderlessButton)
                        .customCursor(.pointingHand)
                        .help("é¸æ“‡æˆ–è‡ªå®šç¾©é¡åˆ¥")
                    }
                    */
                }
            } else {
                HStack {
                    Image(systemName: "tag.fill")
                        .foregroundColor(.blue)
                        .font(.system(size: 20))
                    Text(categoryLabel)
                        .foregroundColor(.secondary)
                        .font(.system(size: 20))
                    Spacer()
                    TextField("", text: $category)
                        .textFieldStyle(.plain)
                        .font(.system(size: 20))
                        .multilineTextAlignment(.trailing)
                        .focused($isCategoryFocused)
                        .onChange(of: category) { oldValue, newValue in
                            updateSuggestions()
                        }
                        .onSubmit {
                            showingSuggestions = false
                        }
                        .onKeyPress(.tab) {
                            handleTabKey()
                            return .handled
                        }
                        .help("è¼¸å…¥é†’ä¾†æ¬¡æ•¸ï¼ŒæŒ‰Tabå¯è‡ªå‹•å¡«å¯«")
                }
                
                if showingSuggestions && isCategoryFocused {
                    ScrollView {
                        LazyVStack(alignment: .trailing, spacing: 8) {
                            ForEach(Array(suggestions.enumerated()), id: \.element) { index, suggestion in
                                Text(suggestion)
                                    .font(.system(size: 18))
                                    .padding(.vertical, 4)
                                    .padding(.horizontal, 8)
                                    .frame(maxWidth: .infinity, alignment: .trailing)
                                    .background(index == selectedSuggestionIndex ? Color.blue.opacity(0.2) : Color.clear)
                                    .cornerRadius(4)
                                    .contentShape(Rectangle())
                                    .onTapGesture {
                                        selectSuggestion(suggestion)
                                    }
                                    .onHover { isHovered in
                                        if isHovered {
                                            selectedSuggestionIndex = index
                                        }
                                    }
                                    .customCursor(.pointingHand)
                            }
                        }
                    }
                    .frame(maxHeight: 150)
                    .background(Color(NSColor.windowBackgroundColor))
                    .overlay(
                        RoundedRectangle(cornerRadius: 5)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
                    .padding(.top, 4)
                }
            }
        }
    }
}

private struct NumberSection: View {
    let type: CategoryType
    @Binding var numberString: String
    @Binding var number: Double
    @Binding var showNumberError: Bool
    let validateAndUpdateNumber: (String) -> Void
    
    var numberLabel: String {
        switch type {
        case .expense: return "é‡‘é¡"
        case .exercise: return "æ™‚é–“"
        case .sleep: return "æ™‚é–“"
        case .work: return "æ™‚é•·"
        case .relationship: return "æ™‚é•·"
        case .study: return "æ™‚é•·"
        }
    }
    
    var body: some View {
        Section {
            VStack(alignment: .leading, spacing: 8) {
                HStack {
                    Image(systemName: "number.circle.fill")
                        .foregroundColor(.blue)
                        .font(.system(size: 20))
                    Text(numberLabel)
                        .foregroundColor(.secondary)
                        .font(.system(size: 20))
                    Spacer()
                    TextField(
                        "è¼¸å…¥\(numberLabel)\(type == .exercise || type == .sleep || type == .work || type == .relationship || type == .study ? "ï¼ˆh:mmæˆ–åˆ†é˜ï¼‰" : "")",
                        text: $numberString
                    )
                    .font(.system(size: 14))
                    .onChange(of: numberString) { oldValue, newValue in
                        if type == .exercise || type == .sleep || type == .work || type == .relationship || type == .study {
                            // å¦‚æœæ˜¯æ™‚é–“ç›¸é—œæ¢ç›®ï¼Œå…è¨±h:mmæ ¼å¼
                            if newValue.contains(":") {
                                processTimeFormat(newValue)
                            } else {
                                // ç´”æ•¸å­—è¼¸å…¥æ™‚ï¼Œåƒ…å…è¨±æ•¸å­—
                                let filtered = newValue.filter { "0123456789".contains($0) }
                                if filtered != newValue {
                                    numberString = filtered
                                }
                                validateAndUpdateNumber(filtered)
                            }
                        } else {
                            // å…¶ä»–é¡å‹ï¼ˆå¦‚é‡‘é¡ï¼‰åªæ¥å—æ•¸å­—
                            let filtered = newValue.filter { "0123456789".contains($0) }
                            if filtered != newValue {
                                numberString = filtered
                            }
                            validateAndUpdateNumber(filtered)
                        }
                    }
                    .font(.system(size: 20))
                    
                    Stepper("", value: $number, in: 0...9999, step: 1) { _ in
                        if type == .exercise || type == .sleep || type == .work || type == .relationship || type == .study {
                            // æ™‚é–“ç›¸é—œæ¢ç›®é¡¯ç¤ºç‚ºh:mm
                            numberString = formatMinutesToTimeString(Int(number))
                        } else {
                            numberString = String(format: "%.0f", number)
                        }
                    }
                }
                
                if showNumberError {
                    Text("è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å€¼æˆ–æ™‚é–“æ ¼å¼")
                        .foregroundColor(.red)
                        .font(.system(size: 20))
                }
            }
        }
    }
    
    // è™•ç†h:mmæ ¼å¼çš„æ™‚é–“è¼¸å…¥
    private func processTimeFormat(_ input: String) {
        // åˆ†å‰²å°æ™‚å’Œåˆ†é˜
        let components = input.split(separator: ":")
        
        if components.count == 2,
           let hours = Int(components[0]),
           let minutes = Int(components[1]),
           hours >= 0 && hours <= 99,
           minutes >= 0 && minutes <= 59 {
            
            // è¨ˆç®—ç¸½åˆ†é˜æ•¸
            let totalMinutes = hours * 60 + minutes
            
            if totalMinutes <= 9999 {
                number = Double(totalMinutes)
                numberString = input  // ä¿æŒh:mmæ ¼å¼
                showNumberError = false
            } else {
                showNumberError = true
            }
        } else {
            showNumberError = true
        }
    }
}

// å°‡åˆ†é˜æ•¸æ ¼å¼åŒ–ç‚ºh:mmæ ¼å¼
func formatMinutesToTimeString(_ minutes: Int) -> String {
    let hours = minutes / 60
    let mins = minutes % 60
    return String(format: "%d:%02d", hours, mins)
}

private struct NotesSection: View {
    @Binding var notes: String
    
    var body: some View {
        Section {
            VStack(alignment: .leading) {
                HStack {
                    Image(systemName: "text.bubble.fill")
                        .foregroundColor(.blue)
                        .font(.system(size: 20))
                    Text("å‚™æ³¨")
                        .foregroundColor(.secondary)
                        .font(.system(size: 20))
                }
                
                TextEditor(text: $notes)
                    .font(.system(size: 16))
                    .frame(height: 100)
                    .cornerRadius(4)
            }
            .padding(.vertical, 4)
        }
    }
}

struct CategoryTableView: View {
    let type: CategoryType
    let entries: [CategoryEntry]
    let diary: DiaryEntry
    let onAdd: () -> Void
    let onDelete: (IndexSet) -> Void
    let onEdit: (CategoryEntry) -> Void
    
    // âš ï¸ é€™è£¡çš„ @AppStorage å®£å‘Šèˆ‡å…¶ä»–è¦–åœ–é‡è¤‡ï¼Œè€ƒæ…®å‰µå»ºä¸€å€‹å…±äº«è¨­å®šç‰©ä»¶
    @AppStorage("titleFontSize") private var titleFontSize: Double = 22
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    // ç›®æ¨™åå¥½è¨­ç½®ä¹Ÿå¯ä»¥æ•´åˆåˆ°å…±äº«è¨­å®šç‰©ä»¶ä¸­
    @AppStorage("monthlyExpenseLimit") private var monthlyExpenseLimit: Double = 20000
    @AppStorage("dailyExerciseGoal") private var dailyExerciseGoal: Double = 60
    @AppStorage("dailySleepGoal") private var dailySleepGoal: Double = 390
    @AppStorage("dailyWorkGoal") private var dailyWorkGoal: Double = 120
    @AppStorage("dailyRelationshipGoal") private var dailyRelationshipGoal: Double = 30
    @AppStorage("dailyStudyGoal") private var dailyStudyGoal: Double = 60
    
    var total: Double {
        entries.reduce(0) { $0 + $1.number }
    }
    
    // è®¡ç®—æœˆåº¦åˆè®¡
    var monthlyTotal: Double {
        let calendar = Calendar.current
        let currentMonth = calendar.component(.month, from: diary.date)
        let currentYear = calendar.component(.year, from: diary.date)
        
        // è·å–æ‰€æœ‰æ—¥è®°æ¡ç›®
        let modelContext = diary.modelContext
        let descriptor = FetchDescriptor<DiaryEntry>()
        guard let allDiaries = try? modelContext?.fetch(descriptor) else { return 0 }
        
        // è¿‡æ»¤å‡ºåŒæœˆçš„æ—¥è®°æ¡ç›®
        let monthDiaries = allDiaries.filter { entry in
            let entryMonth = calendar.component(.month, from: entry.date)
            let entryYear = calendar.component(.year, from: entry.date)
            return entryMonth == currentMonth && entryYear == currentYear
        }
        
        // æ ¹æ®ç±»å‹è·å–å¹¶è®¡ç®—åˆè®¡
        let monthlyEntries = monthDiaries.flatMap { diary -> [CategoryEntry] in
            switch type {
            case .expense: return diary.expenses
            case .exercise: return diary.exercises
            case .sleep: return diary.sleeps
            case .work: return diary.works
            case .relationship: return diary.relationships
            case .study: return diary.studies
            }
        }
        
        return monthlyEntries.reduce(0) { $0 + $1.number }
    }
    
    var nameLabel: String {
        switch type {
        case .expense: return "åç¨±"
        case .exercise: return "åç¨±"
        case .sleep: return "å“è³ª"
        case .work: return "åç¨±"
        case .relationship: return "å§“å"
        case .study: return "åç¨±"
        }
    }
    
    var categoryLabel: String {
        switch type {
        case .expense: return "é¡åˆ¥"
        case .exercise: return "é‹å‹•é¡å‹"
        case .sleep: return "é†’ä¾†æ¬¡æ•¸"
        case .work: return "å·¥ä½œé¡å‹"
        case .relationship: return "é—œä¿‚é¡å‹"
        case .study: return "å­¸ç¿’é¡å‹"
        }
    }
    
    var numberLabel: String {
        switch type {
        case .expense: return "é‡‘é¡"
        case .exercise: return "æ™‚é–“"
        case .sleep: return "æ™‚é–“"
        case .work: return "æ™‚é•·"
        case .relationship: return "æ™‚é•·"
        case .study: return "æ™‚é•·"
        }
    }
    
    var body: some View {
        VStack(spacing: 16) {
            HStack {
                Label(type.rawValue, systemImage: type.icon)
                    .font(.system(size: titleFontSize))
                    .fontWeight(.bold)
                    .foregroundColor(Color.fromString(titleFontColor))
                Spacer()
                Button(action: onAdd) {
                    Label("æ–°å¢", systemImage: "plus.circle.fill")
                        .font(.system(size: contentFontSize))
                        .foregroundColor(.blue)
                }
                .buttonStyle(.plain)
            }
            
            Table(entries) {
                TableColumn(nameLabel) { entry in
                    Text(entry.name)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .font(.system(size: contentFontSize))
                        .foregroundColor(Color.fromString(contentFontColor))
                }
                TableColumn(categoryLabel) { entry in
                    Text(entry.category)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .font(.system(size: contentFontSize))
                        .foregroundColor(Color.fromString(contentFontColor))
                }
                TableColumn(numberLabel) { entry in
                    if type == .expense {
                        Text(String(format: "%.0f", entry.number))
                            .frame(maxWidth: .infinity, alignment: .trailing)
                            .font(.system(size: contentFontSize))
                            .monospacedDigit()
                            .foregroundColor(Color.fromString(contentFontColor))
                    } else {
                        // æ™‚é–“ç›¸é—œæ¢ç›®é¡¯ç¤ºç‚ºh:mm
                        Text(formatMinutesToTimeString(Int(entry.number)))
                            .frame(maxWidth: .infinity, alignment: .trailing)
                            .font(.system(size: contentFontSize))
                            .monospacedDigit()
                            .foregroundColor(Color.fromString(contentFontColor))
                    }
                }
                TableColumn("å‚™æ³¨") { entry in
                    Text(entry.notes)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .font(.system(size: contentFontSize))
                        .foregroundColor(.secondary)
                }
                TableColumn("æ“ä½œ") { entry in
                    HStack(spacing: 16) {
                        Button(action: { onEdit(entry) }) {
                            Image(systemName: "pencil.circle.fill")
                                .foregroundColor(.blue)
                                .font(.system(size: contentFontSize))
                        }
                        .buttonStyle(.plain)
                        
                        Button(action: {
                            if let index = entries.firstIndex(where: { $0.id == entry.id }) {
                                onDelete(IndexSet([index]))
                            }
                        }) {
                            Image(systemName: "trash.circle.fill")
                                .foregroundColor(.red)
                                .font(.system(size: contentFontSize))
                        }
                        .buttonStyle(.plain)
                    }
                    .frame(maxWidth: .infinity, alignment: .center)
                }
            }
            .frame(minHeight: 100)
            
            HStack {
                // æœˆåˆè®¡
                HStack {
                    Label("æœˆåˆè¨ˆ: ", systemImage: "calendar")
                    Group {
                        switch type {
                        case .expense:
                            // æ”¯å‡ºï¼šè¶…å‡ºæœˆæ”¯å‡ºä¸Šé™å‰‡é¡¯ç¤ºç´…è‰²å’ŒğŸ˜©è¡¨æƒ…ç¬¦è™Ÿï¼Œæœªè¶…å‡ºé¡¯ç¤ºç¶ è‰²å’ŒğŸ˜
                            let isOverLimit = monthlyTotal > monthlyExpenseLimit
                            Text(String(format: "%.0f", monthlyTotal))
                                .monospacedDigit()
                                .foregroundColor(isOverLimit ? .red : .green)
                            Text("\(isOverLimit ? "ğŸ¥µ" : "ğŸ˜") å…ƒ")
                        case .exercise, .sleep, .work, .relationship, .study:
                            Text(formatMinutesToTimeString(Int(monthlyTotal))).monospacedDigit()
                            Text(" (\(String(format: "%.0f", monthlyTotal))åˆ†é˜)")
                        }
                    }
                }
                .font(.system(size: contentFontSize))
                
                Spacer()
                
                // å°è®¡
                HStack {
                    Label("å°è¨ˆ: ", systemImage: "sum")
                    Group {
                        switch type {
                        case .expense:
                            Text(String(format: "%.0f", total)).monospacedDigit()
                            Text(" å…ƒ")
                        case .exercise:
                            // é‹å‹•ï¼šé”åˆ°æˆ–è¶…éæ¯æ—¥ç›®æ¨™é¡¯ç¤ºç¶ è‰²å’ŒğŸ˜ï¼Œæœªé”åˆ°é¡¯ç¤ºç´…è‰²å’ŒğŸ¥µ
                            let isGoalMet = total >= dailyExerciseGoal
                            Text(formatMinutesToTimeString(Int(total)))
                                .monospacedDigit()
                                .foregroundColor(isGoalMet ? .green : .red)
                            Text("\(isGoalMet ? "ğŸ˜" : "ğŸ¥µ") (\(String(format: "%.0f", total))åˆ†é˜)")
                        case .sleep:
                            // ç¡çœ ï¼šé”åˆ°æˆ–è¶…éæ¯æ—¥ç›®æ¨™é¡¯ç¤ºç¶ è‰²å’ŒğŸ˜ï¼Œæœªé”åˆ°é¡¯ç¤ºç´…è‰²å’ŒğŸ¥µ
                            let isGoalMet = total >= dailySleepGoal
                            Text(formatMinutesToTimeString(Int(total)))
                                .monospacedDigit()
                                .foregroundColor(isGoalMet ? .green : .red)
                            Text("\(isGoalMet ? "ğŸ˜" : "ğŸ¥µ") (\(String(format: "%.0f", total))åˆ†é˜)")
                        case .work:
                            // å·¥ä½œï¼šé”åˆ°æˆ–è¶…éæ¯æ—¥ç›®æ¨™é¡¯ç¤ºç¶ è‰²å’ŒğŸ˜ï¼Œæœªé”åˆ°é¡¯ç¤ºç´…è‰²å’ŒğŸ¥µ
                            let isGoalMet = total >= dailyWorkGoal
                            Text(formatMinutesToTimeString(Int(total)))
                                .monospacedDigit()
                                .foregroundColor(isGoalMet ? .green : .red)
                            Text("\(isGoalMet ? "ğŸ˜" : "ğŸ¥µ") (\(String(format: "%.0f", total))åˆ†é˜)")
                        case .relationship:
                            // é—œä¿‚ï¼šé”åˆ°æˆ–è¶…éæ¯æ—¥ç›®æ¨™é¡¯ç¤ºç¶ è‰²å’ŒğŸ˜ï¼Œæœªé”åˆ°é¡¯ç¤ºç´…è‰²å’ŒğŸ¥µ
                            let isGoalMet = total >= dailyRelationshipGoal
                            Text(formatMinutesToTimeString(Int(total)))
                                .monospacedDigit()
                                .foregroundColor(isGoalMet ? .green : .red)
                            Text("\(isGoalMet ? "ğŸ˜" : "ğŸ¥µ") (\(String(format: "%.0f", total))åˆ†é˜)")
                        case .study:
                            // å­¸ç¿’ï¼šé”åˆ°æˆ–è¶…éæ¯æ—¥ç›®æ¨™é¡¯ç¤ºç¶ è‰²å’ŒğŸ˜ï¼Œæœªé”åˆ°é¡¯ç¤ºç´…è‰²å’ŒğŸ¥µ
                            let isGoalMet = total >= dailyStudyGoal
                            Text(formatMinutesToTimeString(Int(total)))
                                .monospacedDigit()
                                .foregroundColor(isGoalMet ? .green : .red)
                            Text("\(isGoalMet ? "ğŸ˜" : "ğŸ¥µ") (\(String(format: "%.0f", total))åˆ†é˜)")
                        }
                    }
                }
                .font(.system(size: contentFontSize))
            }
            .padding(.top, 8)
        }
        .padding()
    }
}

// MARK: - å‚™ä»½æ•¸æ“šçµæ§‹
/// ç”¨æ–¼å‚™ä»½çš„æ•¸æ“šçµæ§‹
struct DiaryBackup: Codable {
    var entries: [DiaryBackupEntry]
    
    struct DiaryBackupEntry: Codable {
        var id: UUID
        var date: Date
        var weatherRaw: String
        var thoughts: String
        var temperature: String
        var expenses: [CategoryBackupEntry]
        var exercises: [CategoryBackupEntry]
        var sleeps: [CategoryBackupEntry]
        var works: [CategoryBackupEntry]
        var relationships: [CategoryBackupEntry]
        var studies: [CategoryBackupEntry]
    }
    
    struct CategoryBackupEntry: Codable {
        var id: UUID
        var typeRaw: String
        var name: String
        var category: String
        var number: Double
        var notes: String
    }
}

// MARK: - ä¸»è¦–åœ–
/// æ‡‰ç”¨ç¨‹åºçš„ä¸»è¦–åœ–ï¼ŒåŒ…å«æ—¥è¨˜åˆ—è¡¨å’Œè©³ç´°å…§å®¹
struct ContentView: View {
    @Environment(\.modelContext) private var modelContext
    @Query(sort: \DiaryEntry.date, order: .reverse) private var diaries: [DiaryEntry]
    @State private var selectedDiary: DiaryEntry?
    @State private var showingNewDiarySheet = false
    @State private var showingExportSheet = false
    @State private var showingImportSheet = false
    @State private var showingAlert = false
    @State private var alertTitle = ""
    @State private var alertMessage = ""
    @State private var startDate = Date.now.addingTimeInterval(-30*24*60*60)
    @State private var endDate = Date.now
    @State private var showingDateRangeSheet = false
    @State private var isExporting = false
    @State private var selectedDate = Date()  // é¸æ“‡çš„æ—¥æœŸ
    @State private var showingPreferencesSheet = false // é¡¯ç¤ºåå¥½è¨­ç½®è¦–åœ–
    @State private var showingHelpSheet = false // é¡¯ç¤ºä½¿ç”¨èªªæ˜è¦–åœ–
    
    // æœå°‹åŠŸèƒ½
    @State private var searchText = ""
    @State private var searchResults: [SearchResult] = []
    @State private var currentResultIndex: Int = -1
    @State private var showSearchField = false
    
    // ç”¨æˆ¶åå¥½è¨­ç½®
    @AppStorage("titleFontSize") private var titleFontSize: Double = 22
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    // åªåŸºäºæ—¥æœŸè¿‡æ»¤æ—¥è®°ï¼Œå¿½ç•¥æœç´¢æ–‡æœ¬
    private var filteredDiaries: [DiaryEntry] {
        let calendar = Calendar.current
        return diaries.filter { diary in
            calendar.isDate(diary.date, inSameDayAs: selectedDate)
        }
    }
    
    // æœå°‹çµæœçµæ§‹
    struct SearchResult: Identifiable {
        let id = UUID()
        let diary: DiaryEntry
        let fieldName: String
        let matchText: String
        let matchLocation: String // æè¿°åŒ¹é…ä½ç½®ï¼Œå¦‚ "å¿ƒå¾—" æˆ– "æ”¯å‡ºè¨˜éŒ„-åç¨±"
    }
    
    // åŸ·è¡Œæœå°‹
    private func performSearch() {
        guard !searchText.isEmpty else {
            searchResults = []
            currentResultIndex = -1
            return
        }
        
        var results: [SearchResult] = []
        
        for diary in diaries {
            // æœå°‹æ—¥æœŸ
            let dateString = diary.date.formatted(date: .abbreviated, time: .omitted)
            if dateString.localizedCaseInsensitiveContains(searchText) {
                results.append(SearchResult(diary: diary, fieldName: "æ—¥æœŸ", matchText: dateString, matchLocation: "åŸºæœ¬ä¿¡æ¯"))
            }
            
            // æœå°‹å¤©æ°£
            let weatherString = diary.weather.rawValue
            if weatherString.localizedCaseInsensitiveContains(searchText) {
                results.append(SearchResult(diary: diary, fieldName: "å¤©æ°£", matchText: weatherString, matchLocation: "åŸºæœ¬ä¿¡æ¯"))
            }
            
            // æœå°‹æº«åº¦ä¿¡æ¯
            if diary.temperature.localizedCaseInsensitiveContains(searchText) {
                results.append(SearchResult(diary: diary, fieldName: "æº«åº¦", matchText: diary.temperature, matchLocation: "åŸºæœ¬ä¿¡æ¯"))
            }
            
            // æœå°‹å¿ƒå¾—
            if diary.thoughts.localizedCaseInsensitiveContains(searchText) {
                results.append(SearchResult(diary: diary, fieldName: "å¿ƒå¾—", matchText: diary.thoughts, matchLocation: "åŸºæœ¬ä¿¡æ¯"))
            }
            
            // æœå°‹æ”¯å‡ºè¨˜éŒ„
            for entry in diary.expenses {
                if searchEntryFields(entry, in: diary, categoryType: .expense, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
            
            // æœå°‹é‹å‹•è¨˜éŒ„
            for entry in diary.exercises {
                if searchEntryFields(entry, in: diary, categoryType: .exercise, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
            
            // æœå°‹ç¡çœ è¨˜éŒ„
            for entry in diary.sleeps {
                if searchEntryFields(entry, in: diary, categoryType: .sleep, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
            
            // æœå°‹å·¥ä½œè¨˜éŒ„
            for entry in diary.works {
                if searchEntryFields(entry, in: diary, categoryType: .work, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
            
            // æœå°‹é—œä¿‚è¨˜éŒ„
            for entry in diary.relationships {
                if searchEntryFields(entry, in: diary, categoryType: .relationship, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
            
            // æœå°‹å­¸ç¿’è¨˜éŒ„
            for entry in diary.studies {
                if searchEntryFields(entry, in: diary, categoryType: .study, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
        }
        
        searchResults = results
        currentResultIndex = results.isEmpty ? -1 : 0
        
        // å¦‚æœæœ‰æœå°‹çµæœï¼Œå°èˆªåˆ°ç¬¬ä¸€å€‹çµæœ
        navigateToCurrentResult()
    }
    
    // æœå°‹å–®å€‹æ¢ç›®çš„å„å€‹å­—æ®µ
    private func searchEntryFields(_ entry: CategoryEntry, in diary: DiaryEntry, categoryType: CategoryType, results: inout [SearchResult]) -> Bool {
        var foundMatch = false
        let categoryName = categoryType.rawValue
        
        // æœå°‹åç¨±å­—æ®µ
        if entry.name.localizedCaseInsensitiveContains(searchText) {
            results.append(SearchResult(
                diary: diary,
                fieldName: "åç¨±",
                matchText: entry.name,
                matchLocation: "\(categoryName)-\(entry.name)"
            ))
            foundMatch = true
        }
        
        // æœå°‹é¡åˆ¥å­—æ®µ
        if entry.category.localizedCaseInsensitiveContains(searchText) {
            results.append(SearchResult(
                diary: diary,
                fieldName: "é¡åˆ¥",
                matchText: entry.category,
                matchLocation: "\(categoryName)-\(entry.name)"
            ))
            foundMatch = true
        }
        
        // æœå°‹å‚™æ³¨å­—æ®µ
        if entry.notes.localizedCaseInsensitiveContains(searchText) {
            results.append(SearchResult(
                diary: diary,
                fieldName: "å‚™æ³¨",
                matchText: entry.notes,
                matchLocation: "\(categoryName)-\(entry.name)"
            ))
            foundMatch = true
        }
        
        // æœå°‹æ•¸å­—ï¼ˆè½‰ç‚ºå­—ç¬¦ä¸²å¾Œæœå°‹ï¼‰
        let numberString = String(format: "%.0f", entry.number)
        if numberString.localizedCaseInsensitiveContains(searchText) {
            results.append(SearchResult(
                diary: diary,
                fieldName: "æ•¸é‡",
                matchText: numberString,
                matchLocation: "\(categoryName)-\(entry.name)"
            ))
            foundMatch = true
        }
        
        return foundMatch
    }
    
    // å‘ä¸Šæœå°‹
    private func searchUp() {
        guard !searchResults.isEmpty else { return }
        
        if currentResultIndex > 0 {
            currentResultIndex -= 1
        } else {
            // å¾ªç’°å›åˆ°æœ€å¾Œä¸€å€‹çµæœ
            currentResultIndex = searchResults.count - 1
        }
        
        navigateToCurrentResult()
    }
    
    // å‘ä¸‹æœå°‹
    private func searchDown() {
        guard !searchResults.isEmpty else { return }
        
        if currentResultIndex < searchResults.count - 1 {
            currentResultIndex += 1
        } else {
            // å¾ªç’°å›åˆ°ç¬¬ä¸€å€‹çµæœ
            currentResultIndex = 0
        }
        
        navigateToCurrentResult()
    }
    
    // å°èˆªåˆ°ç•¶å‰æœå°‹çµæœ
    private func navigateToCurrentResult() {
        guard !searchResults.isEmpty && currentResultIndex >= 0 && currentResultIndex < searchResults.count else { return }
        
        let result = searchResults[currentResultIndex]
        selectedDiary = result.diary
        selectedDate = result.diary.date
        
        // æ ¹æ“šçµæœé¡å‹è¨­ç½®é©ç•¶çš„é¸é …å¡
        switch result.matchLocation.split(separator: "-").first?.trimmingCharacters(in: .whitespaces) {
        case "æ”¯å‡ºè¨˜éŒ„", "æ”¯å‡º":
            selectedTab = "æ”¯å‡º"
        case "é‹å‹•è¨˜éŒ„", "é‹å‹•":
            selectedTab = "é‹å‹•"
        case "ç¡çœ è¨˜éŒ„", "ç¡çœ ":
            selectedTab = "ç¡çœ "
        case "å·¥ä½œè¨˜éŒ„", "å·¥ä½œ":
            selectedTab = "å·¥ä½œ"
        case "é—œä¿‚è¨˜éŒ„", "é—œä¿‚":
            selectedTab = "é—œä¿‚"
        case "å­¸ç¿’è¨˜éŒ„", "å­¸ç¿’":
            selectedTab = "å­¸ç¿’"
        default:
            selectedTab = "basic"
        }
    }
    
    // åˆ‡æ›æœå°‹æ¬„ä½å¯è¦‹æ€§
    private func toggleSearchField() {
        showSearchField.toggle()
        if !showSearchField {
            searchText = ""
            searchResults = []
            currentResultIndex = -1
        }
    }
    
    // é¸ä¸­çš„æ¨™ç±¤é 
    @State private var selectedTab: String? = "basic"

    var body: some View {
        NavigationSplitView {
            VStack {
                // æ—¥æœŸé¸æ“‡å™¨éƒ¨åˆ†
                HStack {
                    Text("é¸æ“‡æ—¥æœŸ")
                        .font(.system(size: titleFontSize))
                        .foregroundColor(Color.fromString(titleFontColor))
                    Spacer()
                    CustomDatePickerView(
                        selectedDate: $selectedDate,
                        titleFontColor: titleFontColor,
                        contentFontColor: contentFontColor
                    )
                    .help("é¸æ“‡è¦æŸ¥çœ‹çš„æ—¥æœŸ")
                }
                .padding(.horizontal)
                .padding(.top, 10)
                
                // æœå°‹æ¬„ä½ï¼ˆç•¶ showSearchField ç‚º true æ™‚é¡¯ç¤ºï¼‰
                if showSearchField {
                    VStack(spacing: 8) {
                        HStack {
                            Image(systemName: "magnifyingglass")
                                .foregroundColor(.secondary)
                            
                            TextField("æœå°‹æ—¥è¨˜å…§å®¹...", text: $searchText)
                                .textFieldStyle(.plain)
                                .onSubmit {
                                    performSearch()
                                }
                            
                            Button(action: {
                                searchText = ""
                                searchResults = []
                                currentResultIndex = -1
                            }) {
                                Image(systemName: "xmark.circle.fill")
                                    .foregroundColor(.gray)
                            }
                            .buttonStyle(.borderless)
                            .opacity(searchText.isEmpty ? 0 : 1)
                        }
                        .padding(8)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color(NSColor.textBackgroundColor))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                )
                        )
                        
                        HStack {
                            // é¡¯ç¤ºæœå°‹çµæœè¨ˆæ•¸
                            if !searchResults.isEmpty {
                                Text("æ‰¾åˆ° \(searchResults.count) å€‹çµæœ (ç•¶å‰: \(currentResultIndex + 1)/\(searchResults.count))")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            HStack(spacing: 8) {
                                Button(action: searchUp) {
                                    Image(systemName: "chevron.up")
                                        .frame(width: 24, height: 24)
                                }
                                .buttonStyle(.borderless)
                                .disabled(searchResults.isEmpty)
                                
                                Button(action: searchDown) {
                                    Image(systemName: "chevron.down")
                                        .frame(width: 24, height: 24)
                                }
                                .buttonStyle(.borderless)
                                .disabled(searchResults.isEmpty)
                                
                                Button(action: performSearch) {
                                    Text("æœå°‹")
                                        .font(.caption)
                                }
                                .disabled(searchText.isEmpty)
                                .buttonStyle(.borderedProminent)
                                .controlSize(.small)
                            }
                        }
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 4)
                }
                
                List(filteredDiaries) { diary in
                    DiaryRowView(diary: diary)
                        .onTapGesture {
                            selectedDiary = diary
                        }
                        .customCursor(.pointingHand)
                        .help("æŸ¥çœ‹æ—¥è¨˜è©³ç´°å…§å®¹")
                }
            }
            .navigationTitle("æ—¥è¨˜åˆ—è¡¨")
            .modifier(ListToolbarModifier(
                toggleSearchField: toggleSearchField,
                showSearchField: showSearchField,
                switchToToday: switchToToday,
                isExporting: $isExporting,
                showingDateRangeSheet: $showingDateRangeSheet,
                showingPreferencesSheet: $showingPreferencesSheet,
                showingHelpSheet: $showingHelpSheet,
                showingNewDiarySheet: $showingNewDiarySheet
            ))
            .searchable(text: $searchText, isPresented: $showSearchField, prompt: "æœå°‹æ—¥è¨˜...")
        } detail: {
            if let diary = selectedDiary {
                DiaryDetailView(diary: diary, selectedTab: $selectedTab)
            } else {
                Text("è«‹é¸æ“‡ä¸€ç¯‡æ—¥è¨˜")
                    .font(.title)
                    .foregroundColor(.secondary)
            }
        }
        .sheet(isPresented: $showingDateRangeSheet) {
            NavigationView {
                VStack(spacing: 20) {
                    Text(isExporting ? "åŒ¯å‡ºå‚™ä»½" : "åŒ¯å…¥å‚™ä»½")
                        .font(.headline)
                        .padding(.top, 20)
                    
                    Form {
                        Section(header: Text("é¸æ“‡æ—¥æœŸç¯„åœ")) {
                            HStack {
                                Text("é–‹å§‹æ—¥æœŸ")
                                    .frame(minWidth: 80, alignment: .leading)
                                Spacer()
                                CustomDatePickerView(
                                    selectedDate: $startDate,
                                    titleFontColor: titleFontColor,
                                    contentFontColor: contentFontColor
                                )
                            }
                            .padding(.vertical, 5)
                            
                            HStack {
                                Text("çµæŸæ—¥æœŸ")
                                    .frame(minWidth: 80, alignment: .leading)
                                Spacer()
                                CustomDatePickerView(
                                    selectedDate: $endDate,
                                    titleFontColor: titleFontColor,
                                    contentFontColor: contentFontColor
                                )
                            }
                            .padding(.vertical, 5)
                        }
                    }
                    
                    HStack(spacing: 30) {
                        Button("å–æ¶ˆ") {
                            showingDateRangeSheet = false
                        }
                        
                        Button("ç¢ºå®š") {
                            showingDateRangeSheet = false
                            if isExporting {
                                exportData()
                            } else {
                                importData()
                            }
                        }
                        .buttonStyle(.borderedProminent)
                    }
                    .padding(.bottom, 20)
                    
                    Spacer()
                }
                .frame(maxWidth: .infinity)
            }
            .frame(width: 400, height: 320)
        }
        .alert(isPresented: $showingAlert) {
            Alert(
                title: Text(alertTitle),
                message: Text(alertMessage),
                dismissButton: .default(Text("ç¢ºå®š"))
            )
        }
        .onChange(of: selectedDate) { oldValue, newValue in
            // ç•¶é¸æ“‡æ–°æ—¥æœŸæ™‚ï¼Œå¦‚æœéæ¿¾å¾Œçš„æ—¥è¨˜ä¸ç‚ºç©ºï¼Œé¸æ“‡ç¬¬ä¸€ç¯‡
            if let firstDiary = filteredDiaries.first {
                selectedDiary = firstDiary
            }
        }
        .onAppear {
            // åˆå§‹åŒ–æ™‚ï¼Œè‡ªå‹•åˆ‡æ›åˆ°ä»Šæ—¥æ—¥è¨˜
            switchToToday()
        }
        .sheet(isPresented: $showingNewDiarySheet) {
            NewDiaryView()
        }
        .sheet(isPresented: $showingPreferencesSheet) {
            PreferencesView()
                .frame(width: 600, height: 700)
        }
        .sheet(isPresented: $showingHelpSheet) {
            HelpView()
                .frame(width: 800, height: 600)
        }
    }
    
    /// å°‡æŒ‡å®šæ—¥æœŸç¯„åœå…§çš„æ—¥è¨˜æ¢ç›®è½‰æ›ç‚ºå‚™ä»½æ ¼å¼
    private func createBackup(from: Date, to: Date) -> DiaryBackup {
        let calendar = Calendar.current
        let filteredDiaries = diaries.filter { diary in
            let diaryDate = calendar.startOfDay(for: diary.date)
            let fromDate = calendar.startOfDay(for: from)
            let toDate = calendar.startOfDay(for: to.addingTimeInterval(24*60*60))  // åŠ ä¸€å¤©ï¼Œä½¿å¾—çµæŸæ—¥æœŸåŒ…å«åœ¨å…§
            return diaryDate >= fromDate && diaryDate < toDate
        }
        
        let entries = filteredDiaries.map { diary in
            DiaryBackup.DiaryBackupEntry(
                id: diary.id,
                date: diary.date,
                weatherRaw: diary.weather.rawValue,
                thoughts: diary.thoughts,
                temperature: diary.temperature,
                expenses: diary.expenses.map { convertToBackupEntry($0) },
                exercises: diary.exercises.map { convertToBackupEntry($0) },
                sleeps: diary.sleeps.map { convertToBackupEntry($0) },
                works: diary.works.map { convertToBackupEntry($0) },
                relationships: diary.relationships.map { convertToBackupEntry($0) },
                studies: diary.studies.map { convertToBackupEntry($0) }
            )
        }
        return DiaryBackup(entries: entries)
    }
    
    /// å°‡åˆ†é¡æ¢ç›®è½‰æ›ç‚ºå‚™ä»½æ ¼å¼
    private func convertToBackupEntry(_ entry: CategoryEntry) -> DiaryBackup.CategoryBackupEntry {
        DiaryBackup.CategoryBackupEntry(
            id: entry.id,
            typeRaw: entry.typeRaw,
            name: entry.name,
            category: entry.category,
            number: entry.number,
            notes: entry.notes
        )
    }
    
    /// å¾å‚™ä»½æ•¸æ“šå‰µå»ºåˆ†é¡æ¢ç›®
    private func createCategoryEntry(_ backup: DiaryBackup.CategoryBackupEntry, type: CategoryType) -> CategoryEntry {
        let entry = CategoryEntry(type: type,
                                name: backup.name,
                                category: backup.category,
                                number: backup.number,
                                notes: backup.notes)
        entry.id = backup.id
        return entry
    }
    
    /// åŒ¯å‡ºæ•¸æ“š
    private func exportData() {
        let diariesInRange = diaries.filter { diary in
            diary.date >= startDate && diary.date <= endDate
        }
        
        if diariesInRange.isEmpty {
            alertTitle = "åŒ¯å‡ºå¤±æ•—"
            alertMessage = "æ‰€é¸æ—¥æœŸç¯„åœå…§æ²’æœ‰æ—¥è¨˜è³‡æ–™ã€‚"
            showingAlert = true
            return
        }
        
        let entries = diariesInRange.map { diary -> DiaryBackup.DiaryBackupEntry in
            // è·å–æ­¤æ—¥è®°çš„æ‰€æœ‰åˆ†ç±»æ¡ç›®çš„é›†åˆ
            var diaryCategories: [CategoryEntry] = []
            diaryCategories.append(contentsOf: diary.expenses)
            diaryCategories.append(contentsOf: diary.exercises)
            diaryCategories.append(contentsOf: diary.sleeps)
            diaryCategories.append(contentsOf: diary.works)
            diaryCategories.append(contentsOf: diary.relationships)
            diaryCategories.append(contentsOf: diary.studies)
            
            // æŒ‰ç±»å‹åˆ†ç±»
            let expenseEntries = diary.expenses.map { createBackupCategoryEntry($0) }
            let exerciseEntries = diary.exercises.map { createBackupCategoryEntry($0) }
            let sleepEntries = diary.sleeps.map { createBackupCategoryEntry($0) }
            let workEntries = diary.works.map { createBackupCategoryEntry($0) }
            let relationshipEntries = diary.relationships.map { createBackupCategoryEntry($0) }
            let studyEntries = diary.studies.map { createBackupCategoryEntry($0) }
            
            return DiaryBackup.DiaryBackupEntry(
                id: diary.id,
                date: diary.date,
                weatherRaw: diary.weather.rawValue,
                thoughts: diary.thoughts,
                temperature: "",  // ç›®å‰æ²¡æœ‰æ¸©åº¦å­—æ®µï¼Œä½¿ç”¨ç©ºå­—ç¬¦ä¸²
                expenses: expenseEntries,
                exercises: exerciseEntries,
                sleeps: sleepEntries,
                works: workEntries,
                relationships: relationshipEntries,
                studies: studyEntries
            )
        }
        
        let backup = DiaryBackup(entries: entries)
        
        do {
            let encoder = JSONEncoder()
            encoder.dateEncodingStrategy = .iso8601
            encoder.outputFormatting = .prettyPrinted
            let data = try encoder.encode(backup)
            
            // å‰µå»ºæª”æ¡ˆåç¨±ï¼Œä½¿ç”¨æ—¥æœŸç¯„åœ
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "yyyyMMdd"
            let fileName = "diary_backup_\(dateFormatter.string(from: startDate))_to_\(dateFormatter.string(from: endDate)).json"
            
            // é¡¯ç¤ºå„²å­˜å°è©±æ¡†
            let savePanel = NSSavePanel()
            savePanel.allowedContentTypes = [UTType.json]
            savePanel.nameFieldStringValue = fileName
            savePanel.message = "é¸æ“‡æª”æ¡ˆå„²å­˜ä½ç½®"
            savePanel.title = "å„²å­˜æ—¥è¨˜å‚™ä»½"
            
            let response = savePanel.runModal()
            
            if response == .OK, let url = savePanel.url {
                try data.write(to: url)
                alertTitle = "åŒ¯å‡ºæˆåŠŸ"
                alertMessage = "æˆåŠŸåŒ¯å‡º \(entries.count) ç¯‡æ—¥è¨˜è‡³ \(url.lastPathComponent)"
            } else {
                alertTitle = "åŒ¯å‡ºå–æ¶ˆ"
                alertMessage = "ä½¿ç”¨è€…å–æ¶ˆäº†åŒ¯å‡ºæ“ä½œã€‚"
            }
        } catch {
            alertTitle = "åŒ¯å‡ºå¤±æ•—"
            alertMessage = "éŒ¯èª¤ï¼š\(error.localizedDescription)"
        }
        
        showingAlert = true
    }
    
    // è¾…åŠ©å‡½æ•°ï¼Œåˆ›å»ºå¤‡ä»½åˆ†ç±»æ¡ç›®
    private func createBackupCategoryEntry(_ entry: CategoryEntry) -> DiaryBackup.CategoryBackupEntry {
        return DiaryBackup.CategoryBackupEntry(
            id: entry.id,
            typeRaw: entry.type.rawValue,
            name: entry.name,
            category: entry.category,
            number: entry.number,
            notes: entry.notes
        )
    }
    
    /// åŒ¯å…¥æ•¸æ“š
    private func importData() {
        do {
            let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "yyyyMMdd"
            let startDateString = dateFormatter.string(from: startDate)
            let endDateString = dateFormatter.string(from: endDate)
            let backupURL = documentsDirectory.appendingPathComponent("diary_backup_\(startDateString)_\(endDateString).json")
            let data = try Data(contentsOf: backupURL)
            let backup = try JSONDecoder().decode(DiaryBackup.self, from: data)
            
            // åˆªé™¤æŒ‡å®šæ—¥æœŸç¯„åœå…§çš„ç¾æœ‰æ•¸æ“š
            let calendar = Calendar.current
            let diariesToDelete = diaries.filter { diary in
                let diaryDate = calendar.startOfDay(for: diary.date)
                let fromDate = calendar.startOfDay(for: startDate)
                let toDate = calendar.startOfDay(for: endDate.addingTimeInterval(24*60*60))  // åŠ ä¸€å¤©ï¼Œä½¿å¾—çµæŸæ—¥æœŸåŒ…å«åœ¨å…§
                return diaryDate >= fromDate && diaryDate < toDate
            }
            for diary in diariesToDelete {
                modelContext.delete(diary)
            }
            
            // æ¢å¾©å‚™ä»½æ•¸æ“š
            for backupEntry in backup.entries {
                let diary = DiaryEntry(date: backupEntry.date,
                                     weather: WeatherType(rawValue: backupEntry.weatherRaw) ?? .sunny,
                                     thoughts: backupEntry.thoughts,
                                     temperature: backupEntry.temperature)
                diary.id = backupEntry.id
                
                diary.expenses = backupEntry.expenses.map { createCategoryEntry($0, type: .expense) }
                diary.exercises = backupEntry.exercises.map { createCategoryEntry($0, type: .exercise) }
                diary.sleeps = backupEntry.sleeps.map { createCategoryEntry($0, type: .sleep) }
                diary.works = backupEntry.works.map { createCategoryEntry($0, type: .work) }
                diary.relationships = backupEntry.relationships.map { createCategoryEntry($0, type: .relationship) }
                diary.studies = backupEntry.studies.map { createCategoryEntry($0, type: .study) }
                
                modelContext.insert(diary)
            }
            
            try modelContext.save()
            alertTitle = "åŒ¯å…¥æˆåŠŸ"
            alertMessage = "æ•¸æ“šå·²æˆåŠŸæ¢å¾©"
        } catch {
            alertTitle = "åŒ¯å…¥å¤±æ•—"
            alertMessage = error.localizedDescription
        }
        showingAlert = true
    }
    
    /// å¾å‚™ä»½æ•¸æ“šæ¢å¾©
    private func restoreFromBackup(_ backup: DiaryBackup) {
        // æ¸…é™¤ç¾æœ‰æ•¸æ“š
        for diary in diaries {
            modelContext.delete(diary)
        }
        
        // æ¢å¾©å‚™ä»½æ•¸æ“š
        for backupEntry in backup.entries {
            let diary = DiaryEntry(date: backupEntry.date,
                                 weather: WeatherType(rawValue: backupEntry.weatherRaw) ?? .sunny,
                                 thoughts: backupEntry.thoughts,
                                 temperature: backupEntry.temperature)
            diary.id = backupEntry.id
            
            // æ¢å¾©åˆ†é¡æ¢ç›®
            diary.expenses = backupEntry.expenses.map { createCategoryEntry($0, type: .expense) }
            diary.exercises = backupEntry.exercises.map { createCategoryEntry($0, type: .exercise) }
            diary.sleeps = backupEntry.sleeps.map { createCategoryEntry($0, type: .sleep) }
            diary.works = backupEntry.works.map { createCategoryEntry($0, type: .work) }
            diary.relationships = backupEntry.relationships.map { createCategoryEntry($0, type: .relationship) }
            diary.studies = backupEntry.studies.map { createCategoryEntry($0, type: .study) }
            
            modelContext.insert(diary)
        }
        
        // ä¿å­˜æ›´æ”¹
        try? modelContext.save()
    }
    
    /// åˆ‡æ›åˆ°ä»Šæ—¥æ—¥è¨˜ï¼Œå¦‚æœä¸å­˜åœ¨å‰‡å‰µå»º
    private func switchToToday() {
        let today = Date()
        let calendar = Calendar.current
        
        // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ä»Šæ—¥æ—¥è¨˜
        if let existingDiary = diaries.first(where: { calendar.isDateInToday($0.date) }) {
            // å·²æœ‰ä»Šæ—¥æ—¥è¨˜ï¼Œé¸ä¸­å®ƒ
            selectedDiary = existingDiary
            selectedDate = existingDiary.date
        } else {
            // æ²’æœ‰ä»Šæ—¥æ—¥è¨˜ï¼Œå‰µå»ºæ–°çš„
            let newDiary = DiaryEntry(date: today, weather: .sunny, thoughts: "")
            modelContext.insert(newDiary)
            try? modelContext.save()
            selectedDiary = newDiary
            selectedDate = today
        }
    }
}

// MARK: - æ–°æ—¥è¨˜è¦–åœ–
/// å‰µå»ºæ–°æ—¥è¨˜çš„è¦–åœ–
struct NewDiaryView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var modelContext
    @State private var date = Date()
    @State private var weather = WeatherType.sunny
    @State private var thoughts = ""
    
    // æ·»åŠ å­—ä½“é¢œè‰²è®¾ç½®
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    var body: some View {
        NavigationView {
            Form {
                // ä½¿ç”¨è‡ªå®šä¹‰æ—¥æœŸé€‰æ‹©å™¨
                HStack {
                    Text("æ—¥æœŸ")
                        .font(.system(size: 20))
                    Spacer()
                    CustomDatePickerView(
                        selectedDate: $date,
                        titleFontColor: titleFontColor,
                        contentFontColor: contentFontColor
                    )
                    .help("é¸æ“‡è¦æŸ¥çœ‹çš„æ—¥æœŸ")
                }
                .padding(.vertical, 5)
                
                Section("å¤©æ°£") {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 15) {
                            ForEach(WeatherType.allCases, id: \.self) { type in
                                VStack {
                                    Image(systemName: type.icon)
                                        .font(.system(size: 22))
                                        .foregroundColor(weather == type ? .blue : .gray)
                                        .padding(8)
                                        .background(
                                            Circle()
                                                .fill(weather == type ? Color.blue.opacity(0.2) : Color.clear)
                                        )
                                    Text(type.rawValue)
                                        .font(.system(size: 20))
                                }
                                .onTapGesture {
                                    weather = type
                                }
                            }
                        }
                    }
                    .frame(height: 80)
                }
                
                Section("å¿ƒå¾—") {
                    EnhancedTextEditor(text: $thoughts)
                        .frame(height: 200)
                }
            }
            .navigationTitle("æ–°å¢æ—¥è¨˜")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("å–æ¶ˆ") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("ä¿å­˜") {
                        let newDiary = DiaryEntry(date: date, weather: weather, thoughts: thoughts)
                        modelContext.insert(newDiary)
                        try? modelContext.save()
                        dismiss()
                    }
                }
            }
        }
    }
}

// MARK: - æ—¥è¨˜è©³ç´°è¦–åœ–
/// é¡¯ç¤ºæ—¥è¨˜è©³ç´°å…§å®¹çš„è¦–åœ–
struct DiaryDetailView: View {
    var diary: DiaryEntry
    @State private var selectedTab: Int = 0
    @Binding var externalSelectedTab: String?
    @State private var thoughts: String
    @State private var isLoading: Bool = false
    @State private var isOnline: Bool = false
    @State private var isUpdating: Bool = false
    @State private var selectedWeather: String
    @AppStorage("weatherApiKey") private var apiKey: String = "76fb9beb7dd213c17447b2b9080e0bcb"
    
    // âš ï¸ é€™è£¡çš„ @AppStorage å®£å‘Šèˆ‡å…¶ä»–è¦–åœ–é‡è¤‡ï¼Œè€ƒæ…®å‰µå»ºä¸€å€‹å–®ä¸€å…±äº«è¨­å®šç‰©ä»¶
    @AppStorage("titleFontSize") private var titleFontSize: Double = 22
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    @State private var showingApiKeyAlert = false
    @State private var showingLocationAlert = false
    @State private var locationErrorMessage = ""
    @Environment(\.modelContext) private var modelContext
    
    // æ·»åŠ å‹•ç•«ç‹€æ…‹
    @State private var titleScale: Double = 1.0
    
    init(diary: DiaryEntry) {
        self.diary = diary
        _selectedWeather = State(initialValue: diary.weather.rawValue)
        _thoughts = State(initialValue: diary.thoughts)
        _isOnline = State(initialValue: Calendar.current.isDateInToday(diary.date) && !diary.temperature.isEmpty)
        _externalSelectedTab = .constant(nil)
    }
    
    init(diary: DiaryEntry, selectedTab: Binding<String?>) {
        self.diary = diary
        _selectedWeather = State(initialValue: diary.weather.rawValue)
        _thoughts = State(initialValue: diary.thoughts)
        _isOnline = State(initialValue: Calendar.current.isDateInToday(diary.date) && !diary.temperature.isEmpty)
        _externalSelectedTab = selectedTab
    }
    
    private var weatherService: WeatherService? {
        if !apiKey.isEmpty {
            return WeatherService(apiKey: apiKey)
        }
        return nil
    }
    
    private var isToday: Bool {
        Calendar.current.isDateInToday(diary.date)
    }
    
    private func saveContext() {
        do {
            try modelContext.save()
            print("å¤©æ°£å’Œå¿ƒå¾—ä¿å­˜æˆåŠŸ")
        } catch {
            print("ä¿å­˜å¤±æ•—: \(error)")
        }
    }
    
    private func updateWeather() {
        // æ·»åŠ èª¿è©¦è¼¸å‡º
        print("æº–å‚™æ›´æ–°å¤©æ°£ä¿¡æ¯...")
        
        guard isToday else {
            isOnline = false
            diary.temperature = ""
            saveContext()
            return
        }
        
        if let service = weatherService {
            isLoading = true
            Task {
                do {
                    let (weatherType, temp) = try await service.fetchWeather()
                    await MainActor.run {
                        selectedWeather = weatherType.rawValue
                        diary.temperature = temp
                        diary.weather = weatherType
                        isOnline = true
                        
                        // æ·»åŠ èª¿è©¦è¼¸å‡º
                        print("å¤©æ°£æ›´æ–°æˆåŠŸ: \(temp), é¡å‹: \(weatherType.rawValue)")
                        
                        saveContext()
                        isLoading = false
                    }
                } catch {
                    await MainActor.run {
                        diary.temperature = ""
                        isOnline = false
                        isLoading = false
                        
                        // æ·»åŠ èª¿è©¦è¼¸å‡º
                        print("å¤©æ°£æ›´æ–°å¤±æ•—: \(error)")
                        
                        let nsError = error as NSError
                        switch nsError.domain {
                        case "WeatherService":
                            switch nsError.code {
                            case 1:
                                locationErrorMessage = "è«‹åœ¨ç³»çµ±åå¥½è¨­å®šä¸­å•Ÿç”¨ä½ç½®æœå‹™ï¼Œä¸¦å…è¨±æ‡‰ç”¨ç¨‹åºä½¿ç”¨ä½ç½®ä¿¡æ¯ã€‚"
                            case 2:
                                locationErrorMessage = "è«‹æˆäºˆæ‡‰ç”¨ç¨‹åºä½ç½®æ¬Šé™ä»¥ç²å–å¤©æ°£è³‡è¨Šã€‚"
                            default:
                                locationErrorMessage = nsError.localizedDescription
                            }
                        default:
                            locationErrorMessage = "ç²å–å¤©æ°£è³‡è¨Šå¤±æ•—ï¼Œè«‹ç¨å¾Œé‡è©¦ã€‚"
                        }
                        showingLocationAlert = true
                    }
                }
            }
        } else {
            showingApiKeyAlert = true
        }
    }
    
    private func switchToManual() {
        isOnline = false
        diary.temperature = ""
        saveContext()
    }
    
    var body: some View {
        TabView(selection: $selectedTab) {
            WeatherAndThoughtsView(
                diary: diary, 
                thoughts: $thoughts, 
                diaryTemperature: diary.temperature, 
                isToday: isToday, 
                updateWeather: updateWeather
            )
            .tabItem {
                Label("åŸºæœ¬", systemImage: "house.fill")
            }
            .tag(0)
            
            // ... existing code ...
        }
        .onChange(of: thoughts) { oldValue, newValue in
            diary.thoughts = newValue
            try? modelContext.save()
        }
        // ... existing code ...
    }
}

struct WeatherAndThoughtsView: View {
    let diary: DiaryEntry
    @Binding var thoughts: String
    let diaryTemperature: String
    let isToday: Bool
    let updateWeather: () -> Void
    
    var body: some View {
        VStack(spacing: 20) {
            HStack {
                Text("å¤©æ°£")
                    .font(.headline)
                
                Spacer()
                
                if isToday {
                    Button("æ›´æ–°å¤©æ°£") {
                        updateWeather()
                    }
                    .buttonStyle(.borderedProminent)
                    .controlSize(.small)
                }
                
                HStack(spacing: 10) {
                    Image(systemName: diary.weather.icon)
                        .foregroundColor(.blue)
                        .font(.system(size: 24))
                    Text(diary.weather.rawValue)
                    
                    if !diary.temperature.isEmpty {
                        // ä½¿ç”¨diaryTemperatureä¾†ç¢ºä¿æ¯æ¬¡é¡¯ç¤ºæœ€æ–°å€¼
                        Text("(\(diaryTemperature))")
                            .foregroundColor(.secondary)
                            .id("temp-\(UUID().uuidString)")  // å¼·åˆ¶åˆ·æ–°
                    }
                }
            }
            .padding(.horizontal)
            
            Divider()
            
            VStack(alignment: .leading) {
                Text("å¿ƒå¾—")
                    .font(.headline)
                
                EnhancedTextEditor(text: $thoughts)
                    .frame(minHeight: 200)
                    .padding(.top, 4)
            }
            .padding(.horizontal)
            
            Spacer()
        }
        .padding()
    }
}

// MARK: - æ—¥è¨˜è¡Œè¦–åœ–
/// åœ¨åˆ—è¡¨ä¸­é¡¯ç¤ºå–®å€‹æ—¥è¨˜æ¢ç›®çš„è¦–åœ–
struct DiaryRowView: View {
    let diary: DiaryEntry
    
    // âš ï¸ é€™è£¡çš„ @AppStorage å®£å‘Šåœ¨å¤šå€‹è¦–åœ–ä¸­é‡è¤‡å‡ºç¾ï¼Œè€ƒæ…®å‰µå»ºä¸€å€‹å…±äº«è¨­å®šç’°å¢ƒç‰©ä»¶
    @AppStorage("titleFontSize") private var titleFontSize: Double = 22
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // æ—¥æœŸå’Œå¤©æ°£
            HStack {
                // æ—¥æœŸæ¨™é¡Œä½¿ç”¨èˆ‡å…¶ä»–æ¨™é¡Œç›¸åŒçš„æ¨£å¼
                Text(formatDate(diary.date))
                    .font(.system(size: titleFontSize))
                    .foregroundColor(Color.fromString(titleFontColor))
                Spacer()
                Image(systemName: diary.weather.icon)
                    .foregroundColor(.blue)
                    .font(.system(size: contentFontSize))
            }
            
            // å¿ƒå¾—é è¦½
            if !diary.thoughts.isEmpty {
                Text(diary.thoughts)
                    .lineLimit(2)
                    .font(.system(size: contentFontSize))
                    .foregroundColor(Color.fromString(contentFontColor))
            }
            
            // é¡åˆ¥æ¨™ç±¤
            let categories = getCategoryEntries(for: diary)
            if !categories.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack {
                        ForEach(categories) { category in
                            Label(category.type.rawValue, systemImage: category.type.icon)
                                .font(.caption)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color.blue.opacity(0.1))
                                .cornerRadius(8)
                        }
                    }
                }
            }
        }
        .padding(.vertical, 4)
    }
    
    /// æ ¼å¼åŒ–æ—¥æœŸç‚ºèˆ‡æ—¥æœŸé¸æ“‡å™¨ç›¸åŒçš„æ ¼å¼ (yyyy/M/d)
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy/M/d"
        return formatter.string(from: date)
    }
    
    /// ç²å–æ‰€æœ‰é¡åˆ¥æ¢ç›®
    private func getCategoryEntries(for diary: DiaryEntry) -> [CategoryEntry] {
        var entries: [CategoryEntry] = []
        entries.append(contentsOf: diary.expenses)
        entries.append(contentsOf: diary.exercises)
        entries.append(contentsOf: diary.sleeps)
        entries.append(contentsOf: diary.works)
        entries.append(contentsOf: diary.relationships)
        entries.append(contentsOf: diary.studies)
        return entries
    }
}

// MARK: - Weather Section View
private struct WeatherSectionView: View {
    let diary: DiaryEntry
    @Binding var selectedWeather: String
    @Binding var isOnline: Bool
    @Binding var isLoading: Bool
    let weatherService: WeatherService?
    let isToday: Bool
    let titleFontSize: Double
    let contentFontSize: Double
    let titleFontColor: String
    let updateWeather: () -> Void
    let switchToManual: () -> Void
    let saveContext: () -> Void
    
    // æ–°å¢å‹•ç•«ç‹€æ…‹
    @State private var titleScale: CGFloat = 1.0
    @State private var isUpdating: Bool = false
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text("å¤©æ°£")
                    .font(.system(size: titleFontSize))
                    .foregroundColor(Color.fromString(titleFontColor))
                    .scaleEffect(titleScale)
                    .onAppear {
                        withAnimation(AnimationConstants.springSmall) {
                            titleScale = 1.05
                        }
                        withAnimation(AnimationConstants.springSmall.delay(0.1)) {
                            titleScale = 1.0
                        }
                    }
                
                Spacer()
                
                if isOnline {
                    Text(diary.temperature)
                        .font(.system(size: contentFontSize))
                        .foregroundColor(.secondary)
                        .transition(.opacity.combined(with: .scale))
                        .id("temp-\(diary.temperature)-\(UUID().uuidString)") // å¼ºåˆ¶åˆ·æ–°
                    
                    if weatherService != nil && isToday {
                        Button(action: {
                            withAnimation(AnimationConstants.quick) {
                                isUpdating = true
                            }
                            updateWeather()
                            
                            // å»¶é²é‡ç½®å‹•ç•«ç‹€æ…‹
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                                withAnimation(AnimationConstants.quick) {
                                    isUpdating = false
                                }
                            }
                        }) {
                            if isLoading {
                                ProgressView()
                                    .controlSize(.small)
                            } else {
                                Image(systemName: "arrow.clockwise.circle.fill")
                                    .font(.system(size: contentFontSize))
                                    .foregroundColor(.blue)
                                    .rotationEffect(.degrees(isUpdating ? 360 : 0))
                            }
                        }
                        .buttonStyle(ScaleButtonStyle())
                        .customCursor(.pointingHand)
                        .help("æ›´æ–°å¤©æ°£è³‡è¨Š")
                    }
                    
                    Button(action: switchToManual) {
                        Image(systemName: "hand.tap.fill")
                            .font(.system(size: contentFontSize))
                            .foregroundColor(.blue)
                    }
                    .buttonStyle(ScaleButtonStyle())
                    .customCursor(.pointingHand)
                    .help("åˆ‡æ›åˆ°æ‰‹å‹•é¸æ“‡å¤©æ°£")
                    .transition(.scale.combined(with: .opacity))
                } else {
                    if weatherService != nil && isToday {
                        Button(action: updateWeather) {
                            if isLoading {
                                ProgressView()
                                    .controlSize(.small)
                            } else {
                                Label("è‡ªå‹•æ›´æ–°", systemImage: "cloud.fill")
                                    .font(.system(size: contentFontSize))
                                    .foregroundColor(.blue)
                            }
                        }
                        .buttonStyle(ScaleButtonStyle())
                        .customCursor(.pointingHand)
                        .help("è‡ªå‹•ç²å–ç•¶å‰å¤©æ°£è³‡è¨Š")
                        .transition(.scale.combined(with: .opacity))
                    }
                }
            }
            .animation(AnimationConstants.standard, value: isOnline)
            .animation(AnimationConstants.standard, value: isLoading)
            
            if !isOnline {
                WeatherTypeSelectionView(
                    selectedWeather: $selectedWeather,
                    diary: diary,
                    contentFontSize: contentFontSize,
                    saveContext: saveContext
                )
                .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
        .animation(AnimationConstants.standard, value: isOnline)
    }
}

// MARK: - Weather Type Selection View
private struct WeatherTypeSelectionView: View {
    @Binding var selectedWeather: String
    let diary: DiaryEntry
    let contentFontSize: Double
    let saveContext: () -> Void
    
    // æ·»åŠ å‹•ç•«ç‹€æ…‹
    @State private var animateSelection = false
    @Namespace private var weatherAnimation
    
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 15) {
                ForEach(WeatherType.allCases, id: \.self) { weather in
                    VStack {
                        ZStack {
                            // ç•¶è¢«é¸ä¸­æ™‚é¡¯ç¤ºçš„èƒŒæ™¯åœ“åœˆ
                            if selectedWeather == weather.rawValue {
                                Circle()
                                    .fill(Color.blue.opacity(0.2))
                                    .matchedGeometryEffect(id: "background", in: weatherAnimation)
                            }
                            
                            Image(systemName: weather.icon)
                                .font(.system(size: contentFontSize))
                                .foregroundColor(selectedWeather == weather.rawValue ? .blue : .gray)
                                .padding(8)
                        }
                        .frame(width: 40, height: 40)
                        
                        Text(weather.rawValue)
                            .font(.system(size: contentFontSize))
                            .foregroundColor(selectedWeather == weather.rawValue ? .primary : .secondary)
                    }
                    .onTapGesture {
                        withAnimation(AnimationConstants.spring) {
                            selectedWeather = weather.rawValue
                            diary.weather = weather
                            animateSelection = true
                        }
                        
                        // åŸ·è¡Œä¸€äº›æ›´å¤šçš„å‹•ç•«æ•ˆæœ
                        withAnimation(AnimationConstants.springSmall.delay(0.1)) {
                            animateSelection = false
                        }
                        
                        saveContext()
                    }
                    .scaleEffect(selectedWeather == weather.rawValue && animateSelection ? 1.1 : 1.0)
                    .customCursor(.pointingHand)
                    .help("é¸æ“‡\(weather.rawValue)å¤©æ°£")
                }
            }
            .padding(.horizontal, 5)
        }
        .frame(height: 80)
        .padding(.vertical, 5)
        .background(Color(NSColor.controlBackgroundColor).opacity(0.5))
        .cornerRadius(10)
        .animation(AnimationConstants.standard, value: selectedWeather)
    }
}

// MARK: - Thoughts Section View
private struct ThoughtsSectionView: View {
    @Binding var thoughts: String
    let titleFontSize: Double
    let titleFontColor: String
    let saveContext: () -> Void
    let diary: DiaryEntry
    
    // æ·»åŠ å‹•ç•«ç‹€æ…‹
    @State private var isFocused: Bool = false
    @State private var showSavedIndicator: Bool = false
    @State private var appearScale: CGFloat = 0.98
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text("å¿ƒå¾—")
                    .font(.system(size: titleFontSize))
                    .foregroundColor(Color.fromString(titleFontColor))
                
                Spacer()
                
                // ä¿å­˜æŒ‡ç¤ºå™¨ - ä¿ç•™æ·¡å…¥æ·¡å‡ºå‹•ç•«ä½†ç§»é™¤ç¸®æ”¾æ•ˆæœ
                if showSavedIndicator {
                    HStack(spacing: 4) {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(.green)
                        Text("å·²ä¿å­˜")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .transition(.opacity) // ç§»é™¤ç¸®æ”¾æ•ˆæœï¼Œåªä¿ç•™æ·¡å…¥æ·¡å‡º
                    .onAppear {
                        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                            withAnimation(AnimationConstants.standard) {
                                showSavedIndicator = false
                            }
                        }
                    }
                }
            }
            
            ZStack {
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color(NSColor.textBackgroundColor))
                    .shadow(color: Color.black.opacity(isFocused ? 0.1 : 0.05), radius: isFocused ? 5 : 3, x: 0, y: 1)
                
                EnhancedTextEditor(text: $thoughts)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .frame(minHeight: 250)
                    .padding(5)
            }
            .onChange(of: thoughts) { oldValue, newValue in
                diary.thoughts = newValue
                saveContext()
                
                // åªé¡¯ç¤ºä¿å­˜æŒ‡ç¤ºå™¨ï¼Œä¸æ·»åŠ ç¸®æ”¾å‹•ç•«
                withAnimation(.easeIn(duration: 0.2)) {
                    showSavedIndicator = true
                }
            }
            .onHover { hovering in
                withAnimation(AnimationConstants.quick) {
                    isFocused = hovering
                }
            }
            .help("åœ¨æ­¤è¼¸å…¥ä»Šæ—¥å¿ƒå¾—")
        }
        .padding(.top, 8)
        .scaleEffect(appearScale)
        .onAppear {
            withAnimation(AnimationConstants.spring) {
                appearScale = 1.0
            }
        }
    }
}

// MARK: - è‡ªå®šç¾©æ–‡æœ¬ç·¨è¼¯å™¨
/// æ”¯æŒæ®µè½é¦–å­—æ”¾å¤§çš„æ–‡æœ¬ç·¨è¼¯å™¨ï¼Œä¿æŒå…‰æ¨™ä½ç½®ç©©å®š
struct EnhancedTextEditor: NSViewRepresentable {
    @Binding var text: String
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    class Coordinator: NSObject, NSTextViewDelegate {
        var parent: EnhancedTextEditor
        var shouldUpdateText = true
        var isComposing = false  // è¿½è¸ªä¸­æ–‡è¾“å…¥çŠ¶æ€
        
        init(_ parent: EnhancedTextEditor) {
            self.parent = parent
        }
        
        func textDidChange(_ notification: Notification) {
            guard shouldUpdateText, let textView = notification.object as? NSTextView else { return }
            
            // åªæ›´æ–°ç»‘å®šçš„æ–‡æœ¬å€¼ï¼Œä¸åº”ç”¨æ ·å¼
            parent.text = textView.string
        }
        
        // ç›‘å¬è¾“å…¥æ³•ç¼–è¾‘ä¼šè¯å¼€å§‹
        func textView(_ textView: NSTextView, didStartComposingAtPosition position: Int) {
            isComposing = true
        }
        
        // ç›‘å¬è¾“å…¥æ³•ç¼–è¾‘ä¼šè¯ç»“æŸ
        func textView(_ textView: NSTextView, didEndComposingAtPosition position: Int) {
            isComposing = false
            
            // ä¸­æ–‡è¾“å…¥å®Œæˆåï¼Œåº”ç”¨æ ·å¼
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.applyStyleAfterTyping(textView)
            }
        }
        
        // è¾“å…¥å®Œæˆååº”ç”¨æ ·å¼
        func applyStyleAfterTyping(_ textView: NSTextView) {
            if isComposing { return }
            
            // ä¿å­˜å½“å‰é€‰æ‹©èŒƒå›´
            let selectedRanges = textView.selectedRanges
            
            shouldUpdateText = false
            
            // åº”ç”¨æ®µè½é¦–å­—æ ·å¼
            let text = textView.string
            let attributedString = NSMutableAttributedString(string: text)
            
            // è®¾ç½®åŸºæœ¬æ ·å¼
            attributedString.addAttribute(.font, 
                                          value: NSFont.systemFont(ofSize: CGFloat(parent.contentFontSize)),
                                          range: NSRange(location: 0, length: text.count))
            attributedString.addAttribute(.foregroundColor, 
                                          value: NSColor.fromString(parent.contentFontColor),
                                          range: NSRange(location: 0, length: text.count))
            
            // åº”ç”¨æ®µè½é¦–å­—æ ·å¼
            var paragraphStart = 0
            text.enumerateSubstrings(in: text.startIndex..<text.endIndex, options: [.byParagraphs]) { (substring, substringRange, _, _) in
                guard let paragraphText = substring, 
                      !paragraphText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
                
                // æ‰¾åˆ°æ®µè½å¼€å§‹ä½ç½®
                paragraphStart = text.distance(from: text.startIndex, to: substringRange.lowerBound)
                
                // åº”ç”¨é¦–å­—æ ·å¼
                if paragraphStart < text.count {
                    let paragraphFirstCharLength = min(1, text.count - paragraphStart)
                    attributedString.addAttribute(
                        .font, 
                        value: NSFont.boldSystemFont(ofSize: CGFloat(self.parent.contentFontSize) * 1.2),
                        range: NSRange(location: paragraphStart, length: paragraphFirstCharLength)
                    )
                    attributedString.addAttribute(
                        .foregroundColor, 
                        value: NSColor.systemYellow,
                        range: NSRange(location: paragraphStart, length: paragraphFirstCharLength)
                    )
                }
            }
            
            // åº”ç”¨æ ·å¼
            textView.textStorage?.setAttributedString(attributedString)
            
            // æ¢å¤é€‰æ‹©èŒƒå›´
            textView.selectedRanges = selectedRanges
            
            shouldUpdateText = true
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    func makeNSView(context: Context) -> NSScrollView {
        // åˆ›å»ºæ–‡æœ¬è§†å›¾å’Œæ»šåŠ¨è§†å›¾
        let scrollView = NSScrollView()
        scrollView.hasVerticalScroller = true
        scrollView.borderType = .noBorder
        
        let textView = NSTextView()
        textView.minSize = NSSize(width: 0, height: 0)
        textView.maxSize = NSSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)
        textView.isVerticallyResizable = true
        textView.isHorizontallyResizable = false
        textView.autoresizingMask = [.width]
        textView.textContainer?.widthTracksTextView = true
        textView.textContainer?.containerSize = NSSize(
            width: scrollView.contentSize.width,
            height: CGFloat.greatestFiniteMagnitude
        )
        
        // åŸºæœ¬é…ç½®
        textView.allowsUndo = true
        textView.isRichText = true
        textView.isEditable = true
        textView.isSelectable = true
        textView.font = .systemFont(ofSize: CGFloat(contentFontSize))
        textView.textColor = NSColor.fromString(contentFontColor)
        
        // è®¾ç½®æ®µè½æ ·å¼
        let defaultParagraphStyle = NSMutableParagraphStyle()
        defaultParagraphStyle.paragraphSpacing = 10 // æ®µè½é—´è·
        textView.defaultParagraphStyle = defaultParagraphStyle
        
        // è®¾ç½®ä»£ç†
        textView.delegate = context.coordinator
        
        // è®¾ç½®åˆå§‹æ–‡æœ¬
        textView.string = text
        
        // åˆå§‹åº”ç”¨æ®µè½é¦–å­—æ ·å¼
        if !text.isEmpty {
            context.coordinator.applyStyleAfterTyping(textView)
        }
        
        // ç»„è£…
        scrollView.documentView = textView
        
        return scrollView
    }
    
    func updateNSView(_ scrollView: NSScrollView, context: Context) {
        guard let textView = scrollView.documentView as? NSTextView else { return }
        
        // æ–‡æœ¬å†…å®¹éœ€è¦æ›´æ–°æ—¶ï¼ˆå¤–éƒ¨æ›´æ–°ï¼‰
        if textView.string != text && !context.coordinator.isComposing {
            // è·å–å½“å‰é€‰æ‹©èŒƒå›´å’Œæ»šåŠ¨ä½ç½®
            let selectedRanges = textView.selectedRanges
            let scrollPosition = scrollView.contentView.bounds.origin
            
            // æš‚æ—¶ç¦ç”¨æ–‡æœ¬æ›´æ–°å›è°ƒ
            context.coordinator.shouldUpdateText = false
            
            // æ›´æ–°æ–‡æœ¬
            textView.string = text
            
            // åº”ç”¨æ®µè½é¦–å­—æ ·å¼
            if !text.isEmpty {
                context.coordinator.applyStyleAfterTyping(textView)
            }
            
            // æ¢å¤é€‰æ‹©èŒƒå›´å’Œæ»šåŠ¨ä½ç½®
            textView.selectedRanges = selectedRanges
            scrollView.contentView.scroll(to: scrollPosition)
            
            // é‡æ–°å¯ç”¨æ–‡æœ¬æ›´æ–°å›è°ƒ
            context.coordinator.shouldUpdateText = true
        }
        
        // åªåœ¨å­—ä½“è®¾ç½®æ›´æ”¹æ—¶æ›´æ–°
        if textView.font?.pointSize != CGFloat(contentFontSize) || 
           textView.textColor != NSColor.fromString(contentFontColor) {
            textView.font = .systemFont(ofSize: CGFloat(contentFontSize))
            textView.textColor = NSColor.fromString(contentFontColor)
            
            // åº”ç”¨æ®µè½é¦–å­—æ ·å¼
            if !textView.string.isEmpty && !context.coordinator.isComposing {
                context.coordinator.applyStyleAfterTyping(textView)
            }
        }
    }
}




// MARK: - é¡åˆ¥è©³ç´°è¦–åœ–
/// é¡¯ç¤ºç‰¹å®šé¡åˆ¥è©³ç´°å…§å®¹çš„è¦–åœ–
struct CategoryDetailView: View {
    @Environment(\.modelContext) private var modelContext
    let type: CategoryType
    let diary: DiaryEntry
    @State private var showingCategoryForm = false
    @State private var editingEntry: CategoryEntry?
    
    /// ä¿å­˜æ•¸æ“šåˆ°æŒä¹…åŒ–å­˜å„²
    private func saveContext() {
        do {
            try modelContext.save()
            print("\(type.rawValue)æ•¸æ“šä¿å­˜æˆåŠŸ")
        } catch {
            print("ä¿å­˜å¤±æ•—: \(error)")
        }
    }
    
    /// ç²å–ç‰¹å®šé¡å‹çš„æ¢ç›®åˆ—è¡¨
    private func getEntries(for type: CategoryType, in diary: DiaryEntry) -> [CategoryEntry] {
        switch type {
        case .expense: return diary.expenses
        case .exercise: return diary.exercises
        case .sleep: return diary.sleeps
        case .work: return diary.works
        case .relationship: return diary.relationships
        case .study: return diary.studies
        }
    }
    
    var body: some View {
        VStack {
            CategoryTableView(
                type: type,
                entries: getEntries(for: type, in: diary),
                diary: diary,
                onAdd: {
                    editingEntry = nil
                    showingCategoryForm = true
                },
                onDelete: { indexSet in
                    switch type {
                    case .expense:
                        diary.expenses.remove(atOffsets: indexSet)
                    case .exercise:
                        diary.exercises.remove(atOffsets: indexSet)
                    case .sleep:
                        diary.sleeps.remove(atOffsets: indexSet)
                    case .work:
                        diary.works.remove(atOffsets: indexSet)
                    case .relationship:
                        diary.relationships.remove(atOffsets: indexSet)
                    case .study:
                        diary.studies.remove(atOffsets: indexSet)
                    }
                    saveContext()
                },
                onEdit: { entry in
                    editingEntry = entry
                    showingCategoryForm = true
                }
            )
        }
        .sheet(isPresented: $showingCategoryForm) {
            if let entry = editingEntry {
                CategoryEntryForm(type: type, diary: diary, editingEntry: entry)
            } else {
                CategoryEntryForm(type: type, diary: diary)
            }
        }
        .onChange(of: showingCategoryForm) { oldValue, newValue in
            if !newValue {
                // ç•¶è¡¨å–®é—œé–‰æ™‚ï¼Œæ¸…é™¤ç·¨è¼¯ç‹€æ…‹
                editingEntry = nil
            }
        }
    }
}

#Preview {
    let config = ModelConfiguration(isStoredInMemoryOnly: true)
    let container = try! ModelContainer(for: DiaryEntry.self, CategoryEntry.self, configurations: config)
    return ContentView()
        .modelContainer(container)
}

// MARK: - åå¥½è¨­ç½®è¦–åœ–
struct PreferencesView: View {
    @Environment(\.dismiss) private var dismiss
    
    // å­—é«”è¨­ç½®
    @AppStorage("titleFontSize") private var titleFontSize: Double = 22
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    
    // é¡è‰²è¨­ç½®
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    // ç›®æ¨™è¨­ç½®
    @AppStorage("monthlyExpenseLimit") private var monthlyExpenseLimit: Double = 20000
    @AppStorage("dailyExerciseGoal") private var dailyExerciseGoal: Double = 60
    @AppStorage("dailySleepGoal") private var dailySleepGoal: Double = 390
    @AppStorage("dailyWorkGoal") private var dailyWorkGoal: Double = 120
    @AppStorage("dailyRelationshipGoal") private var dailyRelationshipGoal: Double = 30
    @AppStorage("dailyStudyGoal") private var dailyStudyGoal: Double = 60
    
    // å¤©æ°£è¨­ç½®
    @AppStorage("weatherApiKey") private var weatherApiKey: String = "76fb9beb7dd213c17447b2b9080e0bcb"
    
    // å®‰å…¨è¨­ç½®
    @AppStorage("useBiometricAuth") private var useBiometricAuth: Bool = false
    
    // å¯ç”¨çš„é¡è‰²é¸é …
    private let availableColors = ["Red", "Green", "Blue", "Orange", "Purple", "Yellow", "White", "Black"]
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // å­—é«”è¨­ç½®
                    GroupBox(label: Text("å­—é«”è¨­ç½®").font(.headline)) {
                        VStack(alignment: .leading, spacing: 15) {
                            VStack(alignment: .leading) {
                                Text("æ¨™é¡Œå­—é«”å¤§å°: \(Int(titleFontSize))")
                                    .foregroundColor(Color.fromString(titleFontColor))
                                    .font(.system(size: titleFontSize))
                                
                                Slider(value: $titleFontSize, in: 14...32, step: 1)
                            }
                            .padding(.bottom, 5)
                            
                            VStack(alignment: .leading) {
                                Text("å…§å®¹å­—é«”å¤§å°: \(Int(contentFontSize))")
                                    .foregroundColor(Color.fromString(contentFontColor))
                                    .font(.system(size: contentFontSize))
                                
                                Slider(value: $contentFontSize, in: 12...28, step: 1)
                            }
                            .padding(.bottom, 5)
                            
                            // æ¨™é¡Œé¡è‰²
                            HStack {
                                Text("æ¨™é¡Œå­—é«”é¡è‰²")
                                Spacer()
                                Menu {
                                    ForEach(availableColors, id: \.self) { color in
                                        Button(color) {
                                            titleFontColor = color
                                        }
                                    }
                                } label: {
                                    HStack {
                                        Text(titleFontColor)
                                            .foregroundColor(Color.fromString(titleFontColor))
                                        Image(systemName: "chevron.up.chevron.down")
                                            .foregroundColor(.blue)
                                    }
                                }
                            }
                            .padding(.bottom, 5)
                            
                            // å…§å®¹é¡è‰²
                            HStack {
                                Text("å…§å®¹å­—é«”é¡è‰²")
                                Spacer()
                                Menu {
                                    ForEach(availableColors, id: \.self) { color in
                                        Button(color) {
                                            contentFontColor = color
                                        }
                                    }
                                } label: {
                                    HStack {
                                        Text(contentFontColor)
                                            .foregroundColor(Color.fromString(contentFontColor))
                                        Image(systemName: "chevron.up.chevron.down")
                                            .foregroundColor(.blue)
                                    }
                                }
                            }
                        }
                        .padding()
                    }
                    .padding(.horizontal)
                    
                    // ç›®æ¨™è¨­ç½®
                    GroupBox(label: Text("ç›®æ¨™è¨­ç½®").font(.headline)) {
                        VStack(spacing: 15) {
                            HStack {
                                Text("æœˆæ”¯å‡ºä¸Šé™")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $monthlyExpenseLimit, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                            
                            HStack {
                                Text("æ¯æ—¥é‹å‹•æ™‚é–“")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $dailyExerciseGoal, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                            
                            HStack {
                                Text("æ¯æ—¥ç¡çœ æ™‚é–“")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $dailySleepGoal, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                            
                            HStack {
                                Text("æ¯æ—¥å·¥ä½œæ™‚é–“")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $dailyWorkGoal, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                            
                            HStack {
                                Text("æ¯æ—¥é—œä¿‚ç¶“ç‡Ÿ")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $dailyRelationshipGoal, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                            
                            HStack {
                                Text("æ¯æ—¥å­¸ç¿’æ™‚é–“")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $dailyStudyGoal, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                        }
                        .padding()
                    }
                    .padding(.horizontal)
                    
                    // å¤©æ°£è¨­ç½®
                    GroupBox(label: Text("å¤©æ°£è¨­ç½®").font(.headline)) {
                        VStack(alignment: .leading) {
                            Text("OpenWeatherMap API Key")
                                .foregroundColor(.green)
                            TextField("API Key", text: $weatherApiKey)
                                .font(.system(size: 14))
                                .textFieldStyle(.roundedBorder)
                        }
                        .padding()
                    }
                    .padding(.horizontal)
                    
                    // å®‰å…¨è¨­ç½®
                    GroupBox(label: Text("å®‰å…¨è¨­ç½®").font(.headline)) {
                        Toggle("ä½¿ç”¨æŒ‡ç´‹è§£é–", isOn: $useBiometricAuth)
                            .padding()
                    }
                    .padding(.horizontal)
                }
                .padding(.vertical)
            }
            .navigationTitle("åå¥½è¨­ç½®")
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("å®Œæˆ") {
                        dismiss()
                    }
                }
            }
        }
    }
}

// MARK: - é¢œè‰²è¾…åŠ©å‡½æ•°
extension Color {
    static func fromString(_ colorName: String) -> Color {
        switch colorName.lowercased() {
        case "red": return .red
        case "green": return .green
        case "blue": return .blue
        case "orange": return .orange
        case "purple": return .purple
        case "yellow": return .yellow
        case "white": return .white
        case "black": return .black
        default: return .primary
        }
    }
}

extension NSColor {
    static func fromString(_ colorName: String) -> NSColor {
        switch colorName.lowercased() {
        case "red": return .systemRed
        case "green": return .systemGreen
        case "blue": return .systemBlue
        case "orange": return .systemOrange
        case "purple": return .systemPurple
        case "yellow": return .systemYellow
        case "white": return .white
        case "black": return .black
        default: return .labelColor
        }
    }
}

// MARK: - ä½¿ç”¨èªªæ˜è¦–åœ–
struct HelpView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack {
            // æ¨™é¡Œå’Œé—œé–‰æŒ‰éˆ•
            HStack {
                Text("ä½¿ç”¨èªªæ˜")
                    .font(.system(size: 28))
                    .fontWeight(.bold)
                Spacer()
                Button("å®Œæˆ") {
                    dismiss()
                }
                .font(.system(size: 20))
            }
            .padding()
            
            // å…§å®¹
            ScrollView {
                VStack(alignment: .leading, spacing: 25) {
                    Group {
                        helpSection(title: "åŸºæœ¬æ“ä½œ",
                                  items: ["é»æ“Šå³ä¸Šè§’ã€Œ+ã€æŒ‰éˆ•æ–°å¢æ—¥è¨˜",
                                         "å·¦æ»‘æ—¥è¨˜é …ç›®å¯ä»¥åˆªé™¤",
                                         "é»æ“Šæ—¥è¨˜é …ç›®å¯ä»¥æŸ¥çœ‹è©³ç´°å…§å®¹",
                                         "åœ¨æ—¥æ›†ä¸­é¸æ“‡æ—¥æœŸå¯ä»¥æŸ¥çœ‹è©²æ—¥çš„æ—¥è¨˜"])
                        
                        helpSection(title: "å¤©æ°£è¨˜éŒ„",
                                  items: ["æ–°å¢æ—¥è¨˜æ™‚å¯ä»¥æ‰‹å‹•é¸æ“‡å¤©æ°£",
                                         "é»æ“Šã€Œç²å–å¤©æ°£ã€å¯ä»¥è‡ªå‹•ç²å–ç•¶å‰ä½ç½®çš„å¤©æ°£",
                                         "å¤©æ°£è³‡è¨ŠåŒ…å«æº«åº¦ç¯„åœå’Œå¤©æ°£æè¿°"])
                        
                        helpSection(title: "å¤©æ°£ API è¨­ç½®",
                                  items: ["æœ¬ç¨‹å¼ä½¿ç”¨ OpenWeatherMap æä¾›çš„å…è²»å¤©æ°£ API",
                                         "1. å‰å¾€ OpenWeatherMap ç¶²ç«™è¨»å†Šå¸³è™Ÿï¼šhttps://openweathermap.org/",
                                         "2. è¨»å†Šå®Œæˆå¾Œï¼Œç™»å…¥ä¸¦é€²å…¥ API Keys é é¢ï¼šhttps://home.openweathermap.org/api_keys",
                                         "3. é»æ“Šã€ŒGenerateã€æŒ‰éˆ•å‰µå»ºæ–°çš„ API Key",
                                         "4. è¤‡è£½ç”Ÿæˆçš„ API Key",
                                         "5. åœ¨æœ¬ç¨‹å¼çš„ã€Œåå¥½è¨­ç½®ã€ä¸­ï¼Œå°‡ API Key è²¼ä¸Šåˆ°ã€Œå¤©æ°£è¨­ç½®ã€æ¬„ä½",
                                         "6. API Key ç”Ÿæ•ˆå¯èƒ½éœ€è¦ç­‰å¾…å¹¾å°æ™‚",
                                         "æ³¨æ„ï¼šå…è²»ç‰ˆæ¯åˆ†é˜å¯å‘¼å« 60 æ¬¡ï¼Œå°æ–¼ä¸€èˆ¬ä½¿ç”¨å·²ç¶“è¶³å¤ "])
                        
                        helpSection(title: "åˆ†é¡è¨˜éŒ„",
                                  items: ["æ”¯æ´å…­ç¨®åˆ†é¡è¨˜éŒ„ï¼šæ”¯å‡ºã€é‹å‹•ã€ç¡çœ ã€å·¥ä½œã€é—œä¿‚ã€å­¸ç¿’",
                                         "æ¯å€‹åˆ†é¡éƒ½å¯ä»¥æ·»åŠ å¤šå€‹è¨˜éŒ„",
                                         "åˆ†é¡è¨˜éŒ„åŒ…å«åç¨±ã€é¡åˆ¥ã€æ•¸é‡å’Œå‚™è¨»",
                                         "éƒ¨åˆ†åˆ†é¡æä¾›é è¨­çš„é¡åˆ¥é¸é …"])
                        
                        helpSection(title: "æœå°‹åŠŸèƒ½",
                                  items: ["ä½¿ç”¨Command+Fæˆ–é»æ“Šæœå°‹æŒ‰éˆ•é–‹å•Ÿæœå°‹",
                                         "å¯ä»¥æœå°‹æ—¥æœŸã€å¤©æ°£ã€å¿ƒå¾—å’Œæ‰€æœ‰åˆ†é¡è¨˜éŒ„",
                                         "ä½¿ç”¨ä¸Šä¸‹ç®­é ­æˆ–æŒ‰éˆ•åœ¨æœå°‹çµæœä¸­å°èˆª"])
                        
                        helpSection(title: "æ•¸æ“šç®¡ç†",
                                  items: ["æ”¯æ´åŒ¯å‡ºæ—¥è¨˜æ•¸æ“šç‚ºJSONæ ¼å¼",
                                         "å¯ä»¥åŒ¯å…¥ä¹‹å‰åŒ¯å‡ºçš„æ•¸æ“š",
                                         "å¯ä»¥é¸æ“‡æ—¥æœŸç¯„åœé€²è¡ŒåŒ¯å‡º"])
                        
                        helpSection(title: "å€‹äººåŒ–è¨­å®š",
                                  items: ["å¯ä»¥èª¿æ•´æ¨™é¡Œå’Œå…§å®¹çš„å­—é«”å¤§å°",
                                         "å¯ä»¥æ›´æ”¹æ¨™é¡Œå’Œå…§å®¹çš„é¡è‰²",
                                         "æ”¯æ´Face ID/Touch IDè§£é–åŠŸèƒ½",
                                         "å¯ä»¥è¨­ç½®é–‹ç™¼è€…æ¨¡å¼è·³éèªè­‰"])
                    }
                }
                .padding()
            }
        }
    }
    
    private func helpSection(title: String, items: [String]) -> some View {
        VStack(alignment: .leading, spacing: 15) {
            Text(title)
                .font(.system(size: 24))
                .fontWeight(.bold)
            
            ForEach(items, id: \.self) { item in
                if item.hasPrefix("http") {
                    Link(item, destination: URL(string: item)!)
                        .font(.system(size: 21))
                        .foregroundColor(.blue)
                        .padding(.leading, 25)
                } else {
                    HStack(alignment: .top, spacing: 10) {
                        Text("â€¢")
                            .foregroundColor(.blue)
                            .font(.system(size: 21))
                        Text(item)
                            .font(.system(size: 21))
                    }
                }
            }
        }
    }
}

// æ·»åŠ è‡ªå®šç¾©æ¸¸æ¨™ä¿®é£¾ç¬¦
struct CursorModifier: ViewModifier {
    let cursor: NSCursor
    
    func body(content: Content) -> some View {
        content.onHover { inside in
            if inside {
                cursor.push()
            } else {
                NSCursor.pop()
            }
        }
    }
}

extension View {
    func customCursor(_ cursor: NSCursor) -> some View {
        modifier(CursorModifier(cursor: cursor))
    }
}

// MARK: - å¸¶è‡ªå‹•å®ŒæˆåŠŸèƒ½çš„åç¨±è¼¸å…¥å€å¡Š
private struct NameSectionWithAutocomplete: View {
    let type: CategoryType
    @Binding var name: String
    let suggestions: [String]
    @Binding var showingSuggestions: Bool
    @Binding var selectedSuggestionIndex: Int
    let onNameChanged: () -> Void
    let onSuggestionSelected: (String) -> Void
    let onTabPressed: () -> Void
    @FocusState private var isNameFocused: Bool
    
    var nameLabel: String {
        switch type {
        case .expense: return "åç¨±"
        case .exercise: return "åç¨±"
        case .sleep: return "å“è³ª"
        case .work: return "åç¨±"
        case .relationship: return "å§“å"
        case .study: return "åç¨±"
        }
    }
    
    var body: some View {
        Section {
            VStack(alignment: .leading, spacing: 0) {
                HStack {
                    Image(systemName: type.icon)
                        .foregroundColor(.blue)
                        .font(.system(size: 20))
                    Text(nameLabel)
                        .foregroundColor(.secondary)
                        .font(.system(size: 20))
                    Spacer()
                    
                    TextField("", text: $name)
                        .textFieldStyle(.plain)
                        .font(.system(size: 20))
                        .multilineTextAlignment(.trailing)
                        .onChange(of: name) { oldValue, newValue in
                            onNameChanged()
                        }
                        .focused($isNameFocused)
                        .onSubmit {
                            showingSuggestions = false
                        }
                        .onKeyPress(.tab) {
                            onTabPressed()
                            return .handled
                        }
                        .help("è¼¸å…¥\(nameLabel)ï¼ŒæŒ‰Tabå¯è‡ªå‹•å¡«å¯«")
                }
                
                if showingSuggestions && isNameFocused {
                    ScrollView {
                        LazyVStack(alignment: .leading, spacing: 8) {
                            ForEach(Array(suggestions.enumerated()), id: \.element) { index, suggestion in
                                Text(suggestion)
                                    .font(.system(size: 18))
                                    .padding(.vertical, 4)
                                    .padding(.horizontal, 8)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(index == selectedSuggestionIndex ? Color.blue.opacity(0.2) : Color.clear)
                                    .cornerRadius(4)
                                    .contentShape(Rectangle())
                                    .onTapGesture {
                                        onSuggestionSelected(suggestion)
                                    }
                                    .onHover { isHovered in
                                        if isHovered {
                                            selectedSuggestionIndex = index
                                        }
                                    }
                                    .customCursor(.pointingHand)
                            }
                        }
                    }
                    .frame(maxHeight: 150)
                    .background(Color(NSColor.windowBackgroundColor))
                    .overlay(
                        RoundedRectangle(cornerRadius: 5)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
                    .padding(.top, 4)
                }
            }
        }
    }
}

// MARK: - å‹•ç•«å¸¸æ•¸
struct AnimationConstants {
    static let standard = Animation.easeInOut(duration: 0.3)
    static let quick = Animation.easeOut(duration: 0.2)
    static let slow = Animation.easeInOut(duration: 0.5)
    static let spring = Animation.spring(response: 0.3, dampingFraction: 0.6)
    static let springSmall = Animation.spring(response: 0.2, dampingFraction: 0.75)
}

// MARK: - è‡ªå®šç¾©å‹•ç•«æŒ‰éˆ•æ¨£å¼
struct ScaleButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1)
            .animation(.spring(response: 0.2), value: configuration.isPressed)
    }
}

// MARK: - è‡ªå®šä¹‰æ—¥æœŸé€‰æ‹©å™¨
struct CustomDatePickerView: View {
    @Binding var selectedDate: Date
    let timeInterval: Calendar.Component = .day // å›ºå®šä¸ºæŒ‰å¤©å¢å‡
    @State private var showingCalendar: Bool = false
    var titleFontColor: String = "Green" // é»˜è®¤å€¼
    var contentFontColor: String = "White" // é»˜è®¤å€¼
    
    var body: some View {
        HStack(spacing: 5) {
            HStack(spacing: 0) {
                Text(dateFormatter.string(from: selectedDate))
                    .frame(minWidth: 120)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .font(.system(size: 20))
                    .foregroundColor(Color.fromString(contentFontColor)) // ä½¿ç”¨ç”¨æˆ·é¦–é€‰çš„å†…å®¹å­—ä½“é¢œè‰²
                    .background(
                        RoundedRectangle(cornerRadius: 4)
                            .fill(Color(NSColor.controlBackgroundColor))
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: 4)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
                
                VStack(spacing: 0) {
                    Button(action: incrementDate) {
                        Image(systemName: "chevron.up")
                            .frame(width: 20, height: 12)
                            .contentShape(Rectangle())
                    }
                    .buttonStyle(.borderless)
                    .padding(.vertical, 2)
                    .customCursor(.pointingHand)
                    .help("å¢åŠ ä¸€å¤©")
                    
                    Divider()
                        .frame(height: 1)
                    
                    Button(action: decrementDate) {
                        Image(systemName: "chevron.down")
                            .frame(width: 20, height: 12)
                            .contentShape(Rectangle())
                    }
                    .buttonStyle(.borderless)
                    .padding(.vertical, 2)
                    .customCursor(.pointingHand)
                    .help("æ¸›å°‘ä¸€å¤©")
                }
                .frame(width: 20)
                .overlay(
                    RoundedRectangle(cornerRadius: 4)
                        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                )
            }
            .fixedSize()
            
            // æ·»åŠ æ—¥å†æŒ‰é’®
            Button(action: {
                showingCalendar = true
            }) {
                Image(systemName: "calendar")
                    .frame(width: 24, height: 24)
                    .foregroundColor(Color.fromString(titleFontColor)) // ä½¿ç”¨æ ‡é¢˜å­—ä½“é¢œè‰²
                    .padding(2)
            }
            .buttonStyle(.borderless)
            .background(
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color(NSColor.controlBackgroundColor))
                    .overlay(
                        RoundedRectangle(cornerRadius: 4)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
            )
            .customCursor(.pointingHand)
            .help("é–‹å•Ÿæ—¥æ›†")
            .popover(isPresented: $showingCalendar, arrowEdge: .bottom) {
                VStack {
                    DatePicker("", selection: $selectedDate, displayedComponents: [.date])
                        .datePickerStyle(.graphical)
                        .labelsHidden()
                        .padding()
                        .frame(minWidth: 300)
                    
                    Button("ç¢ºå®š") {
                        showingCalendar = false
                    }
                    .buttonStyle(.borderedProminent)
                    .padding(.bottom)
                }
                .padding(5)
            }
        }
    }
    
    private var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy/M/d"
        return formatter
    }
    
    private func incrementDate() {
        withAnimation {
            selectedDate = Calendar.current.date(byAdding: timeInterval, value: 1, to: selectedDate) ?? selectedDate
        }
    }
    
    private func decrementDate() {
        withAnimation {
            selectedDate = Calendar.current.date(byAdding: timeInterval, value: -1, to: selectedDate) ?? selectedDate
        }
    }
}

// MARK: - è¦–åœ–æ“´å±•
extension View {
    @ViewBuilder
    func customCursor(_ cursor: NSCursor) -> some View {
        if #available(macOS 13.0, *) {
            self.onContinuousHover { phase in
                switch phase {
                case .active:
                    cursor.push()
                case .ended:
                    NSCursor.pop()
                }
            }
        } else {
            self.onHover { isHovered in
                if isHovered {
                    cursor.push()
                } else {
                    NSCursor.pop()
                }
            }
        }
    }
    
    /// è§£å†³toolbaræ­§ä¹‰é—®é¢˜çš„å®‰å…¨åŒ…è£…
    func safeToolbar<Content: ToolbarContent>(@ViewBuilder content: () -> Content) -> some View {
        self.toolbar {
            content()
        }
    }
}

// MARK: - Modifiers
struct ListToolbarModifier: ViewModifier {
    let toggleSearchField: () -> Void
    let showSearchField: Bool
    let switchToToday: () -> Void
    @Binding var isExporting: Bool
    @Binding var showingDateRangeSheet: Bool
    @Binding var showingPreferencesSheet: Bool
    @Binding var showingHelpSheet: Bool
    @Binding var showingNewDiarySheet: Bool
    
    func body(content: Content) -> some View {
        content.toolbar {
            ToolbarItem(placement: .automatic) {
                Button(action: toggleSearchField) {
                    Label("æœå°‹", systemImage: showSearchField ? "magnifyingglass.circle.fill" : "magnifyingglass")
                }
                .customCursor(.pointingHand)
                .help("æœå°‹æ—¥è¨˜å…§å®¹")
            }
            
            ToolbarItem(placement: .automatic) {
                Button(action: {
                    switchToToday()
                }) {
                    Label("ä»Šæ—¥", systemImage: "calendar.badge.clock")
                }
                .customCursor(.pointingHand)
                .help("åˆ‡æ›åˆ°ä»Šå¤©çš„æ—¥è¨˜")
            }
            
            ToolbarItem(placement: .automatic) {
                Menu {
                    Button(action: {
                        isExporting = true
                        showingDateRangeSheet = true
                    }) {
                        Label("åŒ¯å‡ºå‚™ä»½", systemImage: "square.and.arrow.up")
                    }
                    .customCursor(.pointingHand)
                    .help("åŒ¯å‡ºæ—¥è¨˜æ•¸æ“š")
                    
                    Button(action: {
                        isExporting = false
                        showingDateRangeSheet = true
                    }) {
                        Label("åŒ¯å…¥å‚™ä»½", systemImage: "square.and.arrow.down")
                    }
                    .customCursor(.pointingHand)
                    .help("åŒ¯å…¥æ—¥è¨˜æ•¸æ“š")
                    
                    Divider()
                    
                    Button(action: {
                        showingPreferencesSheet = true
                    }) {
                        Label("åå¥½è¨­ç½®", systemImage: "gear")
                    }
                    .customCursor(.pointingHand)
                    .help("è¨­ç½®æ‡‰ç”¨ç¨‹åºåå¥½")
                    
                    Button(action: {
                        showingHelpSheet = true
                    }) {
                        Label("ä½¿ç”¨èªªæ˜", systemImage: "questionmark.circle")
                    }
                    .customCursor(.pointingHand)
                    .help("æŸ¥çœ‹ä½¿ç”¨èªªæ˜")
                } label: {
                    Image(systemName: "ellipsis.circle")
                }
                .customCursor(.pointingHand)
                .help("æ›´å¤šé¸é …")
            }
            
            ToolbarItem(placement: .primaryAction) {
                Button(action: { showingNewDiarySheet = true }) {
                    Image(systemName: "plus")
                }
                .customCursor(.pointingHand)
                .help("æ–°å¢æ—¥è¨˜")
            }
        }
    }
}
