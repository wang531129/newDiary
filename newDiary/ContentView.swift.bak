//
//  ContentView.swift
//  newDiary
//
//  Created by WangPuma on 2025/3/18.
//

/*
 é‡æ§‹å»ºè­°:
 1. ValueTransformer é¡åˆ¥ (WeatherTypeTransformer, CategoryTypeTransformer) å¯èƒ½ä¸éœ€è¦ï¼Œå› ç‚º SwiftData å·²èƒ½è™•ç† enum çš„ç·¨ç¢¼è§£ç¢¼
 2. MainDiaryForm çµæ§‹é«”èˆ‡ NewDiaryView åŠŸèƒ½é‡è¤‡ï¼Œå¯ä»¥åˆªé™¤å…¶ä¸­ä¸€å€‹
 3. åµŒå¥—çš„ Form/Section çµæ§‹éå¤šï¼Œç‰¹åˆ¥æ˜¯åœ¨ WeatherAndThoughtsView åŠå…¶å­è¦–åœ–ä¸­ï¼Œå¯ä»¥ç°¡åŒ–å±¤æ¬¡
 4. @AppStorage è®Šæ•¸åœ¨å¤šå€‹è¦–åœ–ä¸­é‡è¤‡å®£å‘Šï¼Œå»ºè­°å‰µå»ºä¸€å€‹å…±äº«çš„è¨­å®šç’°å¢ƒç‰©ä»¶
 5. å¤šé¤˜çš„ padding å’Œä¸å¿…è¦çš„å®¹å™¨åµŒå¥—å¯ä»¥ç²¾ç°¡
 */

import SwiftUI
import SwiftData
import AppKit
import Foundation
import WeatherKit
import Charts
import MapKit
import UniformTypeIdentifiers
import EventKit
import ReminderView

// MARK: - å¤©æ°£é¡å‹å®šç¾©
/// å®šç¾©æ‰€æœ‰å¯ç”¨çš„å¤©æ°£é¡å‹
enum WeatherType: String, Codable, CaseIterable {
    case sunny = "æ™´å¤©"
    case cloudy = "å¤šé›²"
    case rainy = "ä¸‹é›¨"
    case storm = "æš´é›¨"
    case windy = "åˆ®é¢¨"
    case foggy = "éœ§å¤©"
    case snow = "ä¸‹é›ª"
    
    /// æ¯ç¨®å¤©æ°£å°æ‡‰çš„ SF Symbols åœ–æ¨™åç¨±
    var icon: String {
        switch self {
        case .sunny: return "sun.max.fill"      // å¤ªé™½åœ–æ¨™
        case .cloudy: return "cloud.fill"       // é›²æœµåœ–æ¨™
        case .rainy: return "cloud.rain.fill"   // ä¸‹é›¨åœ–æ¨™
        case .storm: return "cloud.bolt.rain.fill" // æš´é›¨åœ–æ¨™
        case .windy: return "wind"              // é¢¨åœ–æ¨™
        case .foggy: return "cloud.fog.fill"    // éœ§å¤©åœ–æ¨™
        case .snow: return "snow"               // ä¸‹é›ªåœ–æ¨™
        }
    }
}

// MARK: - åˆ†é¡é¡å‹å®šç¾©
/// å®šç¾©æ‰€æœ‰å¯ç”¨çš„è¨˜éŒ„åˆ†é¡
enum DiaryEntryType: String, Codable, CaseIterable {
    case expense = "æ”¯å‡º"
    case exercise = "é‹å‹•"
    case sleep = "ç¡çœ "
    case work = "å·¥ä½œ"
    case relationship = "é—œä¿‚"
    case study = "å­¸ç¿’"
    
    /// æ¯ç¨®åˆ†é¡å°æ‡‰çš„ SF Symbols åœ–æ¨™åç¨±
    var icon: String {
        switch self {
        case .expense: return "dollarsign.circle.fill"    // é‡‘éŒ¢åœ–æ¨™
        case .exercise: return "figure.run.circle.fill"   // é‹å‹•åœ–æ¨™
        case .sleep: return "bed.double.circle.fill"      // ç¡çœ åœ–æ¨™
        case .work: return "briefcase.circle.fill"        // å·¥ä½œåœ–æ¨™
        case .relationship: return "person.2.circle.fill"  // é—œä¿‚åœ–æ¨™
        case .study: return "book.circle.fill"            // å­¸ç¿’åœ–æ¨™
        }
    }
    
    /// æ¯ç¨®åˆ†é¡çš„é å®šç¾©é¸é …
    var categories: [String] {
        switch self {
        case .expense:
            return ["é£²é£Ÿ(æ—©)", "é£²é£Ÿ(ä¸­)", "é£²é£Ÿ(æ™š)", "å®¶åº­ç”¨å“", "å€‹äººç”¨å“", 
                   "ç¨…é‡‘", "æ°´é›»ç“¦æ–¯è²»", "è´ˆäºˆ", "ç´…ç™½åŒ…", "äº¤é€šè²»"]
        case .exercise:
            return ["è‚©", "èƒŒ", "èƒ¸", "è…¿", "æ‰‹", "æ ¸å¿ƒ"]
        case .work:
            return ["èŒæª¢", "å„€æ ¡", "ä»£å·¥", "å”åŠ©", "è¡›ç”Ÿæª¢æŸ¥", "æ•™è‚²è¨“ç·´"]
        case .relationship:
            return ["è¦–è¨Š", "çŸ­ä¿¡", "æœƒé¢", "èšé¤", "æ¢è¦–"]
        case .study:
            return ["æ›¸ç±", "é›»åª’", "èªè¨€", "å¥èº«", "ä¿®é¤Š"]
        case .sleep:
            return []
        }
    }
}

// MARK: - å¤©æ°£ API ç›¸é—œçµæ§‹
/// OpenWeatherMap API è¿”å›æ•¸æ“šçš„çµæ§‹å®šç¾©
struct WeatherResponse: Codable {
    let main: MainWeather    // ä¸»è¦å¤©æ°£æ•¸æ“šï¼ˆæº«åº¦ç­‰ï¼‰
    let weather: [Weather]   // å¤©æ°£ç‹€æ³æè¿°
    
    struct MainWeather: Codable {
        let temp: Double     // ç•¶å‰æº«åº¦
        let temp_min: Double // æœ€ä½æº«åº¦
        let temp_max: Double // æœ€é«˜æº«åº¦
    }
    
    struct Weather: Codable {
        let main: String        // ä¸»è¦å¤©æ°£ç‹€æ³
        let description: String // å¤©æ°£æè¿°
    }
}

/// å¤©æ°£æœå‹™é¡ï¼Œè™•ç†èˆ‡ OpenWeatherMap API çš„äº¤äº’
class WeatherService: NSObject, CLLocationManagerDelegate {
    private let apiKey: String        // API å¯†é‘°
    private let locationManager = CLLocationManager()
    private var locationCompletion: ((Result<CLLocation, Error>) -> Void)?
    
    init(apiKey: String) {
        self.apiKey = apiKey
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters
    }
    
    /// è«‹æ±‚ä½ç½®æ¬Šé™ä¸¦ç²å–ä½ç½®
    private func requestLocation() async throws -> CLLocation {
        // æª¢æŸ¥ä½ç½®æœå‹™æ˜¯å¦å¯ç”¨
        guard CLLocationManager.locationServicesEnabled() else {
            throw NSError(domain: "WeatherService", code: 1, userInfo: [NSLocalizedDescriptionKey: "ä½ç½®æœå‹™æœªå•Ÿç”¨"])
        }
        
        return try await withCheckedThrowingContinuation { continuation in
            locationCompletion = { result in
                switch result {
                case .success(let location):
                    continuation.resume(returning: location)
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }
            
            // æ ¹æ“šæˆæ¬Šç‹€æ…‹è«‹æ±‚ä½ç½®
            let status = locationManager.authorizationStatus
            switch status {
            case .authorizedWhenInUse, .authorizedAlways:
                locationManager.requestLocation()
            case .notDetermined:
                locationManager.requestWhenInUseAuthorization()
            case .denied, .restricted:
                continuation.resume(throwing: NSError(domain: "WeatherService", code: 2, userInfo: [NSLocalizedDescriptionKey: "è«‹åœ¨ç³»çµ±è¨­å®šä¸­å…è¨±æ‡‰ç”¨ç¨‹åºä½¿ç”¨ä½ç½®æœå‹™"]))
            @unknown default:
                continuation.resume(throwing: NSError(domain: "WeatherService", code: 2, userInfo: [NSLocalizedDescriptionKey: "æœªçŸ¥çš„æˆæ¬Šç‹€æ…‹"]))
            }
        }
    }
    
    // CLLocationManagerDelegate æ–¹æ³•
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        if let location = locations.first {
            locationCompletion?(.success(location))
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        locationCompletion?(.failure(error))
    }
    
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        switch status {
        case .authorizedWhenInUse, .authorizedAlways:
            locationManager.requestLocation()
        case .denied, .restricted:
            locationCompletion?(.failure(NSError(domain: "WeatherService", code: 2, userInfo: [NSLocalizedDescriptionKey: "ä½ç½®æ¬Šé™æœªæˆäºˆ"])))
        case .notDetermined:
            locationManager.requestWhenInUseAuthorization()
        @unknown default:
            locationCompletion?(.failure(NSError(domain: "WeatherService", code: 2, userInfo: [NSLocalizedDescriptionKey: "æœªçŸ¥çš„æˆæ¬Šç‹€æ…‹"])))
        }
    }
    
    /// å¾ API ç²å–å¤©æ°£æ•¸æ“š
    func fetchWeather() async throws -> (WeatherType, String) {
        // ç²å–ç•¶å‰ä½ç½®
        let location = try await requestLocation()
        
        // æ§‹å»º API è«‹æ±‚ URLï¼ˆä½¿ç”¨ç¶“ç·¯åº¦ï¼‰
        let urlString = "https://api.openweathermap.org/data/2.5/weather?lat=\(location.coordinate.latitude)&lon=\(location.coordinate.longitude)&appid=\(apiKey)&units=metric&lang=zh_tw"
        guard let url = URL(string: urlString) else {
            throw URLError(.badURL)
        }
        
        // ç™¼é€è«‹æ±‚ä¸¦ç²å–æ•¸æ“š
        let (data, httpResponse) = try await URLSession.shared.data(from: url)
        
        // æ‰“å° API éŸ¿æ‡‰ç‹€æ…‹å’Œæ•¸æ“šï¼ˆç”¨æ–¼èª¿è©¦ï¼‰
        if let httpResponse = httpResponse as? HTTPURLResponse {
            print("HTTP Status Code: \(httpResponse.statusCode)")
        }
        if let jsonString = String(data: data, encoding: .utf8) {
            print("API Response: \(jsonString)")
        }
        
        // è§£æ API è¿”å›çš„æ•¸æ“š
        let weatherResponse = try JSONDecoder().decode(WeatherResponse.self, from: data)
        
        // å°‡ API è¿”å›çš„å¤©æ°£é¡å‹è½‰æ›ç‚ºæ‡‰ç”¨å…§çš„å¤©æ°£é¡å‹
        let weatherType = self.convertToWeatherType(weatherResponse.weather.first?.main ?? "")
        
        // ä½¿ç”¨åœ°ç†ç·¨ç¢¼å™¨ç²å–åœ°é»åç¨±
        let geocoder = CLGeocoder()
        let placemarks = try await geocoder.reverseGeocodeLocation(location)
        let locationName = placemarks.first?.locality ?? "ç•¶å‰ä½ç½®"
        
        // æ ¼å¼åŒ–æº«åº¦é¡¯ç¤ºå­—ç¬¦ä¸²
        let minTemp = Int(round(weatherResponse.main.temp_min))
        let maxTemp = Int(round(weatherResponse.main.temp_max))
        let currentTemp = Int(round(weatherResponse.main.temp))
        
        // è¼¸å‡ºèª¿è©¦ä¿¡æ¯
        print("å¤©æ°£æ•¸æ“š: ç•¶å‰æº«åº¦=\(currentTemp)Â°C, æœ€ä½=\(minTemp)Â°C, æœ€é«˜=\(maxTemp)Â°C")
        
        // æ ¹æ“šOpenWeatherMap APIæ–‡æª”ï¼Œcurrent weather APIä¸­çš„temp_minå’Œtemp_maxé€šå¸¸èˆ‡tempç›¸åŒï¼Œ
        // ä¸¦ä¸ä»£è¡¨ä¸€å¤©çš„æœ€é«˜/æœ€ä½æº«åº¦ï¼Œå› æ­¤é¡¯ç¤ºç•¶å‰æº«åº¦æ›´åˆé©
        let temperatureString = "\(locationName) \(currentTemp)Â°C \(weatherResponse.weather.first?.description ?? "")"
        
        // è¼¸å‡ºæœ€çµ‚çš„æº«åº¦å­—ç¬¦ä¸²
        print("é¡¯ç¤ºçš„æº«åº¦å­—ç¬¦ä¸²: \(temperatureString)")
        
        return (weatherType, temperatureString)
    }
    
    /// å°‡ OpenWeatherMap çš„å¤©æ°£é¡å‹è½‰æ›ç‚ºæ‡‰ç”¨å…§çš„å¤©æ°£é¡å‹
    private func convertToWeatherType(_ openWeatherMain: String) -> WeatherType {
        switch openWeatherMain.lowercased() {
        case "clear": return .sunny
        case "clouds": return .cloudy
        case "rain": return .rainy
        case "thunderstorm": return .storm
        case "snow": return .snow
        case "mist", "fog": return .foggy
        default: return .sunny
        }
    }
}

// MARK: - ä¸»è¦æ•¸æ“šæ¨¡å‹
/// æ—¥èªŒæ¢ç›®æ¨¡å‹
@Model
final class DiaryEntry {
    @Attribute(.unique) var id: UUID  // å”¯ä¸€æ¨™è­˜ç¬¦
    var date: Date                    // æ—¥æœŸ
    var weatherRaw: String            // å¤©æ°£ï¼ˆåŸå§‹å­—ç¬¦ä¸²ï¼‰
    var thoughts: String              // è¨˜äº‹
    var temperature: String = ""      // æº«åº¦è³‡è¨Š
    
    /// å¤©æ°£é¡å‹çš„è¨ˆç®—å±¬æ€§
    var weather: WeatherType {
        get { WeatherType(rawValue: weatherRaw) ?? .sunny }
        set { weatherRaw = newValue.rawValue }
    }
    
    // å„ç¨®åˆ†é¡çš„æ¢ç›®é›†åˆ
    @Relationship(deleteRule: .cascade) var expenses: [CategoryEntry] = []      // æ”¯å‡ºè¨˜éŒ„
    @Relationship(deleteRule: .cascade) var exercises: [CategoryEntry] = []     // é‹å‹•è¨˜éŒ„
    @Relationship(deleteRule: .cascade) var sleeps: [CategoryEntry] = []        // ç¡çœ è¨˜éŒ„
    @Relationship(deleteRule: .cascade) var works: [CategoryEntry] = []         // å·¥ä½œè¨˜éŒ„
    @Relationship(deleteRule: .cascade) var relationships: [CategoryEntry] = [] // é—œä¿‚è¨˜éŒ„
    @Relationship(deleteRule: .cascade) var studies: [CategoryEntry] = []       // å­¸ç¿’è¨˜éŒ„
    
    /// åˆå§‹åŒ–æ–¹æ³•
    init(date: Date = Date(), weather: WeatherType = .sunny, thoughts: String = "", temperature: String = "") {
        self.id = UUID()
        self.date = date
        self.weatherRaw = weather.rawValue
        self.thoughts = thoughts
        self.temperature = temperature
    }
}

// MARK: - åˆ†é¡æ¢ç›®æ¨¡å‹
/// åˆ†é¡è¨˜éŒ„æ¢ç›®æ¨¡å‹
@Model
final class CategoryEntry {
    @Attribute(.unique) var id: UUID  // å”¯ä¸€æ¨™è­˜ç¬¦
    var typeRaw: String               // åˆ†é¡é¡å‹ï¼ˆåŸå§‹å­—ç¬¦ä¸²ï¼‰
    var name: String                  // åç¨±/å“è³ª/å§“å
    var category: String              // é¡åˆ¥/æ™‚é–“
    var number: Double                // é‡‘é¡/çµ„æ•¸/é†’ä¾†æ¬¡æ•¸/æ™‚é•·
    var notes: String                 // å‚™æ³¨
    
    /// åˆ†é¡é¡å‹çš„è¨ˆç®—å±¬æ€§
    var type: DiaryEntryType {
        get { DiaryEntryType(rawValue: typeRaw) ?? .expense }
        set { typeRaw = newValue.rawValue }
    }
    
    /// åˆå§‹åŒ–æ–¹æ³•
    init(type: DiaryEntryType, name: String = "", category: String = "", number: Double = 0.0, notes: String = "") {
        self.id = UUID()
        self.typeRaw = type.rawValue
        self.name = name
        self.category = category
        self.number = number
        self.notes = notes
    }
}

// MARK: - WeatherTypeTransformerå¯èƒ½é‡å¤ä¸å¿…è¦çš„è½¬æ¢å™¨

// WeatherType è½¬æ¢å™¨
class WeatherTypeTransformer: ValueTransformer {
    static let shared = WeatherTypeTransformer()
    
    override class func transformedValueClass() -> AnyClass {
        return NSString.self
    }
    
    override class func allowsReverseTransformation() -> Bool {
        return true
    }
    
    override func transformedValue(_ value: Any?) -> Any? {
        return "Deprecated"
    }
    
    override func reverseTransformedValue(_ value: Any?) -> Any? {
        return nil
    }
}

// æ³¨å†Œ WeatherType è½¬æ¢å™¨
extension WeatherTypeTransformer {
    static func register() {
        // Deprecated
    }
}

// MARK: - ä¸»è¡¨å–®è¦–åœ–èˆ‡ NewDiaryView åŠŸèƒ½é‡è¤‡
struct MainDiaryForm: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var modelContext
    @State private var date = Date()
    @State private var selectedWeather = WeatherType.sunny.rawValue
    @State private var thoughts = ""
    
    // æ·»åŠ å­—ä½“é¢œè‰²è®¾ç½®
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    var body: some View {
        NavigationStack {
            Form {
                // ä½¿ç”¨è‡ªå®šä¹‰æ—¥æœŸé€‰æ‹©å™¨
                HStack {
                    Text("æ—¥æœŸ")
                        .font(.system(size: 20))
                    Spacer()
                    CustomDatePickerView(
                        selectedDate: $date,
                        titleFontColor: titleFontColor,
                        contentFontColor: contentFontColor
                    )
                    .help("é¸æ“‡è¦æŸ¥çœ‹çš„æ—¥æœŸ")
                }
                .padding(.vertical, 5)
                
                Section("å¤©æ°£") {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 15) {
                            ForEach(WeatherType.allCases, id: \.self) { weather in
                                VStack {
                                    Image(systemName: weather.icon)
                                        .font(.system(size: 22))
                                        .foregroundColor(selectedWeather == weather.rawValue ? .blue : .gray)
                                        .padding(8)
                                        .background(
                                            Circle()
                                                .fill(selectedWeather == weather.rawValue ? Color.blue.opacity(0.2) : Color.clear)
                                        )
                                    Text(weather.rawValue)
                                        .font(.system(size: 20))
                                }
                                .onTapGesture {
                                    selectedWeather = weather.rawValue
                                }
                            }
                        }
                    }
                    .frame(height: 80)
                }
                
                Section(header: Text("è¨˜äº‹")) {
                    TextEditor(text: $thoughts)
                        .frame(height: 100)
                }
            }
            .navigationTitle("æ–°å¢æ—¥èªŒ")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("å–æ¶ˆ") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("ä¿å­˜") {
                        let newDiary = DiaryEntry(date: date, weather: WeatherType(rawValue: selectedWeather) ?? .sunny, thoughts: thoughts)
                        modelContext.insert(newDiary)
                        dismiss()
                    }
                }
            }
        }
    }
}

struct CategoryEntryForm: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var modelContext
    let type: DiaryEntryType
    let diary: DiaryEntry
    var editingEntry: CategoryEntry? = nil
    
    @State private var name = ""
    @State private var category = ""
    @State private var number: Double = 0
    @State private var numberString = "0"
    @State private var notes = ""
    @State private var showNumberError = false
    @State private var showingCategoryPicker = false
    @FocusState private var isCategoryFocused: Bool
    
    // æ–°å¢çš„ç‹€æ…‹è®Šæ•¸ï¼Œç”¨æ–¼è‡ªå‹•å®ŒæˆåŠŸèƒ½
    @State private var suggestions: [String] = []
    @State private var showingSuggestions = false
    @State private var selectedSuggestionIndex = 0
    @Query private var allDiaries: [DiaryEntry]
    
    init(type: DiaryEntryType, diary: DiaryEntry, editingEntry: CategoryEntry? = nil) {
        self.type = type
        self.diary = diary
        self.editingEntry = editingEntry
        
        let initialName = editingEntry?.name ?? ""
        let initialCategory = editingEntry?.category ?? ""
        let initialNumber = editingEntry?.number ?? 0
        let initialNotes = editingEntry?.notes ?? ""
        
        _name = State(initialValue: initialName)
        _category = State(initialValue: initialCategory)
        _number = State(initialValue: initialNumber)
        
        // å¦‚æœæ˜¯æ™‚é–“ç›¸é—œé …ç›®ï¼Œæ ¼å¼åŒ–ç‚ºh:mmæ ¼å¼
        if  editingEntry != nil,
           (type == .exercise || type == .sleep || type == .work || type == .relationship || type == .study) {
            _numberString = State(initialValue: formatMinutesToTimeString(Int(initialNumber)))
        } else {
            _numberString = State(initialValue: String(format: "%.0f", initialNumber))
        }
        
        _notes = State(initialValue: initialNotes)
    }
    
    private func validateAndUpdateNumber(_ newValue: String) {
        if let parsedNumber = Double(newValue.replacingOccurrences(of: ".", with: "")) {
            if parsedNumber >= 0 && parsedNumber <= 999999 {
                number = parsedNumber
                numberString = String(format: "%.0f", parsedNumber)
                showNumberError = false
            } else {
                showNumberError = true
            }
        } else {
            showNumberError = true
        }
    }
    
    // ç²å–ä»¥å‰è¼¸å…¥éçš„åç¨±åˆ—è¡¨
    private func getPreviousNames() -> [String] {
        var names = Set<String>()
        
        for diary in allDiaries {
            let entries: [CategoryEntry]
            switch type {
            case .expense:
                entries = diary.expenses
            case .exercise:
                entries = diary.exercises
            case .sleep:
                entries = diary.sleeps
            case .work:
                entries = diary.works
            case .relationship:
                entries = diary.relationships
            case .study:
                entries = diary.studies
            }
            
            for entry in entries {
                if !entry.name.isEmpty {
                    names.insert(entry.name)
                }
            }
        }
        
        return Array(names).sorted()
    }
    
    // æ ¹æ“šè¼¸å…¥ç”Ÿæˆå»ºè­°
    private func updateSuggestions() {
        if name.isEmpty {
            showingSuggestions = false
            return
        }
        
        let allNames = getPreviousNames()
        suggestions = allNames.filter { $0.localizedCaseInsensitiveContains(name) && $0 != name }
        
        showingSuggestions = !suggestions.isEmpty
        selectedSuggestionIndex = 0
    }
    
    // é¸æ“‡å»ºè­°
    private func selectSuggestion(_ suggestion: String) {
        name = suggestion
        showingSuggestions = false
    }
    
    // è™•ç†Tabéµè‡ªå‹•å®Œæˆ
    private func handleTabKey() {
        if showingSuggestions && !suggestions.isEmpty {
            name = suggestions[selectedSuggestionIndex]
            showingSuggestions = false
        }
    }
    
    var body: some View {
        NavigationStack {
            Form {
                NameSectionWithAutocomplete(
                    type: type,
                    name: $name,
                    suggestions: suggestions,
                    showingSuggestions: $showingSuggestions,
                    selectedSuggestionIndex: $selectedSuggestionIndex,
                    onNameChanged: updateSuggestions,
                    onSuggestionSelected: selectSuggestion,
                    onTabPressed: handleTabKey
                )
                CategorySection(type: type, category: $category)
                NumberSection(
                    type: type,
                    numberString: $numberString,
                    number: $number,
                    showNumberError: $showNumberError,
                    validateAndUpdateNumber: validateAndUpdateNumber
                )
                NotesSection(notes: $notes)
            }
            .formStyle(.grouped)
            .navigationTitle(editingEntry == nil ? "æ–°å¢\(type.rawValue)è¨˜éŒ„" : "ç·¨è¼¯\(type.rawValue)è¨˜éŒ„")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("å–æ¶ˆ") { dismiss() }
                        .font(.system(size: 20))
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("ä¿å­˜") {
                        if let editingEntry = editingEntry {
                            editingEntry.name = name
                            editingEntry.category = category
                            editingEntry.number = number
                            editingEntry.notes = notes
                        } else {
                            let entry = CategoryEntry(type: type, name: name, category: category, number: number, notes: notes)
                            switch type {
                            case .expense: diary.expenses.append(entry)
                            case .exercise: diary.exercises.append(entry)
                            case .sleep: diary.sleeps.append(entry)
                            case .work: diary.works.append(entry)
                            case .relationship: diary.relationships.append(entry)
                            case .study: diary.studies.append(entry)
                            }
                        }
                        try? modelContext.save()
                        dismiss()
                    }
                    .disabled(showNumberError)
                    .font(.system(size: 20))
                }
            }
            .onAppear {
                updateSuggestions()
            }
        }
        .frame(minWidth: 300, minHeight: 200)
    }
}

// MARK: - CategoryEntryForm Subviews
private struct NameSection: View {
    let type: DiaryEntryType
    @Binding var name: String
    
    var nameLabel: String {
        switch type {
        case .expense: return "åç¨±"
        case .exercise: return "åç¨±"
        case .sleep: return "å“è³ª"
        case .work: return "åç¨±"
        case .relationship: return "å§“å"
        case .study: return "åç¨±"
        }
    }
    
    var body: some View {
        Section {
            HStack {
                Image(systemName: type.icon)
                    .foregroundColor(.blue)
                    .font(.system(size: 20))
                Text(nameLabel)
                    .foregroundColor(.secondary)
                    .font(.system(size: 20))
                Spacer()
                TextField("", text: $name)
                    .textFieldStyle(.plain)
                    .font(.system(size: 20))
                    .multilineTextAlignment(.trailing)
            }
        }
    }
}

private struct CategorySection: View {
    let type: DiaryEntryType
    @Binding var category: String
    @FocusState private var isCategoryFocused: Bool
    @State private var showingSuggestions = false
    @State private var suggestions: [String] = []
    @State private var selectedSuggestionIndex = 0
    @Query private var allDiaries: [DiaryEntry]
    
    // æ ¹æ®åˆ†ç±»ç±»å‹æ˜¾ç¤ºä¸åŒçš„æ ‡ç­¾æ–‡æœ¬
    var categoryLabel: String {
        switch type {
        case .expense: return "é¡åˆ¥"
        case .exercise: return "é‹å‹•é¡å‹"
        case .sleep: return "é†’ä¾†æ¬¡æ•¸"
        case .work: return "å·¥ä½œé¡å‹"
        case .relationship: return "é—œä¿‚é¡å‹"
        case .study: return "å­¸ç¿’é¡å‹"
        }
    }
    
    // ç²å–ä»¥å‰è¼¸å…¥éçš„é¡åˆ¥åˆ—è¡¨
    private func getPreviousCategories() -> [String] {
        var categories = Set<String>()
        
        // æ·»åŠ é å®šç¾©çš„é¡åˆ¥
        for category in type.categories {
            categories.insert(category)
        }
        
        // æ·»åŠ ä»¥å‰ä½¿ç”¨éçš„é¡åˆ¥
        for diary in allDiaries {
            let entries: [CategoryEntry]
            switch type {
            case .expense:
                entries = diary.expenses
            case .exercise:
                entries = diary.exercises
            case .sleep:
                entries = diary.sleeps
            case .work:
                entries = diary.works
            case .relationship:
                entries = diary.relationships
            case .study:
                entries = diary.studies
            }
            
            for entry in entries {
                if !entry.category.isEmpty {
                    categories.insert(entry.category)
                }
            }
        }
        
        return Array(categories).sorted()
    }
    
    // æ ¹æ“šè¼¸å…¥ç”Ÿæˆå»ºè­°
    private func updateSuggestions() {
        if category.isEmpty {
            showingSuggestions = false
            return
        }
        
        let allCategories = getPreviousCategories()
        suggestions = allCategories.filter { $0.localizedCaseInsensitiveContains(category) && $0 != category }
        
        showingSuggestions = !suggestions.isEmpty
        selectedSuggestionIndex = 0
    }
    
    // é¸æ“‡å»ºè­°
    private func selectSuggestion(_ suggestion: String) {
        category = suggestion
        showingSuggestions = false
    }
    
    // è™•ç†Tabéµè‡ªå‹•å®Œæˆ
    private func handleTabKey() {
        if showingSuggestions && !suggestions.isEmpty {
            category = suggestions[selectedSuggestionIndex]
            showingSuggestions = false
        }
    }
    
    var body: some View {
        Section {
            if type != .sleep {
                HStack {
                    Image(systemName: "tag.fill")
                        .foregroundColor(.blue)
                        .font(.system(size: 20))
                    Text(categoryLabel)
                        .foregroundColor(.secondary)
                        .font(.system(size: 20))
                    Spacer()
                    
                    // ç§»é™¤æ¡ä»¶åˆ¤æ–­ï¼Œå§‹ç»ˆæ˜¾ç¤ºè¾“å…¥æ¡†
                    VStack(alignment: .trailing, spacing: 0) {
                        HStack {
                            TextField("", text: $category)
                                .textFieldStyle(.plain)
                                .font(.system(size: 20))
                                .multilineTextAlignment(.trailing)
                                .focused($isCategoryFocused)
                                .onChange(of: category) { oldValue, newValue in
                                    updateSuggestions()
                                }
                                .onSubmit {
                                    showingSuggestions = false
                                }
                                .onKeyPress(.tab) {
                                    handleTabKey()
                                    return .handled
                                }
                                .help("è¼¸å…¥é¡åˆ¥ï¼ŒæŒ‰Tabå¯è‡ªå‹•å¡«å¯«")
                        }
                        
                        if showingSuggestions && isCategoryFocused {
                            ScrollView {
                                LazyVStack(alignment: .trailing, spacing: 8) {
                                    ForEach(Array(suggestions.enumerated()), id: \.element) { index, suggestion in
                                        Text(suggestion)
                                            .font(.system(size: 18))
                                            .padding(.vertical, 4)
                                            .padding(.horizontal, 8)
                                            .frame(maxWidth: .infinity, alignment: .trailing)
                                            .background(index == selectedSuggestionIndex ? Color.blue.opacity(0.2) : Color.clear)
                                            .cornerRadius(4)
                                            .contentShape(Rectangle())
                                            .onTapGesture {
                                                selectSuggestion(suggestion)
                                            }
                                            .onHover { isHovered in
                                                if isHovered {
                                                    selectedSuggestionIndex = index
                                                }
                                            }
                                            .customCursor(.pointingHand)
                                    }
                                }
                            }
                            .frame(maxHeight: 150)
                            .background(Color(NSColor.windowBackgroundColor))
                            .overlay(
                                RoundedRectangle(cornerRadius: 5)
                                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                            )
                            .padding(.top, 4)
                        }
                    }
                    
                    // æ³¨é‡Šæ‰ä¸‹æ‹‰èœå•éƒ¨åˆ†
                    /*
                    } else {
                        Menu {
                            ForEach(type.predefinedCategories, id: \.self) { predefinedCategory in
                                Button(predefinedCategory) {
                                    category = predefinedCategory
                                }
                                .font(.system(size: 20))
                            }
                            
                            Divider()
                            
                            Button("è‡ªå®šç¾©...") {
                                isCustomizing = true
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                    isCategoryFocused = true
                                    updateSuggestions()
                                }
                            }
                        } label: {
                            Text(category.isEmpty ? "é¸æ“‡é¡åˆ¥" : category)
                                .foregroundColor(category.isEmpty ? .secondary : .primary)
                                .font(.system(size: 20))
                            Image(systemName: "chevron.down")
                                .font(.system(size: 16))
                                .foregroundColor(.secondary)
                        }
                        .menuStyle(.borderlessButton)
                        .customCursor(.pointingHand)
                        .help("é¸æ“‡æˆ–è‡ªå®šç¾©é¡åˆ¥")
                    }
                    */
                }
            } else {
                HStack {
                    Image(systemName: "tag.fill")
                        .foregroundColor(.blue)
                        .font(.system(size: 20))
                    Text(categoryLabel)
                        .foregroundColor(.secondary)
                        .font(.system(size: 20))
                    Spacer()
                    TextField("", text: $category)
                        .textFieldStyle(.plain)
                        .font(.system(size: 20))
                        .multilineTextAlignment(.trailing)
                        .focused($isCategoryFocused)
                        .onChange(of: category) { oldValue, newValue in
                            updateSuggestions()
                        }
                        .onSubmit {
                            showingSuggestions = false
                        }
                        .onKeyPress(.tab) {
                            handleTabKey()
                            return .handled
                        }
                        .help("è¼¸å…¥é†’ä¾†æ¬¡æ•¸ï¼ŒæŒ‰Tabå¯è‡ªå‹•å¡«å¯«")
                }
                
                if showingSuggestions && isCategoryFocused {
                    ScrollView {
                        LazyVStack(alignment: .trailing, spacing: 8) {
                            ForEach(Array(suggestions.enumerated()), id: \.element) { index, suggestion in
                                Text(suggestion)
                                    .font(.system(size: 18))
                                    .padding(.vertical, 4)
                                    .padding(.horizontal, 8)
                                    .frame(maxWidth: .infinity, alignment: .trailing)
                                    .background(index == selectedSuggestionIndex ? Color.blue.opacity(0.2) : Color.clear)
                                    .cornerRadius(4)
                                    .contentShape(Rectangle())
                                    .onTapGesture {
                                        selectSuggestion(suggestion)
                                    }
                                    .onHover { isHovered in
                                        if isHovered {
                                            selectedSuggestionIndex = index
                                        }
                                    }
                                    .customCursor(.pointingHand)
                            }
                        }
                    }
                    .frame(maxHeight: 150)
                    .background(Color(NSColor.windowBackgroundColor))
                    .overlay(
                        RoundedRectangle(cornerRadius: 5)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
                    .padding(.top, 4)
                }
            }
        }
    }
}

private struct NumberSection: View {
    let type: DiaryEntryType
    @Binding var numberString: String
    @Binding var number: Double
    @Binding var showNumberError: Bool
    let validateAndUpdateNumber: (String) -> Void
    
    var numberLabel: String {
        switch type {
        case .expense: return "é‡‘é¡"
        case .exercise: return "æ™‚é–“"
        case .sleep: return "æ™‚é–“"
        case .work: return "æ™‚é•·"
        case .relationship: return "æ™‚é•·"
        case .study: return "æ™‚é•·"
        }
    }
    
    var body: some View {
        Section {
            VStack(alignment: .leading, spacing: 8) {
                HStack {
                    Image(systemName: "number.circle.fill")
                        .foregroundColor(.blue)
                        .font(.system(size: 20))
                    Text(numberLabel)
                        .foregroundColor(.secondary)
                        .font(.system(size: 20))
                    Spacer()
                    TextField(
                        "è¼¸å…¥\(numberLabel)\(type == .exercise || type == .sleep || type == .work || type == .relationship || type == .study ? "ï¼ˆh:mmæˆ–åˆ†é˜ï¼‰" : "")",
                        text: $numberString
                    )
                    .font(.system(size: 14))
                    .onChange(of: numberString) { oldValue, newValue in
                        if type == .exercise || type == .sleep || type == .work || type == .relationship || type == .study {
                            // å¦‚æœæ˜¯æ™‚é–“ç›¸é—œæ¢ç›®ï¼Œå…è¨±h:mmæ ¼å¼
                            if newValue.contains(":") {
                                processTimeFormat(newValue)
                            } else {
                                // ç´”æ•¸å­—è¼¸å…¥æ™‚ï¼Œåƒ…å…è¨±æ•¸å­—
                                let filtered = newValue.filter { "0123456789".contains($0) }
                                if filtered != newValue {
                                    numberString = filtered
                                }
                                validateAndUpdateNumber(filtered)
                            }
                        } else {
                            // å…¶ä»–é¡å‹ï¼ˆå¦‚é‡‘é¡ï¼‰åªæ¥å—æ•¸å­—
                            let filtered = newValue.filter { "0123456789".contains($0) }
                            if filtered != newValue {
                                numberString = filtered
                            }
                            validateAndUpdateNumber(filtered)
                        }
                    }
                    .font(.system(size: 20))
                    
                    Stepper("", value: $number, in: 0...9999, step: 1) { _ in
                        if type == .exercise || type == .sleep || type == .work || type == .relationship || type == .study {
                            // æ™‚é–“ç›¸é—œæ¢ç›®é¡¯ç¤ºç‚ºh:mm
                            numberString = formatMinutesToTimeString(Int(number))
                        } else {
                            numberString = String(format: "%.0f", number)
                        }
                    }
                }
                
                if showNumberError {
                    Text("è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å€¼æˆ–æ™‚é–“æ ¼å¼")
                        .foregroundColor(.red)
                        .font(.system(size: 20))
                }
            }
        }
    }
    
    // è™•ç†h:mmæ ¼å¼çš„æ™‚é–“è¼¸å…¥
    private func processTimeFormat(_ input: String) {
        // åˆ†å‰²å°æ™‚å’Œåˆ†é˜
        let components = input.split(separator: ":")
        
        if components.count == 2,
           let hours = Int(components[0]),
           let minutes = Int(components[1]),
           hours >= 0 && hours <= 99,
           minutes >= 0 && minutes <= 59 {
            
            // è¨ˆç®—ç¸½åˆ†é˜æ•¸
            let totalMinutes = hours * 60 + minutes
            
            if totalMinutes <= 9999 {
                number = Double(totalMinutes)
                numberString = input  // ä¿æŒh:mmæ ¼å¼
                showNumberError = false
            } else {
                showNumberError = true
            }
        } else {
            showNumberError = true
        }
    }
}

// å°‡åˆ†é˜æ•¸æ ¼å¼åŒ–ç‚ºh:mmæ ¼å¼
func formatMinutesToTimeString(_ minutes: Int) -> String {
    let hours = minutes / 60
    let mins = minutes % 60
    return String(format: "%d:%02d", hours, mins)
}

private struct NotesSection: View {
    @Binding var notes: String
    
    var body: some View {
        Section {
            VStack(alignment: .leading) {
                HStack {
                    Image(systemName: "text.bubble.fill")
                        .foregroundColor(.blue)
                        .font(.system(size: 20))
                    Text("å‚™æ³¨")
                        .foregroundColor(.secondary)
                        .font(.system(size: 20))
                }
                
                TextEditor(text: $notes)
                    .font(.system(size: 16))
                    .frame(height: 100)
                    .cornerRadius(4)
            }
            .padding(.vertical, 4)
        }
    }
}

struct CategoryTableView: View {
    let type: DiaryEntryType
    let entries: [CategoryEntry]
    let diary: DiaryEntry
    let onAdd: () -> Void
    let onDelete: (IndexSet) -> Void
    let onEdit: (CategoryEntry) -> Void
    
    // âš ï¸ é€™è£¡çš„ @AppStorage å®£å‘Šèˆ‡å…¶ä»–è¦–åœ–é‡è¤‡ï¼Œè€ƒæ…®å‰µå»ºä¸€å€‹å…±äº«è¨­å®šç‰©ä»¶
    @AppStorage("titleFontSize") private var titleFontSize: Double = 22
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    // ç›®æ¨™åå¥½è¨­ç½®ä¹Ÿå¯ä»¥æ•´åˆåˆ°å…±äº«è¨­å®šç‰©ä»¶ä¸­
    @AppStorage("monthlyExpenseLimit") private var monthlyExpenseLimit: Double = 20000
    @AppStorage("dailyExerciseGoal") private var dailyExerciseGoal: Double = 60
    @AppStorage("dailySleepGoal") private var dailySleepGoal: Double = 390
    @AppStorage("dailyWorkGoal") private var dailyWorkGoal: Double = 120
    @AppStorage("dailyRelationshipGoal") private var dailyRelationshipGoal: Double = 30
    @AppStorage("dailyStudyGoal") private var dailyStudyGoal: Double = 60
    
    var total: Double {
        entries.reduce(0) { $0 + $1.number }
    }
    
    // è®¡ç®—æœˆåº¦åˆè®¡
    var monthlyTotal: Double {
        let calendar = Calendar.current
        let currentMonth = calendar.component(.month, from: diary.date)
        let currentYear = calendar.component(.year, from: diary.date)
        
        // è·å–æ‰€æœ‰æ—¥è®°æ¡ç›®
        let modelContext = diary.modelContext
        let descriptor = FetchDescriptor<DiaryEntry>()
        guard let allDiaries = try? modelContext?.fetch(descriptor) else { return 0 }
        
        // è¿‡æ»¤å‡ºåŒæœˆçš„æ—¥è®°æ¡ç›®
        let monthDiaries = allDiaries.filter { entry in
            let entryMonth = calendar.component(.month, from: entry.date)
            let entryYear = calendar.component(.year, from: entry.date)
            return entryMonth == currentMonth && entryYear == currentYear
        }
        
        // æ ¹æ®ç±»å‹è·å–å¹¶è®¡ç®—åˆè®¡
        let monthlyEntries = monthDiaries.flatMap { diary -> [CategoryEntry] in
            switch type {
            case .expense: return diary.expenses
            case .exercise: return diary.exercises
            case .sleep: return diary.sleeps
            case .work: return diary.works
            case .relationship: return diary.relationships
            case .study: return diary.studies
            }
        }
        
        return monthlyEntries.reduce(0) { $0 + $1.number }
    }
    
    var nameLabel: String {
        switch type {
        case .expense: return "åç¨±"
        case .exercise: return "åç¨±"
        case .sleep: return "å“è³ª"
        case .work: return "åç¨±"
        case .relationship: return "å§“å"
        case .study: return "åç¨±"
        }
    }
    
    var categoryLabel: String {
        switch type {
        case .expense: return "é¡åˆ¥"
        case .exercise: return "é‹å‹•é¡å‹"
        case .sleep: return "é†’ä¾†æ¬¡æ•¸"
        case .work: return "å·¥ä½œé¡å‹"
        case .relationship: return "é—œä¿‚é¡å‹"
        case .study: return "å­¸ç¿’é¡å‹"
        }
    }
    
    var numberLabel: String {
        switch type {
        case .expense: return "é‡‘é¡"
        case .exercise: return "æ™‚é–“"
        case .sleep: return "æ™‚é–“"
        case .work: return "æ™‚é•·"
        case .relationship: return "æ™‚é•·"
        case .study: return "æ™‚é•·"
        }
    }
    
    var body: some View {
        VStack(spacing: 16) {
            HStack {
                Label(type.rawValue, systemImage: type.icon)
                    .font(.system(size: titleFontSize))
                    .fontWeight(.bold)
                    .foregroundColor(Color.fromString(titleFontColor))
                Spacer()
                Button(action: onAdd) {
                    Label("æ–°å¢", systemImage: "plus.circle.fill")
                        .font(.system(size: contentFontSize))
                        .foregroundColor(.blue)
                }
                .buttonStyle(.plain)
            }
            
            Table(entries) {
                TableColumn(nameLabel) { entry in
                    Text(entry.name)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .font(.system(size: contentFontSize))
                        .foregroundColor(Color.fromString(contentFontColor))
                }
                TableColumn(categoryLabel) { entry in
                    Text(entry.category)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .font(.system(size: contentFontSize))
                        .foregroundColor(Color.fromString(contentFontColor))
                }
                TableColumn(numberLabel) { entry in
                    if type == .expense {
                        Text(String(format: "%.0f", entry.number))
                            .frame(maxWidth: .infinity, alignment: .trailing)
                            .font(.system(size: contentFontSize))
                            .monospacedDigit()
                            .foregroundColor(Color.fromString(contentFontColor))
                    } else {
                        // æ™‚é–“ç›¸é—œæ¢ç›®é¡¯ç¤ºç‚ºh:mm
                        Text(formatMinutesToTimeString(Int(entry.number)))
                            .frame(maxWidth: .infinity, alignment: .trailing)
                            .font(.system(size: contentFontSize))
                            .monospacedDigit()
                            .foregroundColor(Color.fromString(contentFontColor))
                    }
                }
                TableColumn("å‚™æ³¨") { entry in
                    Text(entry.notes)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .font(.system(size: contentFontSize))
                        .foregroundColor(.secondary)
                }
                TableColumn("æ“ä½œ") { entry in
                    HStack(spacing: 16) {
                        Button(action: { onEdit(entry) }) {
                            Image(systemName: "pencil.circle.fill")
                                .foregroundColor(.blue)
                                .font(.system(size: contentFontSize))
                        }
                        .buttonStyle(.plain)
                        
                        Button(action: {
                            if let index = entries.firstIndex(where: { $0.id == entry.id }) {
                                onDelete(IndexSet([index]))
                            }
                        }) {
                            Image(systemName: "trash.circle.fill")
                                .foregroundColor(.red)
                                .font(.system(size: contentFontSize))
                        }
                        .buttonStyle(.plain)
                    }
                    .frame(maxWidth: .infinity, alignment: .center)
                }
            }
            .frame(minHeight: 100)
            
            HStack {
                // æœˆåˆè®¡
                HStack {
                    Label("æœˆåˆè¨ˆ: ", systemImage: "calendar")
                    Group {
                        switch type {
                        case .expense:
                            // æ”¯å‡ºï¼šè¶…å‡ºæœˆæ”¯å‡ºä¸Šé™å‰‡é¡¯ç¤ºç´…è‰²å’ŒğŸ˜©è¡¨æƒ…ç¬¦è™Ÿï¼Œæœªè¶…å‡ºé¡¯ç¤ºç¶ è‰²å’ŒğŸ˜
                            let isOverLimit = monthlyTotal > monthlyExpenseLimit
                            Text(String(format: "%.0f", monthlyTotal))
                                .monospacedDigit()
                                .foregroundColor(isOverLimit ? .red : .green)
                            Text("\(isOverLimit ? "ğŸ¥µ" : "ğŸ˜") å…ƒ")
                        case .exercise, .sleep, .work, .relationship, .study:
                            Text(formatMinutesToTimeString(Int(monthlyTotal))).monospacedDigit()
                            Text(" (\(String(format: "%.0f", monthlyTotal))åˆ†é˜)")
                        }
                    }
                }
                .font(.system(size: contentFontSize))
                
                Spacer()
                
                // å°è®¡
                HStack {
                    Label("å°è¨ˆ: ", systemImage: "sum")
                    Group {
                        switch type {
                        case .expense:
                            Text(String(format: "%.0f", total)).monospacedDigit()
                            Text(" å…ƒ")
                        case .exercise:
                            // é‹å‹•ï¼šé”åˆ°æˆ–è¶…éæ¯æ—¥ç›®æ¨™é¡¯ç¤ºç¶ è‰²å’ŒğŸ˜ï¼Œæœªé”åˆ°é¡¯ç¤ºç´…è‰²å’ŒğŸ¥µ
                            let isGoalMet = total >= dailyExerciseGoal
                            Text(formatMinutesToTimeString(Int(total)))
                                .monospacedDigit()
                                .foregroundColor(isGoalMet ? .green : .red)
                            Text("\(isGoalMet ? "ğŸ˜" : "ğŸ¥µ") (\(String(format: "%.0f", total))åˆ†é˜)")
                        case .sleep:
                            // ç¡çœ ï¼šé”åˆ°æˆ–è¶…éæ¯æ—¥ç›®æ¨™é¡¯ç¤ºç¶ è‰²å’ŒğŸ˜ï¼Œæœªé”åˆ°é¡¯ç¤ºç´…è‰²å’ŒğŸ¥µ
                            let isGoalMet = total >= dailySleepGoal
                            Text(formatMinutesToTimeString(Int(total)))
                                .monospacedDigit()
                                .foregroundColor(isGoalMet ? .green : .red)
                            Text("\(isGoalMet ? "ğŸ˜" : "ğŸ¥µ") (\(String(format: "%.0f", total))åˆ†é˜)")
                        case .work:
                            // å·¥ä½œï¼šé”åˆ°æˆ–è¶…éæ¯æ—¥ç›®æ¨™é¡¯ç¤ºç¶ è‰²å’ŒğŸ˜ï¼Œæœªé”åˆ°é¡¯ç¤ºç´…è‰²å’ŒğŸ¥µ
                            let isGoalMet = total >= dailyWorkGoal
                            Text(formatMinutesToTimeString(Int(total)))
                                .monospacedDigit()
                                .foregroundColor(isGoalMet ? .green : .red)
                            Text("\(isGoalMet ? "ğŸ˜" : "ğŸ¥µ") (\(String(format: "%.0f", total))åˆ†é˜)")
                        case .relationship:
                            // é—œä¿‚ï¼šé”åˆ°æˆ–è¶…éæ¯æ—¥ç›®æ¨™é¡¯ç¤ºç¶ è‰²å’ŒğŸ˜ï¼Œæœªé”åˆ°é¡¯ç¤ºç´…è‰²å’ŒğŸ¥µ
                            let isGoalMet = total >= dailyRelationshipGoal
                            Text(formatMinutesToTimeString(Int(total)))
                                .monospacedDigit()
                                .foregroundColor(isGoalMet ? .green : .red)
                            Text("\(isGoalMet ? "ğŸ˜" : "ğŸ¥µ") (\(String(format: "%.0f", total))åˆ†é˜)")
                        case .study:
                            // å­¸ç¿’ï¼šé”åˆ°æˆ–è¶…éæ¯æ—¥ç›®æ¨™é¡¯ç¤ºç¶ è‰²å’ŒğŸ˜ï¼Œæœªé”åˆ°é¡¯ç¤ºç´…è‰²å’ŒğŸ¥µ
                            let isGoalMet = total >= dailyStudyGoal
                            Text(formatMinutesToTimeString(Int(total)))
                                .monospacedDigit()
                                .foregroundColor(isGoalMet ? .green : .red)
                            Text("\(isGoalMet ? "ğŸ˜" : "ğŸ¥µ") (\(String(format: "%.0f", total))åˆ†é˜)")
                        }
                    }
                }
                .font(.system(size: contentFontSize))
            }
            .padding(.top, 8)
        }
        .padding()
    }
}

// MARK: - å‚™ä»½æ•¸æ“šçµæ§‹
/// ç”¨æ–¼å‚™ä»½çš„æ•¸æ“šçµæ§‹
struct DiaryBackup: Codable {
    var entries: [DiaryBackupEntry]
    
    struct DiaryBackupEntry: Codable {
        var id: UUID
        var date: Date
        var weatherRaw: String
        var thoughts: String
        var temperature: String
        var expenses: [CategoryBackupEntry]
        var exercises: [CategoryBackupEntry]
        var sleeps: [CategoryBackupEntry]
        var works: [CategoryBackupEntry]
        var relationships: [CategoryBackupEntry]
        var studies: [CategoryBackupEntry]
    }
    
    struct CategoryBackupEntry: Codable {
        var id: UUID
        var typeRaw: String
        var name: String
        var category: String
        var number: Double
        var notes: String
    }
}

// MARK: - ä¸»è¦–åœ–
/// æ‡‰ç”¨ç¨‹åºçš„ä¸»è¦–åœ–ï¼ŒåŒ…å«æ—¥è¨˜åˆ—è¡¨å’Œè©³ç´°å…§å®¹
struct ContentView: View {
    @Environment(\.modelContext) private var modelContext
    @Query(sort: \DiaryEntry.date, order: .reverse) private var diaries: [DiaryEntry]
    
    @State private var searchText = ""
    @State private var showSearchField = false
    @State private var selectedDiary: DiaryEntry?
    @State private var selectedDate = Date()
    @State private var selectedTab: String? = "ä¸»é¡µ"
    @State private var isExporting = false
    @State private var startDate = Calendar.current.date(byAdding: .day, value: -7, to: Date()) ?? Date()
    @State private var endDate = Date()
    @State private var showingDateRangeSheet = false
    @State private var showingPreferencesSheet = false
    @State private var showingHelpSheet = false
    @State private var showingNewDiarySheet = false
    @State private var showingBackupSelectionSheet = false
    @State private var alertTitle = ""
    @State private var alertMessage = ""
    @State private var showingAlert = false
    
    // ç”¨æˆ¶åå¥½è¨­ç½®
    @AppStorage("titleFontSize") private var titleFontSize: Double = 22
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    // æœå°‹çµæœçµæ§‹
    struct SearchResult: Identifiable {
        let id = UUID()
        let diary: DiaryEntry
        let fieldName: String
        let matchText: String
        let matchLocation: String // æè¿°åŒ¹é…ä½ç½®ï¼Œå¦‚ "è¨˜äº‹" æˆ– "æ”¯å‡ºè¨˜éŒ„-åç¨±"
    }
    
    // æœå°‹åŠŸèƒ½
    @State private var searchResults: [SearchResult] = []
    @State private var currentResultIndex: Int = -1
    
    // åªåŸºäºæ—¥æœŸè¿‡æ»¤æ—¥è®°ï¼Œå¿½ç•¥æœç´¢æ–‡æœ¬
    private var filteredDiaries: [DiaryEntry] {
        let calendar = Calendar.current
        let startOfDay = calendar.startOfDay(for: selectedDate)
        let endOfDay = calendar.date(byAdding: .day, value: 1, to: startOfDay)!
        
        return diaries.filter { diary in
            diary.date >= startOfDay && diary.date < endOfDay
        }
    }
    
    // åŸ·è¡Œæœå°‹
    private func performSearch() {
        guard !searchText.isEmpty else {
            searchResults = []
            currentResultIndex = -1
            return
        }
        
        var results: [SearchResult] = []
        
        for diary in diaries {
            // æœå°‹æ—¥æœŸ
            let dateString = diary.date.formatted(date: .abbreviated, time: .omitted)
            if dateString.localizedCaseInsensitiveContains(searchText) {
                results.append(SearchResult(diary: diary, fieldName: "æ—¥æœŸ", matchText: dateString, matchLocation: "åŸºæœ¬ä¿¡æ¯"))
            }
            
            // æœå°‹å¤©æ°£
            let weatherString = diary.weather.rawValue
            if weatherString.localizedCaseInsensitiveContains(searchText) {
                results.append(SearchResult(diary: diary, fieldName: "å¤©æ°£", matchText: weatherString, matchLocation: "åŸºæœ¬ä¿¡æ¯"))
            }
            
            // æœå°‹æº«åº¦ä¿¡æ¯
            if diary.temperature.localizedCaseInsensitiveContains(searchText) {
                results.append(SearchResult(diary: diary, fieldName: "æº«åº¦", matchText: diary.temperature, matchLocation: "åŸºæœ¬ä¿¡æ¯"))
            }
            
            // æœå°‹è¨˜äº‹
            if diary.thoughts.localizedCaseInsensitiveContains(searchText) {
                results.append(SearchResult(diary: diary, fieldName: "è¨˜äº‹", matchText: diary.thoughts, matchLocation: "åŸºæœ¬ä¿¡æ¯"))
            }
            
            // æœå°‹æ”¯å‡ºè¨˜éŒ„
            for entry in diary.expenses {
                if searchEntryFields(entry, in: diary, categoryType: .expense, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
            
            // æœå°‹é‹å‹•è¨˜éŒ„
            for entry in diary.exercises {
                if searchEntryFields(entry, in: diary, categoryType: .exercise, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
            
            // æœå°‹ç¡çœ è¨˜éŒ„
            for entry in diary.sleeps {
                if searchEntryFields(entry, in: diary, categoryType: .sleep, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
            
            // æœå°‹å·¥ä½œè¨˜éŒ„
            for entry in diary.works {
                if searchEntryFields(entry, in: diary, categoryType: .work, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
            
            // æœå°‹é—œä¿‚è¨˜éŒ„
            for entry in diary.relationships {
                if searchEntryFields(entry, in: diary, categoryType: .relationship, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
            
            // æœå°‹å­¸ç¿’è¨˜éŒ„
            for entry in diary.studies {
                if searchEntryFields(entry, in: diary, categoryType: .study, results: &results) {
                    // åŒ¹é…å·²æ·»åŠ åˆ°ç»“æœä¸­
                }
            }
        }
        
        searchResults = results
        currentResultIndex = results.isEmpty ? -1 : 0
        
        // å¦‚æœæœ‰æœå°‹çµæœï¼Œå°èˆªåˆ°ç¬¬ä¸€å€‹çµæœ
        navigateToCurrentResult()
    }
    
    // æœå°‹å–®å€‹æ¢ç›®çš„å„å€‹å­—æ®µ
    private func searchEntryFields(_ entry: CategoryEntry, in diary: DiaryEntry, categoryType: DiaryEntryType, results: inout [SearchResult]) -> Bool {
        var foundMatch = false
        let categoryName = categoryType.rawValue
        
        // æœå°‹åç¨±å­—æ®µ
        if entry.name.localizedCaseInsensitiveContains(searchText) {
            results.append(SearchResult(
                diary: diary,
                fieldName: "åç¨±",
                matchText: entry.name,
                matchLocation: "\(categoryName)-\(entry.name)"
            ))
            foundMatch = true
        }
        
        // æœå°‹é¡åˆ¥å­—æ®µ
        if entry.category.localizedCaseInsensitiveContains(searchText) {
            results.append(SearchResult(
                diary: diary,
                fieldName: "é¡åˆ¥",
                matchText: entry.category,
                matchLocation: "\(categoryName)-\(entry.name)"
            ))
            foundMatch = true
        }
        
        // æœå°‹å‚™æ³¨å­—æ®µ
        if entry.notes.localizedCaseInsensitiveContains(searchText) {
            results.append(SearchResult(
                diary: diary,
                fieldName: "å‚™æ³¨",
                matchText: entry.notes,
                matchLocation: "\(categoryName)-\(entry.name)"
            ))
            foundMatch = true
        }
        
        // æœå°‹æ•¸å­—ï¼ˆè½‰ç‚ºå­—ç¬¦ä¸²å¾Œæœå°‹ï¼‰
        let numberString = String(format: "%.0f", entry.number)
        if numberString.localizedCaseInsensitiveContains(searchText) {
            results.append(SearchResult(
                diary: diary,
                fieldName: "æ•¸é‡",
                matchText: numberString,
                matchLocation: "\(categoryName)-\(entry.name)"
            ))
            foundMatch = true
        }
        
        return foundMatch
    }
    
    // å‘ä¸Šæœå°‹
    private func searchUp() {
        guard !searchResults.isEmpty else { return }
        
        if currentResultIndex > 0 {
            currentResultIndex -= 1
        } else {
            // å¾ªç’°å›åˆ°æœ€å¾Œä¸€å€‹çµæœ
            currentResultIndex = searchResults.count - 1
        }
        
        navigateToCurrentResult()
    }
    
    // å‘ä¸‹æœå°‹
    private func searchDown() {
        guard !searchResults.isEmpty else { return }
        
        if currentResultIndex < searchResults.count - 1 {
            currentResultIndex += 1
        } else {
            // å¾ªç’°å›åˆ°ç¬¬ä¸€å€‹çµæœ
            currentResultIndex = 0
        }
        
        navigateToCurrentResult()
    }
    
    // å°èˆªåˆ°ç•¶å‰æœå°‹çµæœ
    private func navigateToCurrentResult() {
        guard !searchResults.isEmpty && currentResultIndex >= 0 && currentResultIndex < searchResults.count else { return }
        
        let result = searchResults[currentResultIndex]
        selectedDiary = result.diary
        selectedDate = result.diary.date
        
        // æ ¹æ“šçµæœé¡å‹è¨­ç½®é©ç•¶çš„é¸é …å¡
        switch result.matchLocation.split(separator: "-").first?.trimmingCharacters(in: .whitespaces) {
        case "æ”¯å‡ºè¨˜éŒ„", "æ”¯å‡º":
            selectedTab = "æ”¯å‡º"
        case "é‹å‹•è¨˜éŒ„", "é‹å‹•":
            selectedTab = "é‹å‹•"
        case "ç¡çœ è¨˜éŒ„", "ç¡çœ ":
            selectedTab = "ç¡çœ "
        case "å·¥ä½œè¨˜éŒ„", "å·¥ä½œ":
            selectedTab = "å·¥ä½œ"
        case "é—œä¿‚è¨˜éŒ„", "é—œä¿‚":
            selectedTab = "é—œä¿‚"
        case "å­¸ç¿’è¨˜éŒ„", "å­¸ç¿’":
            selectedTab = "å­¸ç¿’"
        default:
            selectedTab = "ä¸»é¡µ"
        }
    }
    
    // åˆ‡æ›æœå°‹æ¬„ä½å¯è¦‹æ€§
    private func toggleSearchField() {
        showSearchField.toggle()
        if !showSearchField {
            searchText = ""
            searchResults = []
            currentResultIndex = -1
        }
    }

    var body: some View {
        NavigationSplitView {
            VStack {
                // æ—¥æœŸé¸æ“‡å™¨éƒ¨åˆ†
                HStack {
                    Text("é¸æ“‡æ—¥æœŸ")
                        .font(.system(size: titleFontSize))
                        .foregroundColor(Color.fromString(titleFontColor))
                    Spacer()
                    
                    // æ¢ä»¶é¡¯ç¤º"æ–°å¢"æŒ‰éˆ• - ç•¶è©²æ—¥æœŸæ²’æœ‰æ—¥è¨˜è¨˜éŒ„æ™‚é¡¯ç¤º
                    if filteredDiaries.isEmpty {
                        Button(action: {
                            createDiaryForSelectedDate()
                        }) {
                            HStack(spacing: 4) {
                                Image(systemName: "plus.circle.fill")
                                Text("æ–°å¢")
                            }
                            .foregroundColor(.blue)
                        }
                        .buttonStyle(.borderless)
                        .customCursor(.pointingHand)
                        .help("ç‚ºé¸æ“‡çš„æ—¥æœŸå‰µå»ºæ–°æ—¥è¨˜")
                        .padding(.trailing, 8)
                    }
                    
                    CustomDatePickerView(
                        selectedDate: $selectedDate,
                        titleFontColor: titleFontColor,
                        contentFontColor: contentFontColor,
                        selectedDiary: $selectedDiary
                    )
                    .help("é¸æ“‡è¦æŸ¥çœ‹çš„æ—¥æœŸ")
                }
                .padding(.horizontal)
                .padding(.top, 10)
                
                // æœå°‹æ¬„ä½ï¼ˆç•¶ showSearchField ç‚º true æ™‚é¡¯ç¤ºï¼‰
                if showSearchField {
                    VStack(spacing: 8) {
                        HStack {
                            Image(systemName: "magnifyingglass")
                                .foregroundColor(.secondary)
                            
                            TextField("æœå°‹æ—¥è¨˜å…§å®¹...", text: $searchText)
                                .textFieldStyle(.plain)
                                .onSubmit {
                                    performSearch()
                                }
                            
                            Button(action: {
                                searchText = ""
                                searchResults = []
                                currentResultIndex = -1
                            }) {
                                Image(systemName: "xmark.circle.fill")
                                    .foregroundColor(.gray)
                            }
                            .buttonStyle(.borderless)
                            .opacity(searchText.isEmpty ? 0 : 1)
                        }
                        .padding(8)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color(NSColor.textBackgroundColor))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                )
                        )
                        
                        HStack {
                            // é¡¯ç¤ºæœå°‹çµæœè¨ˆæ•¸
                            if !searchResults.isEmpty {
                                Text("æ‰¾åˆ° \(searchResults.count) å€‹çµæœ (ç•¶å‰: \(currentResultIndex + 1)/\(searchResults.count))")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            HStack(spacing: 8) {
                                Button(action: searchUp) {
                                    Image(systemName: "chevron.up")
                                        .frame(width: 24, height: 24)
                                }
                                .buttonStyle(.borderless)
                                .disabled(searchResults.isEmpty)
                                
                                Button(action: searchDown) {
                                    Image(systemName: "chevron.down")
                                        .frame(width: 24, height: 24)
                                }
                                .buttonStyle(.borderless)
                                .disabled(searchResults.isEmpty)
                                
                                Button(action: performSearch) {
                                    Text("æœå°‹")
                                        .font(.caption)
                                }
                                .disabled(searchText.isEmpty)
                                .buttonStyle(.borderedProminent)
                                .controlSize(.small)
                            }
                        }
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 4)
                }
                
                List(filteredDiaries) { diary in
                    DiaryRowView(diary: diary)
                        .onTapGesture {
                            selectedDiary = diary
                        }
                        .customCursor(.pointingHand)
                        .help("æŸ¥çœ‹æ—¥è¨˜è©³ç´°å…§å®¹")
                        .contextMenu {
                            Button(action: {
                                deleteEntry(diary)
                            }) {
                                Label("åˆªé™¤", systemImage: "trash")
                            }
                        }
                }
                .contextMenu {
                    Button(action: {
                        showingNewDiarySheet = true
                    }) {
                        Label("æ–°å¢æ—¥è¨˜", systemImage: "plus")
                    }
                    
                    Button(action: {
                        createDiaryForSelectedDate()
                    }) {
                        Label("æ–°å¢ä»Šæ—¥æ—¥è¨˜", systemImage: "calendar.badge.plus")
                    }
                }
            }
            .navigationTitle("æ—¥è¨˜åˆ—è¡¨")
            .modifier(ListToolbarModifier(
                toggleSearchField: toggleSearchField,
                showSearchField: showSearchField,
                switchToToday: switchToToday,
                isExporting: $isExporting,
                showingDateRangeSheet: $showingDateRangeSheet,
                showingPreferencesSheet: $showingPreferencesSheet,
                showingHelpSheet: $showingHelpSheet,
                showingNewDiarySheet: $showingNewDiarySheet,
                showingBackupSelectionSheet: $showingBackupSelectionSheet
            ))
            .searchable(text: $searchText, isPresented: $showSearchField, prompt: "æœå°‹æ—¥è¨˜...")
        } detail: {
            if let diary = selectedDiary {
                DiaryDetailView(diary: diary, selectedTab: $selectedTab)
            } else {
                Text("è«‹é¸æ“‡ä¸€ç¯‡æ—¥è¨˜")
                    .font(.title)
                    .foregroundColor(.secondary)
            }
        }
        .onChange(of: selectedDate) { oldDate, newDate in
            // ç•¶æ—¥æœŸè®Šæ›´æ™‚ï¼Œæ›´æ–° selectedDiary
            logInfo("æ—¥æœŸè®Šæ›´: \(oldDate.formatted()) -> \(newDate.formatted())")
            
            let calendar = Calendar.current
            let startOfDay = calendar.startOfDay(for: newDate)
            let endOfDay = calendar.date(byAdding: .day, value: 1, to: startOfDay)!
            
            do {
                // æ¸…é™¤ç•¶å‰é¸æ“‡çš„ diary (é¿å…ç‹€æ…‹æ®˜ç•™)
                selectedDiary = nil
                
                // ç²å–æ‰€æœ‰æ—¥è¨˜
                let allDiaries = try modelContext.fetch(FetchDescriptor<DiaryEntry>())
                
                // æ‰‹å‹•éæ¿¾ç•¶å¤©çš„æ—¥è¨˜
                let diariesForSelectedDate = allDiaries.filter { diary in
                    let diaryDate = diary.date
                    return diaryDate >= startOfDay && diaryDate < endOfDay
                }
                
                let oldDiaryId = selectedDiary?.id
                
                if let newDiary = diariesForSelectedDate.first {
                    logInfo("æ‰¾åˆ°æ—¥æœŸç‚º \(newDate.formatted()) çš„æ—¥è¨˜ï¼ŒID: \(newDiary.id)")
                    // é¡¯ç¤ºæ—¥è¨˜å…§å®¹çš„è©³ç´°è³‡è¨Šï¼Œä¾¿æ–¼è¨ºæ–·
                    logInfo("æ—¥è¨˜å…§å®¹ - å¤©æ°£: \(newDiary.weather.rawValue), è¨˜äº‹é•·åº¦: \(newDiary.thoughts.count) å­—ç¬¦")
                    if !newDiary.thoughts.isEmpty {
                        logInfo("æ—¥è¨˜è¨˜äº‹é è¦½: \"\(newDiary.thoughts.prefix(50))...\"")
                    } else {
                        logInfo("æ—¥è¨˜è¨˜äº‹ç‚ºç©º")
                    }
                    
                    // ç›´æ¥ä½¿ç”¨éæ¿¾åˆ°çš„æ—¥è¨˜
                    selectedDiary = newDiary
                    logInfo("å·²è¨­ç½® selectedDiary: ID = \(selectedDiary?.id.uuidString ?? "nil"), è¨˜äº‹é•·åº¦ = \(selectedDiary?.thoughts.count ?? 0)")
                } else {
                    logInfo("æœªæ‰¾åˆ°æ—¥æœŸç‚º \(newDate.formatted()) çš„æ—¥è¨˜")
                    selectedDiary = nil
                }
                
                if oldDiaryId != selectedDiary?.id {
                    logInfo("æ—¥è¨˜è®Šæ›´: \(oldDiaryId?.uuidString ?? "nil") -> \(selectedDiary?.id.uuidString ?? "nil")")
                }
            } catch {
                logInfo("æŸ¥è©¢æ—¥è¨˜å¤±æ•—: \(error)")
                selectedDiary = nil
            }
        }
        .sheet(isPresented: $showingDateRangeSheet) {
            NavigationView {
                VStack(spacing: 20) {
                    Text("åŒ¯å‡ºå‚™ä»½")
                        .font(.headline)
                        .padding(.top, 20)
                    
                    Form {
                        Section(header: Text("é¸æ“‡æ—¥æœŸç¯„åœ")) {
                            HStack {
                                Text("é–‹å§‹æ—¥æœŸ")
                                    .frame(minWidth: 80, alignment: .leading)
                                Spacer()
                                CustomDatePickerView(
                                    selectedDate: $startDate,
                                    titleFontColor: titleFontColor,
                                    contentFontColor: contentFontColor
                                )
                            }
                            .padding(.vertical, 5)
                            
                            HStack {
                                Text("çµæŸæ—¥æœŸ")
                                    .frame(minWidth: 80, alignment: .leading)
                                Spacer()
                                CustomDatePickerView(
                                    selectedDate: $endDate,
                                    titleFontColor: titleFontColor,
                                    contentFontColor: contentFontColor
                                )
                            }
                            .padding(.vertical, 5)
                        }
                    }
                    
                    HStack(spacing: 30) {
                        Button("å–æ¶ˆ") {
                            showingDateRangeSheet = false
                        }
                        
                        Button("ç¢ºå®š") {
                            showingDateRangeSheet = false
                            exportData()
                        }
                        .buttonStyle(.borderedProminent)
                    }
                    .padding(.bottom, 20)
                    
                    Spacer()
                }
                .frame(maxWidth: .infinity)
            }
            .frame(width: 400, height: 320)
        }
        .alert(isPresented: $showingAlert) {
            Alert(
                title: Text(alertTitle),
                message: Text(alertMessage),
                dismissButton: .default(Text("ç¢ºå®š"))
            )
        }
        .onAppear {
            // åˆå§‹åŒ–æ™‚ï¼Œè‡ªå‹•åˆ‡æ›åˆ°ä»Šæ—¥æ—¥è¨˜
            switchToToday()
        }
        .sheet(isPresented: $showingNewDiarySheet) {
            NewDiaryView()
        }
        .sheet(isPresented: $showingPreferencesSheet) {
            PreferencesView()
                .frame(width: 600, height: 700)
        }
        .sheet(isPresented: $showingHelpSheet) {
            HelpView()
                .frame(width: 800, height: 600)
        }
        .sheet(isPresented: $showingBackupSelectionSheet) {
            BackupSelectionView(restoreSelectedEntries: { url, selectedIds in
                // ä½¿ç”¨æ–°çš„ restoreBackup æ–¹æ³•æ›¿æ›åŸä¾†çš„æ–¹æ³•
                restoreBackup(from: url)
            })
        }
    }
    
    /// å°‡æŒ‡å®šæ—¥æœŸç¯„åœå…§çš„æ—¥è¨˜æ¢ç›®è½‰æ›ç‚ºå‚™ä»½æ ¼å¼
    private func createBackup(from: Date, to: Date) -> DiaryBackup {
        let calendar = Calendar.current
        let filteredDiaries = diaries.filter { diary in
            let diaryDate = calendar.startOfDay(for: diary.date)
            let fromDate = calendar.startOfDay(for: from)
            let toDate = calendar.startOfDay(for: to.addingTimeInterval(24*60*60))  // åŠ ä¸€å¤©ï¼Œä½¿å¾—çµæŸæ—¥æœŸåŒ…å«åœ¨å…§
            return diaryDate >= fromDate && diaryDate < toDate
        }
        
        let entries = filteredDiaries.map { diary in
            DiaryBackup.DiaryBackupEntry(
                id: diary.id,
                date: diary.date,
                weatherRaw: diary.weather.rawValue,
                thoughts: diary.thoughts,
                temperature: diary.temperature,
                expenses: diary.expenses.map { convertToBackupEntry($0) },
                exercises: diary.exercises.map { convertToBackupEntry($0) },
                sleeps: diary.sleeps.map { convertToBackupEntry($0) },
                works: diary.works.map { convertToBackupEntry($0) },
                relationships: diary.relationships.map { convertToBackupEntry($0) },
                studies: diary.studies.map { convertToBackupEntry($0) }
            )
        }
        return DiaryBackup(entries: entries)
    }
    
    /// å°‡åˆ†é¡æ¢ç›®è½‰æ›ç‚ºå‚™ä»½æ ¼å¼
    private func convertToBackupEntry(_ entry: CategoryEntry) -> DiaryBackup.CategoryBackupEntry {
        DiaryBackup.CategoryBackupEntry(
            id: entry.id,
            typeRaw: entry.typeRaw,
            name: entry.name,
            category: entry.category,
            number: entry.number,
            notes: entry.notes
        )
    }
    
    /// å¾å‚™ä»½æ•¸æ“šå‰µå»ºåˆ†é¡æ¢ç›®
    private func createCategoryEntry(_ backup: DiaryBackup.CategoryBackupEntry, type: DiaryEntryType) -> CategoryEntry {
        let entry = CategoryEntry(type: type,
                                name: backup.name,
                                category: backup.category,
                                number: backup.number,
                                notes: backup.notes)
        entry.id = backup.id
        return entry
    }
    
    /// åŒ¯å‡ºæ•¸æ“š
    private func exportData() {
        // ä½¿ç”¨æ‡‰ç”¨ç¨‹åºçš„æ–‡æª”ç›®éŒ„ï¼Œè€Œä¸æ˜¯æ¡Œé¢
        do {
            // ç²å–ç¯„åœå…§çš„æ—¥è¨˜æ¢ç›®
            let diariesInRange = diaries.filter { diary in
                diary.date >= startDate && diary.date <= endDate
            }
            
            if diariesInRange.isEmpty {
                alertTitle = "åŒ¯å‡ºå¤±æ•—"
                alertMessage = "æ‰€é¸æ—¥æœŸç¯„åœå…§æ²’æœ‰æ—¥è¨˜è³‡æ–™ã€‚"
                showingAlert = true
                showingDateRangeSheet = false
                return
            }
            
            print("é–‹å§‹åŒ¯å‡º \(diariesInRange.count) ç¯‡æ—¥è¨˜...")
            
            // å‰µå»ºå‚™ä»½æ•¸æ“š
            let entries = diariesInRange.map { diary -> DiaryBackup.DiaryBackupEntry in
                // æŒ‰ç±»å‹åˆ†ç±»
                let expenseEntries = diary.expenses.map { convertToBackupEntry($0) }
                let exerciseEntries = diary.exercises.map { convertToBackupEntry($0) }
                let sleepEntries = diary.sleeps.map { convertToBackupEntry($0) }
                let workEntries = diary.works.map { convertToBackupEntry($0) }
                let relationshipEntries = diary.relationships.map { convertToBackupEntry($0) }
                let studyEntries = diary.studies.map { convertToBackupEntry($0) }
                
                return DiaryBackup.DiaryBackupEntry(
                    id: diary.id,
                    date: diary.date,
                    weatherRaw: diary.weather.rawValue,
                    thoughts: diary.thoughts,
                    temperature: diary.temperature,
                    expenses: expenseEntries,
                    exercises: exerciseEntries,
                    sleeps: sleepEntries,
                    works: workEntries,
                    relationships: relationshipEntries,
                    studies: studyEntries
                )
            }
            
            let backup = DiaryBackup(entries: entries)
            
            // å‰µå»º JSON ç·¨ç¢¼å™¨
            let encoder = JSONEncoder()
            encoder.dateEncodingStrategy = .iso8601
            encoder.outputFormatting = .prettyPrinted
            
            // å˜—è©¦ç·¨ç¢¼
            print("é–‹å§‹ç·¨ç¢¼å‚™ä»½æ•¸æ“š...")
            let data: Data
            do {
                data = try encoder.encode(backup)
                print("æˆåŠŸç·¨ç¢¼å‚™ä»½æ•¸æ“šï¼Œå¤§å°: \(data.count) å­—ç¯€")
                
                // é©—è­‰ç·¨ç¢¼å¾Œçš„æ•¸æ“š
                if let jsonString = String(data: data, encoding: .utf8) {
                    print("JSON å‰ 100 å€‹å­—ç¬¦: \(String(jsonString.prefix(100)))")
                    
                    // å˜—è©¦è§£ç¢¼å›ä¾†ä»¥é©—è­‰æ ¼å¼æ˜¯å¦æ­£ç¢º
                    let decoder = JSONDecoder()
                    decoder.dateDecodingStrategy = .iso8601
                    do {
                        let testBackup = try decoder.decode(DiaryBackup.self, from: data)
                        print("é©—è­‰æˆåŠŸ: å¯ä»¥è§£ç¢¼å› \(testBackup.entries.count) ç¯‡æ—¥è¨˜")
                    } catch {
                        print("è­¦å‘Š: ç·¨ç¢¼çš„æ•¸æ“šç„¡æ³•è§£ç¢¼å›ä¾†: \(error)")
                    }
                }
            } catch {
                print("ç·¨ç¢¼å‚™ä»½æ•¸æ“šå¤±æ•—: \(error)")
                throw error
            }
            
            // å‰µå»ºæ–‡ä»¶å
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "yyyyMMdd"
            let fileName = "diary_backup_\(dateFormatter.string(from: startDate))_to_\(dateFormatter.string(from: endDate)).json"
            
            // ä½¿ç”¨æ‡‰ç”¨ç¨‹åºçš„æ–‡æª”ç›®éŒ„
            let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            let fileURL = documentsURL.appendingPathComponent(fileName)
            
            print("æ­£åœ¨ä¿å­˜è‡³: \(fileURL.path)")
            
            // å¯«å…¥æª”æ¡ˆ
            try data.write(to: fileURL)
            print("å‚™ä»½æ–‡ä»¶æˆåŠŸä¿å­˜! è·¯å¾‘: \(fileURL.path)")
            print("å‚™ä»½æ–‡ä»¶å¤§å°: \(data.count) å­—ç¯€")

            // æª¢æŸ¥æ–‡ä»¶æ˜¯å¦ç¢ºå¯¦å­˜åœ¨
            if FileManager.default.fileExists(atPath: fileURL.path) {
                print("å·²ç¢ºèªæ–‡ä»¶æˆåŠŸä¿å­˜åœ¨ç£ç›¤ä¸Š")
                
                // æª¢æŸ¥æ–‡ä»¶æ¬Šé™
                if FileManager.default.isReadableFile(atPath: fileURL.path) {
                    print("æ–‡ä»¶æ¬Šé™æ­£ç¢º: å¯è®€")
                } else {
                    print("è­¦å‘Š: æ–‡ä»¶æ¬Šé™å•é¡Œ - ä¸å¯è®€")
                }
            } else {
                print("è­¦å‘Š: æ–‡ä»¶å¯«å…¥æˆåŠŸä½†ç„¡æ³•åœ¨è·¯å¾‘æ‰¾åˆ°æ–‡ä»¶!")
            }

            // é€šçŸ¥ä½¿ç”¨è€…
            alertTitle = "åŒ¯å‡ºæˆåŠŸ"
            alertMessage = "æ—¥è¨˜å‚™ä»½å·²ä¿å­˜è‡³æ–‡æª”ç›®éŒ„ï¼š\n\(fileURL.path)\n\nè¨»ï¼šæ‚¨å¯ä»¥åœ¨æ‡‰ç”¨ç¨‹åºçš„æ–‡æª”ç›®éŒ„ä¸­æ‰¾åˆ°é€™å€‹æª”æ¡ˆã€‚"
        } catch {
            print("åŒ¯å‡ºå¤±æ•—: \(error)")
            alertTitle = "åŒ¯å‡ºå¤±æ•—"
            alertMessage = "éŒ¯èª¤ï¼š\(error.localizedDescription)"
        }
        
        showingAlert = true
        showingDateRangeSheet = false
    }
    
    /// åŒ¯å…¥æ•¸æ“š
    @available(*, deprecated, message: "ä½¿ç”¨BackupSelectionViewæ›¿ä»£")
    private func importData() {
        alertTitle = "è¯·ä½¿ç”¨å¤‡ä»½æ¢å¤åŠŸèƒ½"
        alertMessage = "å·²æ›´æ–°å¤‡ä»½æ¢å¤åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨å·¥å…·æ ä¸­çš„å¤‡ä»½æ¢å¤æŒ‰é’®(æ–‡ä»¶å¤¹å¸¦ä¸‹ç®­å¤´å›¾æ ‡)æ¥æ¢å¤æ•°æ®ã€‚"
        showingAlert = true
        showingDateRangeSheet = false
        
        // æ—§çš„å®ç°å·²è¢«æ³¨é‡Šæ‰ï¼Œä¿ç•™ä»…ä¾›å‚è€ƒ
        /*
        do {
            let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "yyyyMMdd"
            let startDateString = dateFormatter.string(from: startDate)
            let endDateString = dateFormatter.string(from: endDate)
            let backupURL = documentsDirectory.appendingPathComponent("diary_backup_\(startDateString)_\(endDateString).json")
            let data = try Data(contentsOf: backupURL)
            let backup = try JSONDecoder().decode(DiaryBackup.self, from: data)
            
            // åˆªé™¤æŒ‡å®šæ—¥æœŸç¯„åœå…§çš„ç¾æœ‰æ•¸æ“š
            let calendar = Calendar.current
            let diariesToDelete = diaries.filter { diary in
                let diaryDate = calendar.startOfDay(for: diary.date)
                let fromDate = calendar.startOfDay(for: startDate)
                let toDate = calendar.startOfDay(for: endDate.addingTimeInterval(24*60*60))  // åŠ ä¸€å¤©ï¼Œä½¿å¾—çµæŸæ—¥æœŸåŒ…å«åœ¨å…§
                return diaryDate >= fromDate && diaryDate < toDate
            }
            for diary in diariesToDelete {
                modelContext.delete(diary)
            }
            
            // æ¢å¾©å‚™ä»½æ•¸æ“š
            for backupEntry in backup.entries {
                let diary = DiaryEntry(date: backupEntry.date,
                                     weather: WeatherType(rawValue: backupEntry.weatherRaw) ?? .sunny,
                                     thoughts: backupEntry.thoughts,
                                     temperature: backupEntry.temperature)
                diary.id = backupEntry.id
                
                diary.expenses = backupEntry.expenses.map { createCategoryEntry($0, type: .expense) }
                diary.exercises = backupEntry.exercises.map { createCategoryEntry($0, type: .exercise) }
                diary.sleeps = backupEntry.sleeps.map { createCategoryEntry($0, type: .sleep) }
                diary.works = backupEntry.works.map { createCategoryEntry($0, type: .work) }
                diary.relationships = backupEntry.relationships.map { createCategoryEntry($0, type: .relationship) }
                diary.studies = backupEntry.studies.map { createCategoryEntry($0, type: .study) }
                
                modelContext.insert(diary)
            }
            
            try modelContext.save()
            alertTitle = "åŒ¯å…¥æˆåŠŸ"
            alertMessage = "æˆåŠŸæ¢å¾© \(backup.entries.count) ç¯‡æ—¥è¨˜"
        } catch {
            alertTitle = "åŒ¯å…¥å¤±æ•—"
            alertMessage = error.localizedDescription
        }
        
        showingAlert = true
        */
    }
    
    /// å¾å‚™ä»½æ•¸æ“šæ¢å¾©
    private func restoreFromBackup(_ backup: DiaryBackup) {
        // æ¸…é™¤ç¾æœ‰æ•¸æ“š
        for diary in diaries {
            modelContext.delete(diary)
        }
        
        // æ¢å¾©å‚™ä»½æ•¸æ“š
        for backupEntry in backup.entries {
            let diary = DiaryEntry(date: backupEntry.date,
                                 weather: WeatherType(rawValue: backupEntry.weatherRaw) ?? .sunny,
                                 thoughts: backupEntry.thoughts,
                                 temperature: backupEntry.temperature)
            diary.id = backupEntry.id
            
            // æ¢å¾©åˆ†é¡æ¢ç›®
            diary.expenses = backupEntry.expenses.map { createCategoryEntry($0, type: .expense) }
            diary.exercises = backupEntry.exercises.map { createCategoryEntry($0, type: .exercise) }
            diary.sleeps = backupEntry.sleeps.map { createCategoryEntry($0, type: .sleep) }
            diary.works = backupEntry.works.map { createCategoryEntry($0, type: .work) }
            diary.relationships = backupEntry.relationships.map { createCategoryEntry($0, type: .relationship) }
            diary.studies = backupEntry.studies.map { createCategoryEntry($0, type: .study) }
            
            modelContext.insert(diary)
        }
        
        // ä¿å­˜æ›´æ”¹
        try? modelContext.save()
    }
    
    /// æŸ¥æ‰¾æœ¬åœ°æ‰€æœ‰å¤‡ä»½æ–‡ä»¶
    private func findLocalBackups() -> [URL] {
        let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let fileManager = FileManager.default
        
        do {
            // è·å–æ–‡æ¡£ç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶
            let fileURLs = try fileManager.contentsOfDirectory(at: documentsDirectory, includingPropertiesForKeys: nil)
            
            // è¿‡æ»¤å‡ºå¤‡ä»½æ–‡ä»¶ï¼ˆ.jsonæ ¼å¼ä¸”æ–‡ä»¶ååŒ…å«"diary_backup_"ï¼‰
            let backupFiles = fileURLs.filter { url in
                let filename = url.lastPathComponent
                return filename.hasSuffix(".json") && filename.contains("diary_backup_")
            }
            
            return backupFiles.sorted { $0.lastPathComponent > $1.lastPathComponent }
        } catch {
            print("Error finding backup files: \(error)")
            return []
        }
    }
    
    /// ä»å¤‡ä»½æ–‡ä»¶æ¢å¤æ•°æ®ï¼Œä»…æ¢å¤é€‰å®šçš„æ¡ç›®ï¼Œä»¥å¤‡ä»½ä¼˜å…ˆ
    private func restoreSelectedEntries(from backupURL: URL, selectedEntryIds: [UUID]) {
        do {
            let data = try Data(contentsOf: backupURL)
            
            // åˆ›å»ºè§£ç å™¨å¹¶è®¾ç½®æ—¥æœŸè§£ç ç­–ç•¥
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601 // ç¡®ä¿ä¸ç¼–ç æ—¶ä½¿ç”¨ç›¸åŒçš„æ—¥æœŸç­–ç•¥
            
            // å°è¯•è§£ç å‰å…ˆæ‰“å°è°ƒè¯•ä¿¡æ¯
            print("å‚™ä»½æ–‡ä»¶å¤§å°: \(data.count) å­—ç¯€")
            if let jsonString = String(data: data, encoding: .utf8) {
                print("JSON å‰ 100 å€‹å­—ç¬¦: \(String(jsonString.prefix(100)))")
            }
            
            // å°è¯•è§£ç 
            let backup: DiaryBackup
            do {
                backup = try decoder.decode(DiaryBackup.self, from: data)
            } catch let decodingError as DecodingError {
                // è§£ç å¤±è´¥çš„æ›´è¯¦ç»†ä¿¡æ¯
                switch decodingError {
                case .dataCorrupted(let context):
                    print("æ•¸æ“šæå£: \(context.debugDescription)")
                case .keyNotFound(let key, let context):
                    print("æ‰¾ä¸åˆ°éµ '\(key.stringValue)': \(context.debugDescription)")
                case .typeMismatch(let type, let context):
                    print("é¡å‹ä¸åŒ¹é… \(type): \(context.debugDescription)")
                case .valueNotFound(let type, let context):
                    print("æ‰¾ä¸åˆ°å€¼ \(type): \(context.debugDescription)")
                @unknown default:
                    print("æœªçŸ¥è§£ç¢¼éŒ¯èª¤")
                }
                throw decodingError
            }
            
            // è§£ç æˆåŠŸåç»§ç»­å¤„ç†
            print("æˆåŠŸè§£ç å¤‡ä»½ï¼ŒåŒ…å« \(backup.entries.count) æ¡æ—¥è®°")
            
            // è¿‡æ»¤å‡ºé€‰å®šçš„æ¡ç›®
            let selectedEntries: [DiaryBackup.DiaryBackupEntry]
            if selectedEntryIds.isEmpty {
                // å¦‚æœæ²¡æœ‰æŒ‡å®šIDï¼Œæ¢å¤æ‰€æœ‰æ¡ç›®
                selectedEntries = backup.entries
            } else {
                // å¦åˆ™åªæ¢å¤é€‰å®šçš„æ¡ç›®
                selectedEntries = backup.entries.filter { backupEntry in
                    selectedEntryIds.contains(backupEntry.id)
                }
            }
            
            // æŸ¥æ‰¾ç°æœ‰æ—¥è®°ä¸­ä¸é€‰å®šå¤‡ä»½æ—¥è®°ç›¸åŒæ—¥æœŸçš„æ¡ç›®
            let calendar = Calendar.current
            for backupEntry in selectedEntries {
                // æŸ¥æ‰¾åŒä¸€æ—¥æœŸçš„ç°æœ‰æ—¥è®°
                let backupEntryStartOfDay = calendar.startOfDay(for: backupEntry.date)
                let backupEntryEndOfDay = calendar.date(byAdding: .day, value: 1, to: backupEntryStartOfDay)!
                
                let existingDiary = diaries.first { diary in
                    let diaryDate = diary.date
                    return diaryDate >= backupEntryStartOfDay && diaryDate < backupEntryEndOfDay
                }
                
                if let existingDiary = existingDiary {
                    // å¦‚æœæ‰¾åˆ°åŒæ—¥æœŸçš„æ—¥è®°ï¼Œåˆ é™¤ç°æœ‰çš„å¹¶æ’å…¥å¤‡ä»½çš„
                    modelContext.delete(existingDiary)
                }
                
                // åˆ›å»ºå¹¶æ’å…¥å¤‡ä»½æ—¥è®°
                let diary = DiaryEntry(date: backupEntry.date,
                                     weather: WeatherType(rawValue: backupEntry.weatherRaw) ?? .sunny,
                                     thoughts: backupEntry.thoughts,
                                     temperature: backupEntry.temperature)
                diary.id = backupEntry.id
                
                diary.expenses = backupEntry.expenses.map { createCategoryEntry($0, type: .expense) }
                diary.exercises = backupEntry.exercises.map { createCategoryEntry($0, type: .exercise) }
                diary.sleeps = backupEntry.sleeps.map { createCategoryEntry($0, type: .sleep) }
                diary.works = backupEntry.works.map { createCategoryEntry($0, type: .work) }
                diary.relationships = backupEntry.relationships.map { createCategoryEntry($0, type: .relationship) }
                diary.studies = backupEntry.studies.map { createCategoryEntry($0, type: .study) }
                
                modelContext.insert(diary)
            }
            
            try modelContext.save()
            alertTitle = "æ¢å¤æˆåŠŸ"
            alertMessage = "å·²æˆåŠŸæ¢å¤é€‰å®šçš„ \(selectedEntries.count) ç¯‡æ—¥è®°"
            showingAlert = true
        } catch {
            print("æ¢å¾©å¤±æ•—: \(error.localizedDescription)")
            alertTitle = "æ¢å¤å¤±è´¥"
            alertMessage = "é”™è¯¯ï¼š\(error.localizedDescription)"
            showingAlert = true
        }
    }
    
    /// åˆ‡æ¢åˆ°ä»Šæ—¥æ—¥è®°ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
    private func switchToToday() {
        let today = Date()
        let calendar = Calendar.current
        
        // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ä»Šæ—¥æ—¥è¨˜
        if let existingDiary = diaries.first(where: { calendar.isDateInToday($0.date) }) {
            // å·²æœ‰ä»Šæ—¥æ—¥è¨˜ï¼Œé¸ä¸­å®ƒ
            selectedDiary = existingDiary
            selectedDate = existingDiary.date
        } else {
            // æ²’æœ‰ä»Šæ—¥æ—¥è¨˜ï¼Œå‰µå»ºæ–°çš„
            let newDiary = DiaryEntry(date: today, weather: .sunny, thoughts: "")
            modelContext.insert(newDiary)
            try? modelContext.save()
            selectedDiary = newDiary
            selectedDate = today
        }
    }
    
    func deleteEntry(_ diary: DiaryEntry) {
        // å¦‚æœè¦åˆªé™¤çš„æ˜¯ç•¶å‰é¸ä¸­çš„æ—¥è¨˜ï¼Œå…ˆæ¸…ç©ºé¸ä¸­ç‹€æ…‹
        if selectedDiary?.id == diary.id {
            selectedDiary = nil
        }
        
        // å¾æ•¸æ“šåº«ä¸­åˆªé™¤æ—¥è¨˜
        modelContext.delete(diary)
        
        // å˜—è©¦ä¿å­˜æ›´æ”¹
        do {
            try modelContext.save()
            logInfo("æˆåŠŸåˆªé™¤æ—¥è¨˜")
        } catch {
            logInfo("åˆªé™¤æ—¥è¨˜æ™‚å‡ºéŒ¯: \(error)")
        }
    }
    
    /// ç‚ºé¸æ“‡çš„æ—¥æœŸå‰µå»ºæ–°æ—¥è¨˜
    private func createDiaryForSelectedDate() {
        logInfo("ç‚ºæ—¥æœŸ \(selectedDate.formatted()) å‰µå»ºæ–°æ—¥è¨˜")
        
        // å‰µå»ºæ–°æ—¥è¨˜
        let newDiary = DiaryEntry(date: selectedDate, weather: .sunny, thoughts: "")
        modelContext.insert(newDiary)
        
        do {
            try modelContext.save()
            logInfo("æˆåŠŸå‰µå»ºæ–°æ—¥è¨˜ï¼ŒID: \(newDiary.id)")
            
            // è¨­ç½®ç‚ºç•¶å‰é¸ä¸­çš„æ—¥è¨˜
            selectedDiary = newDiary
        } catch {
            logInfo("å‰µå»ºæ—¥è¨˜å¤±æ•—: \(error)")
        }
    }
    
    private func restoreBackup(from backupURL: URL, filterByDate: (Date, Date)? = nil) {
        print("é–‹å§‹å¾ \(backupURL.path) æ¢å¾©å‚™ä»½")
        
        do {
            let data = try Data(contentsOf: backupURL)
            
            // è§£ç¢¼å™¨è¨­å®š
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601
            
            print("å‚™ä»½æ–‡ä»¶å¤§å°: \(data.count) å­—ç¯€")
            
            // å˜—è©¦è§£ç¢¼
            let backup: DiaryBackup
            do {
                backup = try decoder.decode(DiaryBackup.self, from: data)
                print("æˆåŠŸè§£ç¢¼å‚™ä»½ï¼ŒåŒ…å« \(backup.entries.count) æ¢æ—¥è¨˜")
            } catch {
                print("å‚™ä»½æ–‡ä»¶è§£ç¢¼å¤±æ•—: \(error)")
                alertTitle = "æ¢å¾©å¤±æ•—"
                alertMessage = "å‚™ä»½æ–‡ä»¶æ ¼å¼ç„¡æ•ˆ: \(error.localizedDescription)"
                showingAlert = true
                return
            }
            
            // ç¯©é¸æ—¥æœŸç¯„åœå…§çš„æ¢ç›®
            var entriesToRestore = backup.entries
            
            if let (startDate, endDate) = filterByDate {
                entriesToRestore = backup.entries.filter { entry in
                    entry.date >= startDate && entry.date <= endDate
                }
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰æ‰¾åˆ°æ¢ç›®
            guard !entriesToRestore.isEmpty else {
                alertTitle = "æ¢å¾©å¤±æ•—"
                alertMessage = "æ²’æœ‰æ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„æ—¥è¨˜æ¢ç›®"
                showingAlert = true
                return
            }
            
            print("å°‡æ¢å¾© \(entriesToRestore.count) æ¢æ—¥è¨˜")
            
            // åˆªé™¤é‡ç–Šæ—¥æœŸçš„ç¾æœ‰æ¢ç›®
            let calendar = Calendar.current
            for backupEntry in entriesToRestore {
                let backupEntryStartOfDay = calendar.startOfDay(for: backupEntry.date)
                let backupEntryEndOfDay = calendar.date(byAdding: .day, value: 1, to: backupEntryStartOfDay)!
                
                let existingDiary = diaries.first { diary in
                    let diaryDate = diary.date
                    return diaryDate >= backupEntryStartOfDay && diaryDate < backupEntryEndOfDay
                }
                
                if let existingDiary = existingDiary {
                    print("åˆªé™¤ç¾æœ‰çš„æ—¥è¨˜: \(existingDiary.id)")
                    modelContext.delete(existingDiary)
                }
                
                // å‰µå»ºä¸¦æ’å…¥å‚™ä»½æ—¥è¨˜
                let diary = DiaryEntry(date: backupEntry.date,
                                     weather: WeatherType(rawValue: backupEntry.weatherRaw) ?? .sunny,
                                     thoughts: backupEntry.thoughts,
                                     temperature: backupEntry.temperature)
                diary.id = backupEntry.id
                
                diary.expenses = backupEntry.expenses.map { createCategoryEntry($0, type: .expense) }
                diary.exercises = backupEntry.exercises.map { createCategoryEntry($0, type: .exercise) }
                diary.sleeps = backupEntry.sleeps.map { createCategoryEntry($0, type: .sleep) }
                diary.works = backupEntry.works.map { createCategoryEntry($0, type: .work) }
                diary.relationships = backupEntry.relationships.map { createCategoryEntry($0, type: .relationship) }
                diary.studies = backupEntry.studies.map { createCategoryEntry($0, type: .study) }
                
                modelContext.insert(diary)
            }
            
            // ä¿å­˜æ›´æ”¹
            do {
                try modelContext.save()
                alertTitle = "æ¢å¾©æˆåŠŸ"
                alertMessage = "å·²æˆåŠŸæ¢å¾© \(entriesToRestore.count) ç¯‡æ—¥è¨˜"
                showingAlert = true
            } catch {
                print("ä¿å­˜æ¢å¾©çš„æ—¥è¨˜æ™‚å‡ºéŒ¯: \(error)")
                alertTitle = "æ¢å¾©å¤±æ•—"
                alertMessage = "ä¿å­˜æ¢å¾©çš„æ—¥è¨˜æ™‚å‡ºéŒ¯: \(error.localizedDescription)"
                showingAlert = true
            }
        } catch {
            print("è®€å–å‚™ä»½æ–‡ä»¶æ™‚å‡ºéŒ¯: \(error)")
            alertTitle = "æ¢å¾©å¤±æ•—"
            alertMessage = "è®€å–å‚™ä»½æ–‡ä»¶æ™‚å‡ºéŒ¯: \(error.localizedDescription)"
            showingAlert = true
        }
    }
}

// MARK: - æ–°æ—¥è¨˜è¦–åœ–
/// å‰µå»ºæ–°æ—¥è¨˜çš„è¦–åœ–
struct NewDiaryView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var modelContext
    @State private var date = Date()
    @State private var weather = WeatherType.sunny
    @State private var thoughts = ""
    
    // æ·»åŠ å­—ä½“é¢œè‰²è®¾ç½®
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    var body: some View {
        NavigationView {
            Form {
                // ä½¿ç”¨è‡ªå®šä¹‰æ—¥æœŸé€‰æ‹©å™¨
                HStack {
                    Text("æ—¥æœŸ")
                        .font(.system(size: 20))
                    Spacer()
                    CustomDatePickerView(
                        selectedDate: $date,
                        titleFontColor: titleFontColor,
                        contentFontColor: contentFontColor
                    )
                    .help("é¸æ“‡è¦æŸ¥çœ‹çš„æ—¥æœŸ")
                }
                .padding(.vertical, 5)
                
                Section("å¤©æ°£") {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 15) {
                            ForEach(WeatherType.allCases, id: \.self) { type in
                                VStack {
                                    Image(systemName: type.icon)
                                        .font(.system(size: 22))
                                        .foregroundColor(weather == type ? .blue : .gray)
                                        .padding(8)
                                        .background(
                                            Circle()
                                                .fill(weather == type ? Color.blue.opacity(0.2) : Color.clear)
                                        )
                                    Text(type.rawValue)
                                        .font(.system(size: 20))
                                }
                                .onTapGesture {
                                    weather = type
                                }
                            }
                        }
                    }
                    .frame(height: 80)
                }
                
                Section("è¨˜äº‹") {
                    EnhancedTextEditor(text: $thoughts)
                        .frame(height: 200)
                }
            }
            .navigationTitle("æ–°å¢æ—¥è¨˜")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("å–æ¶ˆ") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("ä¿å­˜") {
                        let newDiary = DiaryEntry(date: date, weather: weather, thoughts: thoughts)
                        modelContext.insert(newDiary)
                        try? modelContext.save()
                        dismiss()
                    }
                }
            }
        }
    }
}

// MARK: - æ—¥è¨˜è©³ç´°è¦–åœ–
/// é¡¯ç¤ºæ—¥è¨˜è©³ç´°å…§å®¹çš„è¦–åœ–
struct DiaryDetailView: View {
    var diary: DiaryEntry  // ä½¿ç”¨æ™®é€šè®Šé‡ï¼Œè€Œé ObservedObject
    @State private var selectedTab: Int = 0
    @Binding var externalSelectedTab: String?
    @State private var thoughts: String
    @State private var isLoading: Bool = false
    @State private var isOnline: Bool = false
    @State private var isUpdating: Bool = false
    @State private var selectedWeather: String
    @AppStorage("weatherApiKey") private var apiKey: String = "76fb9beb7dd213c17447b2b9080e0bcb"
    
    // âš ï¸ é€™è£¡çš„ @AppStorage å®£å‘Šèˆ‡å…¶ä»–è¦–åœ–é‡è¤‡ï¼Œè€ƒæ…®å‰µå»ºä¸€å€‹å–®ä¸€å…±äº«è¨­å®šç‰©ä»¶
    @AppStorage("titleFontSize") private var titleFontSize: Double = 22
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    @State private var showingApiKeyAlert = false
    @State private var showingLocationAlert = false
    @State private var locationErrorMessage = ""
    @Environment(\.modelContext) private var modelContext
    
    // æ·»åŠ å‹•ç•«ç‹€æ…‹
    @State private var titleScale: Double = 1.0
    // è¿½è¹¤ç•¶å‰é¡¯ç¤ºçš„æ—¥è¨˜ID
    @State private var currentDiaryId: UUID
    
    init(diary: DiaryEntry) {
        self.diary = diary
        _selectedWeather = State(initialValue: diary.weather.rawValue)
        _thoughts = State(initialValue: diary.thoughts)
        _isOnline = State(initialValue: Calendar.current.isDateInToday(diary.date) && !diary.temperature.isEmpty)
        _externalSelectedTab = .constant(nil)
        _currentDiaryId = State(initialValue: diary.id)
    }
    
    init(diary: DiaryEntry, selectedTab: Binding<String?>) {
        self.diary = diary
        _selectedWeather = State(initialValue: diary.weather.rawValue)
        _thoughts = State(initialValue: diary.thoughts)
        _isOnline = State(initialValue: Calendar.current.isDateInToday(diary.date) && !diary.temperature.isEmpty)
        _externalSelectedTab = selectedTab
        _currentDiaryId = State(initialValue: diary.id)
    }
    
    private var weatherService: WeatherService? {
        if !apiKey.isEmpty {
            return WeatherService(apiKey: apiKey)
        }
        return nil
    }
    
    private var isToday: Bool {
        Calendar.current.isDateInToday(diary.date)
    }
    
    private func saveContext() {
        do {
            try modelContext.save()
            logInfo("å¤©æ°£å’Œè¨˜äº‹ä¿å­˜æˆåŠŸ")
        } catch {
            logInfo("ä¿å­˜å¤±æ•—: \(error)")
        }
    }
    
    private func updateWeather() {
        // æ·»åŠ èª¿è©¦è¼¸å‡º
        logInfo("æº–å‚™æ›´æ–°å¤©æ°£ä¿¡æ¯...")
        
        guard isToday else {
            isOnline = false
            diary.temperature = ""
            saveContext()
            return
        }
        
        if let service = weatherService {
            isLoading = true
            Task {
                do {
                    let (weatherType, temp) = try await service.fetchWeather()
                    await MainActor.run {
                        selectedWeather = weatherType.rawValue
                        diary.temperature = temp
                        diary.weather = weatherType
                        isOnline = true
                        
                        // æ·»åŠ èª¿è©¦è¼¸å‡º
                        logInfo("å¤©æ°£æ›´æ–°æˆåŠŸ: \(temp), é¡å‹: \(weatherType.rawValue)")
                        
                        saveContext()
                        isLoading = false
                    }
                } catch {
                    await MainActor.run {
                        diary.temperature = ""
                        isOnline = false
                        isLoading = false
                        
                        // æ·»åŠ èª¿è©¦è¼¸å‡º
                        logInfo("å¤©æ°£æ›´æ–°å¤±æ•—: \(error)")
                        
                        let nsError = error as NSError
                        switch nsError.domain {
                        case "WeatherService":
                            switch nsError.code {
                            case 1:
                                locationErrorMessage = "è«‹åœ¨ç³»çµ±åå¥½è¨­å®šä¸­å•Ÿç”¨ä½ç½®æœå‹™ï¼Œä¸¦å…è¨±æ‡‰ç”¨ç¨‹åºä½¿ç”¨ä½ç½®ä¿¡æ¯ã€‚"
                            case 2:
                                locationErrorMessage = "è«‹æˆäºˆæ‡‰ç”¨ç¨‹åºä½ç½®æ¬Šé™ä»¥ç²å–å¤©æ°£è³‡è¨Šã€‚"
                            default:
                                locationErrorMessage = nsError.localizedDescription
                            }
                        default:
                            locationErrorMessage = "ç²å–å¤©æ°£è³‡è¨Šå¤±æ•—ï¼Œè«‹ç¨å¾Œé‡è©¦ã€‚"
                        }
                        showingLocationAlert = true
                    }
                }
            }
        } else {
            showingApiKeyAlert = true
        }
    }
    
    private func switchToManual() {
        isOnline = false
        diary.temperature = ""
        saveContext()
    }
    
    // åˆ·æ–°è¦–åœ–ç‹€æ…‹ï¼Œèˆ‡ diary ä¿æŒåŒæ­¥
    private func refreshViewData() {
        // æª¢æŸ¥æ—¥è¨˜ ID æ˜¯å¦è®Šæ›´ï¼Œç¢ºä¿æ˜¯æ–°æ•¸æ“š
        if currentDiaryId != diary.id {
            logInfo("æ—¥è¨˜å·²è®Šæ›´ï¼Œå¾ ID: \(currentDiaryId) åˆ° ID: \(diary.id)")
            currentDiaryId = diary.id
        }
        
        // ç„¡è«–å¦‚ä½•éƒ½è¦æ›´æ–°æœ¬åœ°ç‹€æ…‹ï¼Œä»¥ç¢ºä¿è¦–åœ–èˆ‡æ¨¡å‹åŒæ­¥
        thoughts = diary.thoughts
        selectedWeather = diary.weather.rawValue
        isOnline = Calendar.current.isDateInToday(diary.date) && !diary.temperature.isEmpty
        
        logInfo("å·²åˆ·æ–°è¦–åœ–æ•¸æ“š - æ—¥è¨˜ID: \(diary.id), æ—¥æœŸ: \(diary.date.formatted()), å¤©æ°£: \(diary.weather.rawValue), è¨˜äº‹é•·åº¦: \(diary.thoughts.count)å­—ç¬¦")
        logInfo("è¨˜äº‹å…§å®¹: \"\(diary.thoughts.prefix(50))...\"")
    }
    
    var body: some View {
        TabView(selection: $selectedTab) {
            WeatherAndThoughtsView(
                diary: diary, 
                thoughts: $thoughts, 
                diaryTemperature: diary.temperature, 
                isToday: isToday, 
                updateWeather: updateWeather,
                diaryId: diary.id // å‚³éæ—¥è¨˜IDï¼Œç”¨æ–¼æª¢æ¸¬è®ŠåŒ–
            )
            .tabItem {
                Label("åŸºæœ¬", systemImage: "house.fill")
            }
            .tag(0)
            
            // æ”¯å‡ºåˆ†ç±»
            CategoryDetailView(type: .expense, diary: diary)
            .tabItem {
                Label("æ”¯å‡º", systemImage: "dollarsign.circle.fill")
            }
            .tag(1)
            
            // é‹å‹•åˆ†ç±»
            CategoryDetailView(type: .exercise, diary: diary)
            .tabItem {
                Label("é‹å‹•", systemImage: "figure.run.circle.fill")
            }
            .tag(2)
            
            // ç¡çœ åˆ†ç±»
            CategoryDetailView(type: .sleep, diary: diary)
            .tabItem {
                Label("ç¡çœ ", systemImage: "bed.double.circle.fill")
            }
            .tag(3)
            
            // å·¥ä½œåˆ†ç±»
            CategoryDetailView(type: .work, diary: diary)
            .tabItem {
                Label("å·¥ä½œ", systemImage: "briefcase.circle.fill")
            }
            .tag(4)
            
            // é—œä¿‚åˆ†ç±»
            CategoryDetailView(type: .relationship, diary: diary)
            .tabItem {
                Label("é—œä¿‚", systemImage: "person.2.circle.fill")
            }
            .tag(5)
            
            // å­¸ç¿’åˆ†ç±»
            CategoryDetailView(type: .study, diary: diary)
            .tabItem {
                Label("å­¸ç¿’", systemImage: "book.circle.fill")
            }
            .tag(6)
        }
        .onChange(of: thoughts) { oldValue, newValue in
            // æ·»åŠ æ—¥èªŒï¼Œæª¢æŸ¥è¨˜äº‹è®Šæ›´
            if oldValue != newValue {
                logInfo("è¨˜äº‹è®Šæ›´ï¼šå¾ \(oldValue.count) å­—ç¬¦åˆ° \(newValue.count) å­—ç¬¦")
                // å°‡æ›´æ–°å¾Œçš„è¨˜äº‹ä¿å­˜åˆ°æ—¥è¨˜ç‰©ä»¶
                diary.thoughts = newValue
                try? modelContext.save()
            }
        }
        .onChange(of: diary.id) { oldId, newId in
            // ç•¶æ—¥è¨˜IDè®Šæ›´æ™‚ï¼Œå¼·åˆ¶æ›´æ–°æ‰€æœ‰è¦–åœ–ç‹€æ…‹
            logInfo("âš ï¸ æ—¥è¨˜IDè®Šæ›´è§¸ç™¼ï¼Œå¾ \(oldId.uuidString) åˆ° \(newId.uuidString)")
            refreshViewData()
        }
        // ä½¿ç”¨è¤‡åˆIDä½œç‚ºè¦–åœ–å”¯ä¸€æ¨™è­˜ï¼Œç¢ºä¿è¦–åœ–æœƒé‡æ–°å‰µå»º
        .id("diary-\(diary.id)-\(diary.date.timeIntervalSince1970)")
        .onAppear {
            logInfo("DiaryDetailViewå‡ºç¾ï¼Œæ—¥è¨˜ID: \(diary.id), è¨˜äº‹: \(diary.thoughts.prefix(20))...")
            refreshViewData() // é¦–æ¬¡å‡ºç¾æ™‚åˆ·æ–°æ•¸æ“š
        }
        .alert("éœ€è¦APIå¯†é‘°", isPresented: $showingApiKeyAlert) {
            Button("ç¢ºå®š") { }
        } message: {
            Text("è«‹åœ¨è¨­å®šä¸­æ·»åŠ å¤©æ°£APIå¯†é‘°ä»¥ç²å–å¯¦æ™‚å¤©æ°£è³‡è¨Šã€‚")
        }
        .alert("ä½ç½®æœå‹™éŒ¯èª¤", isPresented: $showingLocationAlert) {
            Button("ç¢ºå®š") { }
        } message: {
            Text(locationErrorMessage)
        }
    }
}

struct WeatherAndThoughtsView: View {
    var diary: DiaryEntry  // ä½¿ç”¨æ™®é€šè®Šé‡ï¼Œè€Œé ObservedObject
    @Binding var thoughts: String
    let diaryTemperature: String
    let isToday: Bool
    let updateWeather: () -> Void
    let diaryId: UUID  // è¿½è¹¤æ—¥è¨˜IDï¼Œç”¨æ–¼æª¢æ¸¬è®ŠåŒ–
    
    // æ–°å¢ç‹€æ…‹ï¼Œæ§åˆ¶æé†’è¡¨å–®
    @State private var showingReminderSheet = false
    @State private var showingEventAlert = false
    @State private var eventAlertMessage = ""
    @State private var eventDetails: (title: String, date: Date)? = nil
    
    // ä½¿ç”¨ onAppear åˆ·æ–°ç¶å®šçš„æ•¸æ“š
    private func refreshBindings() {
        // ç¢ºä¿é¡¯ç¤ºçš„è¨˜äº‹èˆ‡ç•¶å‰æ—¥è¨˜åŒæ­¥
        if thoughts != diary.thoughts {
            logInfo("WeatherAndThoughtsView: æ›´æ–°è¨˜äº‹å…§å®¹ï¼Œå¾ \(thoughts.count) å­—ç¬¦åˆ° \(diary.thoughts.count) å­—ç¬¦")
            thoughts = diary.thoughts
        }
    }
    
    var body: some View {
        VStack(spacing: 20) {
            // å°‡å¤©æ°£å€æ®µæŠ½å–ç‚ºç¨ç«‹è¦–åœ–çµ„ä»¶ï¼Œæå‡æ›´æ–°æ•ˆç‡
            WeatherDisplayView(
                diary: diary,
                diaryTemperature: diaryTemperature,
                isToday: isToday,
                updateWeather: updateWeather
            )
            
            Divider()
            
            VStack(alignment: .leading) {
                HStack {
                    Text("è¨˜äº‹")
                        .font(.headline)
                    
                    Spacer()
                    
                    // æ·»åŠ è¨­å®šæé†’çš„æŒ‰éˆ•
                    Button(action: {
                        showingReminderSheet = true
                    }) {
                        Image(systemName: "bell.badge")
                            .font(.system(size: 16))
                            .foregroundColor(.blue)
                    }
                    .buttonStyle(.borderless)
                    .help("è¨­å®šæé†’")
                    
                    // æ·»åŠ ä¸€å€‹èª¿è©¦æŒ‰éˆ•ï¼Œç”¨æ–¼æŸ¥çœ‹ç•¶å‰ç¶å®šå’Œæ—¥è¨˜ä¸­çš„è¨˜äº‹å…§å®¹
                    Button(action: {
                        logInfo("èª¿è©¦ï¼šç•¶å‰ç¶å®šè¨˜äº‹é•·åº¦: \(thoughts.count) å­—ç¬¦")
                        logInfo("èª¿è©¦ï¼šæ—¥è¨˜è¨˜äº‹é•·åº¦: \(diary.thoughts.count) å­—ç¬¦")
                        logInfo("èª¿è©¦ï¼šç¶å®šè¨˜äº‹å‰20å­—ç¬¦: \"\(thoughts.prefix(20))...\"")
                        logInfo("èª¿è©¦ï¼šæ—¥è¨˜è¨˜äº‹å‰20å­—ç¬¦: \"\(diary.thoughts.prefix(20))...\"")
                        
                        // ç¢ºä¿é¡¯ç¤ºçš„è¨˜äº‹èˆ‡æ—¥è¨˜åŒæ­¥
                        if thoughts != diary.thoughts {
                            thoughts = diary.thoughts
                            logInfo("å·²å¼·åˆ¶åŒæ­¥è¨˜äº‹å…§å®¹")
                        }
                    }) {
                        Image(systemName: "arrow.triangle.2.circlepath")
                            .font(.system(size: 16))
                            .foregroundColor(.blue)
                    }
                    .buttonStyle(.borderless)
                    .help("æ¸¬è©¦ç”¨ï¼šåŒæ­¥è¨˜äº‹å…§å®¹")
                }
                
                EnhancedTextEditor(text: $thoughts)
                    .frame(minHeight: 200)
                    .padding(.top, 4)
            }
            .padding(.horizontal)
            
            Spacer()
        }
        .padding()
        // ä½¿ç”¨è¤‡åˆIDä½œç‚ºè¦–åœ–å”¯ä¸€æ¨™è­˜ï¼Œç¢ºä¿åœ¨æ—¥è¨˜ ID è®ŠåŒ–æ™‚è¦–åœ–æœƒé‡æ–°å‰µå»º
        .id("weather-thoughts-\(diaryId)")
        .onAppear {
            // é¦–æ¬¡å‡ºç¾æ™‚ç¢ºä¿è¨˜äº‹å…§å®¹å·²åŒæ­¥
            logInfo("WeatherAndThoughtsView å‡ºç¾ï¼Œæ—¥è¨˜ID: \(diary.id)")
            refreshBindings()
        }
        .onChange(of: diaryId) { oldId, newId in
            // ç•¶æ—¥è¨˜ ID è®ŠåŒ–æ™‚ï¼Œç¢ºä¿æ›´æ–°è¨˜äº‹å…§å®¹
            logInfo("æ—¥è¨˜ ID è®ŠåŒ–: \(oldId) -> \(newId)")
            refreshBindings()
        }
        // æ·»åŠ æé†’è¡¨å–®
        .sheet(isPresented: $showingReminderSheet) {
            CustomReminderSheetView(text: $thoughts)
                .frame(width: 500, height: 450)
                .presentationDetents([.height(450)])
        }
        // æ·»åŠ è‡ªå‹•æª¢æ¸¬äº‹ä»¶æé†’
        .alert("æª¢æ¸¬åˆ°æ—¥æ›†äº‹ä»¶", isPresented: $showingEventAlert) {
            Button("å–æ¶ˆ", role: .cancel) { }
            Button("å‰µå»º") {
                if let details = eventDetails {
                    CustomCalendarEventHelper.createCalendarEvent(title: details.title, date: details.date) { reminderNote in
                        if !reminderNote.isEmpty {
                            thoughts += reminderNote
                        }
                    }
                }
            }
        } message: {
            Text(eventAlertMessage)
        }
        .onChange(of: thoughts) { oldValue, newValue in
            if let details = CustomCalendarEventHelper.extractEventDetails(from: newValue) {
                eventDetails = details
                eventAlertMessage = "æª¢æ¸¬åˆ°å¯èƒ½çš„æ—¥æ›†äº‹ä»¶ï¼š\næ¨™é¡Œï¼š\(details.title)\næ™‚é–“ï¼š\(details.date.formatted())\n\næ˜¯å¦å‰µå»ºæ—¥æ›†äº‹ä»¶ï¼Ÿ"
                showingEventAlert = true
            }
        }
    }
}

// å¤©æ°£é¡¯ç¤ºçµ„ä»¶
struct WeatherDisplayView: View {
    var diary: DiaryEntry  // ä½¿ç”¨æ™®é€šè®Šé‡ï¼Œè€Œé ObservedObject
    let diaryTemperature: String
    let isToday: Bool
    let updateWeather: () -> Void
    
    var body: some View {
        HStack {
            Text("å¤©æ°£")
                .font(.headline)
            
            Spacer()
            
            if isToday {
                Button("æ›´æ–°å¤©æ°£") {
                    updateWeather()
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.small)
            }
            
            HStack(spacing: 10) {
                Image(systemName: diary.weather.icon)
                    .foregroundColor(.blue)
                    .font(.system(size: 24))
                Text(diary.weather.rawValue)
                
                if !diary.temperature.isEmpty {
                    // ä½¿ç”¨diaryTemperatureä¾†ç¢ºä¿æ¯æ¬¡é¡¯ç¤ºæœ€æ–°å€¼
                    Text("(\(diaryTemperature))")
                        .foregroundColor(.secondary)
                        .id("temp-\(diaryTemperature)") // ä½¿ç”¨å”¯ä¸€IDå¼·åˆ¶åˆ·æ–°
                }
            }
        }
        .padding(.horizontal)
        // ä½¿ç”¨è¤‡åˆIDä½œç‚ºè¦–åœ–å”¯ä¸€æ¨™è­˜ï¼Œç¢ºä¿è¦–åœ–æ›´æ–°
        .id("weather-display-\(diary.id)-\(diary.weather.rawValue)-\(diaryTemperature)")
        .onAppear {
            // è¨˜éŒ„å¤©æ°£ä¿¡æ¯ï¼Œä¾¿æ–¼è¨ºæ–·
            logInfo("WeatherDisplayView å‡ºç¾ï¼Œå¤©æ°£: \(diary.weather.rawValue), æº«åº¦: \(diaryTemperature)")
        }
    }
}

// MARK: - æ—¥è¨˜è¡Œè¦–åœ–
/// åœ¨åˆ—è¡¨ä¸­é¡¯ç¤ºå–®å€‹æ—¥è¨˜æ¢ç›®çš„è¦–åœ–
struct DiaryRowView: View {
    let diary: DiaryEntry
    
    // âš ï¸ é€™è£¡çš„ @AppStorage å®£å‘Šåœ¨å¤šå€‹è¦–åœ–ä¸­é‡è¤‡å‡ºç¾ï¼Œè€ƒæ…®å‰µå»ºä¸€å€‹å…±äº«è¨­å®šç’°å¢ƒç‰©ä»¶
    @AppStorage("titleFontSize") private var titleFontSize: Double = 22
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // æ—¥æœŸå’Œå¤©æ°£
            HStack {
                // æ—¥æœŸæ¨™é¡Œä½¿ç”¨èˆ‡å…¶ä»–æ¨™é¡Œç›¸åŒçš„æ¨£å¼
                Text(formatDate(diary.date))
                    .font(.system(size: titleFontSize))
                    .foregroundColor(Color.fromString(titleFontColor))
                Spacer()
                Image(systemName: diary.weather.icon)
                    .foregroundColor(.blue)
                    .font(.system(size: contentFontSize))
            }
            
            // è¨˜äº‹é è¦½
            if !diary.thoughts.isEmpty {
                Text(diary.thoughts)
                    .lineLimit(2)
                    .font(.system(size: contentFontSize))
                    .foregroundColor(Color.fromString(contentFontColor))
            }
            
            // é¡åˆ¥æ¨™ç±¤
            let categories = getCategoryEntries(for: diary)
            if !categories.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack {
                        ForEach(categories) { category in
                            Label(category.type.rawValue, systemImage: category.type.icon)
                                .font(.caption)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color.blue.opacity(0.1))
                                .cornerRadius(8)
                        }
                    }
                }
            }
        }
        .padding(.vertical, 4)
    }
    
    /// æ ¼å¼åŒ–æ—¥æœŸç‚ºèˆ‡æ—¥æœŸé¸æ“‡å™¨ç›¸åŒçš„æ ¼å¼ (yyyy/M/d)
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy/M/d"
        return formatter.string(from: date)
    }
    
    /// ç²å–æ‰€æœ‰é¡åˆ¥æ¢ç›®
    private func getCategoryEntries(for diary: DiaryEntry) -> [CategoryEntry] {
        var entries: [CategoryEntry] = []
        entries.append(contentsOf: diary.expenses)
        entries.append(contentsOf: diary.exercises)
        entries.append(contentsOf: diary.sleeps)
        entries.append(contentsOf: diary.works)
        entries.append(contentsOf: diary.relationships)
        entries.append(contentsOf: diary.studies)
        return entries
    }
}

// MARK: - Weather Section View
private struct WeatherSectionView: View {
    let diary: DiaryEntry
    @Binding var selectedWeather: String
    @Binding var isOnline: Bool
    @Binding var isLoading: Bool
    let weatherService: WeatherService?
    let isToday: Bool
    let titleFontSize: Double
    let contentFontSize: Double
    let titleFontColor: String
    let updateWeather: () -> Void
    let switchToManual: () -> Void
    let saveContext: () -> Void
    
    // æ–°å¢å‹•ç•«ç‹€æ…‹
    @State private var titleScale: CGFloat = 1.0
    @State private var isUpdating: Bool = false
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text("å¤©æ°£")
                    .font(.system(size: titleFontSize))
                    .foregroundColor(Color.fromString(titleFontColor))
                    .scaleEffect(titleScale)
                    .onAppear {
                        withAnimation(AnimationConstants.springSmall) {
                            titleScale = 1.05
                        }
                        withAnimation(AnimationConstants.springSmall.delay(0.1)) {
                            titleScale = 1.0
                        }
                    }
                
                Spacer()
                
                if isOnline {
                    Text(diary.temperature)
                        .font(.system(size: contentFontSize))
                        .foregroundColor(.secondary)
                        .transition(.opacity.combined(with: .scale))
                        .id("temp-\(diary.temperature)-\(UUID().uuidString)") // å¼ºåˆ¶åˆ·æ–°
                    
                    if weatherService != nil && isToday {
                        Button(action: {
                            withAnimation(AnimationConstants.quick) {
                                isUpdating = true
                            }
                            updateWeather()
                            
                            // å»¶é²é‡ç½®å‹•ç•«ç‹€æ…‹
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                                withAnimation(AnimationConstants.quick) {
                                    isUpdating = false
                                }
                            }
                        }) {
                            if isLoading {
                                ProgressView()
                                    .controlSize(.small)
                            } else {
                                Image(systemName: "arrow.clockwise.circle.fill")
                                    .font(.system(size: contentFontSize))
                                    .foregroundColor(.blue)
                                    .rotationEffect(.degrees(isUpdating ? 360 : 0))
                            }
                        }
                        .buttonStyle(ScaleButtonStyle())
                        .customCursor(.pointingHand)
                        .help("æ›´æ–°å¤©æ°£è³‡è¨Š")
                    }
                    
                    Button(action: switchToManual) {
                        Image(systemName: "hand.tap.fill")
                            .font(.system(size: contentFontSize))
                            .foregroundColor(.blue)
                    }
                    .buttonStyle(ScaleButtonStyle())
                    .customCursor(.pointingHand)
                    .help("åˆ‡æ›åˆ°æ‰‹å‹•é¸æ“‡å¤©æ°£")
                    .transition(.scale.combined(with: .opacity))
                } else {
                    if weatherService != nil && isToday {
                        Button(action: updateWeather) {
                            if isLoading {
                                ProgressView()
                                    .controlSize(.small)
                            } else {
                                Label("è‡ªå‹•æ›´æ–°", systemImage: "cloud.fill")
                                    .font(.system(size: contentFontSize))
                                    .foregroundColor(.blue)
                            }
                        }
                        .buttonStyle(ScaleButtonStyle())
                        .customCursor(.pointingHand)
                        .help("è‡ªå‹•ç²å–ç•¶å‰å¤©æ°£è³‡è¨Š")
                        .transition(.scale.combined(with: .opacity))
                    }
                }
            }
            .animation(AnimationConstants.standard, value: isOnline)
            .animation(AnimationConstants.standard, value: isLoading)
            
            if !isOnline {
                WeatherTypeSelectionView(
                    selectedWeather: $selectedWeather,
                    diary: diary,
                    contentFontSize: contentFontSize,
                    saveContext: saveContext
                )
                .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
        .animation(AnimationConstants.standard, value: isOnline)
    }
}

// MARK: - Weather Type Selection View
private struct WeatherTypeSelectionView: View {
    @Binding var selectedWeather: String
    let diary: DiaryEntry
    let contentFontSize: Double
    let saveContext: () -> Void
    
    // æ·»åŠ å‹•ç•«ç‹€æ…‹
    @State private var animateSelection = false
    @Namespace private var weatherAnimation
    
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 15) {
                ForEach(WeatherType.allCases, id: \.self) { weather in
                    VStack {
                        ZStack {
                            // ç•¶è¢«é¸ä¸­æ™‚é¡¯ç¤ºçš„èƒŒæ™¯åœ“åœˆ
                            if selectedWeather == weather.rawValue {
                                Circle()
                                    .fill(Color.blue.opacity(0.2))
                                    .matchedGeometryEffect(id: "background", in: weatherAnimation)
                            }
                            
                            Image(systemName: weather.icon)
                                .font(.system(size: contentFontSize))
                                .foregroundColor(selectedWeather == weather.rawValue ? .blue : .gray)
                                .padding(8)
                        }
                        .frame(width: 40, height: 40)
                        
                        Text(weather.rawValue)
                            .font(.system(size: contentFontSize))
                            .foregroundColor(selectedWeather == weather.rawValue ? .primary : .secondary)
                    }
                    .onTapGesture {
                        withAnimation(AnimationConstants.spring) {
                            selectedWeather = weather.rawValue
                            diary.weather = weather
                            animateSelection = true
                        }
                        
                        // åŸ·è¡Œä¸€äº›æ›´å¤šçš„å‹•ç•«æ•ˆæœ
                        withAnimation(AnimationConstants.springSmall.delay(0.1)) {
                            animateSelection = false
                        }
                        
                        saveContext()
                    }
                    .scaleEffect(selectedWeather == weather.rawValue && animateSelection ? 1.1 : 1.0)
                    .customCursor(.pointingHand)
                    .help("é¸æ“‡\(weather.rawValue)å¤©æ°£")
                }
            }
            .padding(.horizontal, 5)
        }
        .frame(height: 80)
        .padding(.vertical, 5)
        .background(Color(NSColor.controlBackgroundColor).opacity(0.5))
        .cornerRadius(10)
        .animation(AnimationConstants.standard, value: selectedWeather)
    }
}

// MARK: - Thoughts Section View
private struct ThoughtsSectionView: View {
    @Binding var thoughts: String
    let titleFontSize: Double
    let titleFontColor: String
    let saveContext: () -> Void
    let diary: DiaryEntry
    
    // æ·»åŠ å‹•ç•«ç‹€æ…‹
    @State private var isFocused: Bool = false
    @State private var showSavedIndicator: Bool = false
    @State private var appearScale: CGFloat = 0.98
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text("è¨˜äº‹")
                    .font(.system(size: titleFontSize))
                    .foregroundColor(Color.fromString(titleFontColor))
                
                Spacer()
                
                // ä¿å­˜æŒ‡ç¤ºå™¨ - ä¿ç•™æ·¡å…¥æ·¡å‡ºå‹•ç•«ä½†ç§»é™¤ç¸®æ”¾æ•ˆæœ
                if showSavedIndicator {
                    HStack(spacing: 4) {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(.green)
                        Text("å·²ä¿å­˜")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .transition(.opacity) // ç§»é™¤ç¸®æ”¾æ•ˆæœï¼Œåªä¿ç•™æ·¡å…¥æ·¡å‡º
                    .onAppear {
                        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                            withAnimation(AnimationConstants.standard) {
                                showSavedIndicator = false
                            }
                        }
                    }
                }
            }
            
            ZStack {
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color(NSColor.textBackgroundColor))
                    .shadow(color: Color.black.opacity(isFocused ? 0.1 : 0.05), radius: isFocused ? 5 : 3, x: 0, y: 1)
                
                EnhancedTextEditor(text: $thoughts)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .frame(minHeight: 250)
                    .padding(5)
            }
            .onChange(of: thoughts) { oldValue, newValue in
                diary.thoughts = newValue
                saveContext()
                
                // åªé¡¯ç¤ºä¿å­˜æŒ‡ç¤ºå™¨ï¼Œä¸æ·»åŠ ç¸®æ”¾å‹•ç•«
                withAnimation(.easeIn(duration: 0.2)) {
                    showSavedIndicator = true
                }
            }
            .onHover { hovering in
                withAnimation(AnimationConstants.quick) {
                    isFocused = hovering
                }
            }
            .help("åœ¨æ­¤è¼¸å…¥ä»Šæ—¥è¨˜äº‹")
        }
        .padding(.top, 8)
        .scaleEffect(appearScale)
        .onAppear {
            withAnimation(AnimationConstants.spring) {
                appearScale = 1.0
            }
        }
    }
}

// MARK: - è‡ªå®šç¾©æ–‡æœ¬ç·¨è¼¯å™¨
/// æ”¯æŒæ®µè½é¦–å­—æ”¾å¤§çš„æ–‡æœ¬ç·¨è¼¯å™¨ï¼Œä¿æŒå…‰æ¨™ä½ç½®ç©©å®š
struct EnhancedTextEditor: NSViewRepresentable {
    @Binding var text: String
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    class Coordinator: NSObject, NSTextViewDelegate {
        var parent: EnhancedTextEditor
        var shouldUpdateText = true
        var isComposing = false  // è¿½è¸ªä¸­æ–‡è¾“å…¥çŠ¶æ€
        
        init(_ parent: EnhancedTextEditor) {
            self.parent = parent
        }
        
        func textDidChange(_ notification: Notification) {
            guard shouldUpdateText, let textView = notification.object as? NSTextView else { return }
            
            // åªæ›´æ–°ç»‘å®šçš„æ–‡æœ¬å€¼ï¼Œä¸åº”ç”¨æ ·å¼
            parent.text = textView.string
        }
        
        // ç›‘å¬è¾“å…¥æ³•ç¼–è¾‘ä¼šè¯å¼€å§‹
        func textView(_ textView: NSTextView, didStartComposingAtPosition position: Int) {
            isComposing = true
        }
        
        // ç›‘å¬è¾“å…¥æ³•ç¼–è¾‘ä¼šè¯ç»“æŸ
        func textView(_ textView: NSTextView, didEndComposingAtPosition position: Int) {
            isComposing = false
            
            // ä¸­æ–‡è¾“å…¥å®Œæˆåï¼Œåº”ç”¨æ ·å¼
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.applyStyleAfterTyping(textView)
            }
        }
        
        // è¾“å…¥å®Œæˆååº”ç”¨æ ·å¼
        func applyStyleAfterTyping(_ textView: NSTextView) {
            if isComposing { return }
            
            // ä¿å­˜å½“å‰é€‰æ‹©èŒƒå›´
            let selectedRanges = textView.selectedRanges
            
            shouldUpdateText = false
            
            // åº”ç”¨æ®µè½é¦–å­—æ ·å¼
            let text = textView.string
            let attributedString = NSMutableAttributedString(string: text)
            
            // è®¾ç½®åŸºæœ¬æ ·å¼
            attributedString.addAttribute(.font, 
                                          value: NSFont.systemFont(ofSize: CGFloat(parent.contentFontSize)),
                                          range: NSRange(location: 0, length: text.count))
            attributedString.addAttribute(.foregroundColor, 
                                          value: NSColor.fromString(parent.contentFontColor),
                                          range: NSRange(location: 0, length: text.count))
            
            // åº”ç”¨æ®µè½é¦–å­—æ ·å¼
            var paragraphStart = 0
            text.enumerateSubstrings(in: text.startIndex..<text.endIndex, options: [.byParagraphs]) { (substring, substringRange, _, _) in
                guard let paragraphText = substring, 
                      !paragraphText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
                
                // æ‰¾åˆ°æ®µè½å¼€å§‹ä½ç½®
                paragraphStart = text.distance(from: text.startIndex, to: substringRange.lowerBound)
                
                // åº”ç”¨é¦–å­—æ ·å¼
                if paragraphStart < text.count {
                    let paragraphFirstCharLength = min(1, text.count - paragraphStart)
                    attributedString.addAttribute(
                        .font, 
                        value: NSFont.boldSystemFont(ofSize: CGFloat(self.parent.contentFontSize) * 1.2),
                        range: NSRange(location: paragraphStart, length: paragraphFirstCharLength)
                    )
                    attributedString.addAttribute(
                        .foregroundColor, 
                        value: NSColor.systemYellow,
                        range: NSRange(location: paragraphStart, length: paragraphFirstCharLength)
                    )
                }
            }
            
            // åº”ç”¨æ ·å¼
            textView.textStorage?.setAttributedString(attributedString)
            
            // æ¢å¤é€‰æ‹©èŒƒå›´
            textView.selectedRanges = selectedRanges
            
            shouldUpdateText = true
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    func makeNSView(context: Context) -> NSScrollView {
        // åˆ›å»ºæ–‡æœ¬è§†å›¾å’Œæ»šåŠ¨è§†å›¾
        let scrollView = NSScrollView()
        scrollView.hasVerticalScroller = true
        scrollView.borderType = .noBorder
        
        let textView = NSTextView()
        textView.minSize = NSSize(width: 0, height: 0)
        textView.maxSize = NSSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)
        textView.isVerticallyResizable = true
        textView.isHorizontallyResizable = false
        textView.autoresizingMask = [.width]
        textView.textContainer?.widthTracksTextView = true
        textView.textContainer?.containerSize = NSSize(
            width: scrollView.contentSize.width,
            height: CGFloat.greatestFiniteMagnitude
        )
        
        // åŸºæœ¬é…ç½®
        textView.allowsUndo = true
        textView.isRichText = true
        textView.isEditable = true
        textView.isSelectable = true
        textView.font = .systemFont(ofSize: CGFloat(contentFontSize))
        textView.textColor = NSColor.fromString(contentFontColor)
        
        // è®¾ç½®æ®µè½æ ·å¼
        let defaultParagraphStyle = NSMutableParagraphStyle()
        defaultParagraphStyle.paragraphSpacing = 10 // æ®µè½é—´è·
        textView.defaultParagraphStyle = defaultParagraphStyle
        
        // è®¾ç½®ä»£ç†
        textView.delegate = context.coordinator
        
        // è®¾ç½®åˆå§‹æ–‡æœ¬
        textView.string = text
        
        // åˆå§‹åº”ç”¨æ®µè½é¦–å­—æ ·å¼
        if !text.isEmpty {
            context.coordinator.applyStyleAfterTyping(textView)
        }
        
        // ç»„è£…
        scrollView.documentView = textView
        
        return scrollView
    }
    
    func updateNSView(_ scrollView: NSScrollView, context: Context) {
        guard let textView = scrollView.documentView as? NSTextView else { return }
        
        // æ–‡æœ¬å†…å®¹éœ€è¦æ›´æ–°æ—¶ï¼ˆå¤–éƒ¨æ›´æ–°ï¼‰
        if textView.string != text && !context.coordinator.isComposing {
            // è·å–å½“å‰é€‰æ‹©èŒƒå›´å’Œæ»šåŠ¨ä½ç½®
            let selectedRanges = textView.selectedRanges
            let scrollPosition = scrollView.contentView.bounds.origin
            
            // æš‚æ—¶ç¦ç”¨æ–‡æœ¬æ›´æ–°å›è°ƒ
            context.coordinator.shouldUpdateText = false
            
            // æ›´æ–°æ–‡æœ¬
            textView.string = text
            
            // åº”ç”¨æ®µè½é¦–å­—æ ·å¼
            if !text.isEmpty {
                context.coordinator.applyStyleAfterTyping(textView)
            }
            
            // æ¢å¤é€‰æ‹©èŒƒå›´å’Œæ»šåŠ¨ä½ç½®
            textView.selectedRanges = selectedRanges
            scrollView.contentView.scroll(to: scrollPosition)
            
            // é‡æ–°å¯ç”¨æ–‡æœ¬æ›´æ–°å›è°ƒ
            context.coordinator.shouldUpdateText = true
        }
        
        // åªåœ¨å­—ä½“è®¾ç½®æ›´æ”¹æ—¶æ›´æ–°
        if textView.font?.pointSize != CGFloat(contentFontSize) || 
           textView.textColor != NSColor.fromString(contentFontColor) {
            textView.font = .systemFont(ofSize: CGFloat(contentFontSize))
            textView.textColor = NSColor.fromString(contentFontColor)
            
            // åº”ç”¨æ®µè½é¦–å­—æ ·å¼
            if !textView.string.isEmpty && !context.coordinator.isComposing {
                context.coordinator.applyStyleAfterTyping(textView)
            }
        }
    }
}




// MARK: - é¡åˆ¥è©³ç´°è¦–åœ–
/// é¡¯ç¤ºç‰¹å®šé¡åˆ¥è©³ç´°å…§å®¹çš„è¦–åœ–
struct CategoryDetailView: View {
    @Environment(\.modelContext) private var modelContext
    let type: DiaryEntryType
    let diary: DiaryEntry
    @State private var showingCategoryForm = false
    @State private var editingEntry: CategoryEntry?
    
    /// ä¿å­˜æ•¸æ“šåˆ°æŒä¹…åŒ–å­˜å„²
    private func saveContext() {
        do {
            try modelContext.save()
            print("\(type.rawValue)æ•¸æ“šä¿å­˜æˆåŠŸ")
        } catch {
            print("ä¿å­˜å¤±æ•—: \(error)")
        }
    }
    
    /// ç²å–ç‰¹å®šé¡å‹çš„æ¢ç›®åˆ—è¡¨
    private func getEntries(for type: DiaryEntryType, in diary: DiaryEntry) -> [CategoryEntry] {
        switch type {
        case .expense: return diary.expenses
        case .exercise: return diary.exercises
        case .sleep: return diary.sleeps
        case .work: return diary.works
        case .relationship: return diary.relationships
        case .study: return diary.studies
        }
    }
    
    var body: some View {
        VStack {
            CategoryTableView(
                type: type,
                entries: getEntries(for: type, in: diary),
                diary: diary,
                onAdd: {
                    editingEntry = nil
                    showingCategoryForm = true
                },
                onDelete: { indexSet in
                    switch type {
                    case .expense:
                        diary.expenses.remove(atOffsets: indexSet)
                    case .exercise:
                        diary.exercises.remove(atOffsets: indexSet)
                    case .sleep:
                        diary.sleeps.remove(atOffsets: indexSet)
                    case .work:
                        diary.works.remove(atOffsets: indexSet)
                    case .relationship:
                        diary.relationships.remove(atOffsets: indexSet)
                    case .study:
                        diary.studies.remove(atOffsets: indexSet)
                    }
                    saveContext()
                },
                onEdit: { entry in
                    editingEntry = entry
                    showingCategoryForm = true
                }
            )
        }
        .sheet(isPresented: $showingCategoryForm) {
            if let entry = editingEntry {
                CategoryEntryForm(type: type, diary: diary, editingEntry: entry)
            } else {
                CategoryEntryForm(type: type, diary: diary)
            }
        }
        .onChange(of: showingCategoryForm) { oldValue, newValue in
            if !newValue {
                // ç•¶è¡¨å–®é—œé–‰æ™‚ï¼Œæ¸…é™¤ç·¨è¼¯ç‹€æ…‹
                editingEntry = nil
            }
        }
    }
}

#Preview {
    let config = ModelConfiguration(isStoredInMemoryOnly: true)
    let container = try! ModelContainer(for: DiaryEntry.self, CategoryEntry.self, configurations: config)
    return ContentView()
        .modelContainer(container)
}

// MARK: - åå¥½è¨­ç½®è¦–åœ–
struct PreferencesView: View {
    @Environment(\.dismiss) private var dismiss
    
    // å­—é«”è¨­ç½®
    @AppStorage("titleFontSize") private var titleFontSize: Double = 22
    @AppStorage("contentFontSize") private var contentFontSize: Double = 16
    
    // é¡è‰²è¨­ç½®
    @AppStorage("titleFontColor") private var titleFontColor: String = "Green"
    @AppStorage("contentFontColor") private var contentFontColor: String = "White"
    
    // ç›®æ¨™è¨­ç½®
    @AppStorage("monthlyExpenseLimit") private var monthlyExpenseLimit: Double = 20000
    @AppStorage("dailyExerciseGoal") private var dailyExerciseGoal: Double = 60
    @AppStorage("dailySleepGoal") private var dailySleepGoal: Double = 390
    @AppStorage("dailyWorkGoal") private var dailyWorkGoal: Double = 120
    @AppStorage("dailyRelationshipGoal") private var dailyRelationshipGoal: Double = 30
    @AppStorage("dailyStudyGoal") private var dailyStudyGoal: Double = 60
    
    // å¤©æ°£è¨­ç½®
    @AppStorage("weatherApiKey") private var weatherApiKey: String = "76fb9beb7dd213c17447b2b9080e0bcb"
    
    // å®‰å…¨è¨­ç½®
    @AppStorage("useBiometricAuth") private var useBiometricAuth: Bool = false
    
    // å¯ç”¨çš„é¡è‰²é¸é …
    private let availableColors = ["Red", "Green", "Blue", "Orange", "Purple", "Yellow", "White", "Black"]
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // å­—é«”è¨­ç½®
                    GroupBox(label: Text("å­—é«”è¨­ç½®").font(.headline)) {
                        VStack(alignment: .leading, spacing: 15) {
                            VStack(alignment: .leading) {
                                Text("æ¨™é¡Œå­—é«”å¤§å°: \(Int(titleFontSize))")
                                    .foregroundColor(Color.fromString(titleFontColor))
                                    .font(.system(size: titleFontSize))
                                
                                Slider(value: $titleFontSize, in: 14...32, step: 1)
                            }
                            .padding(.bottom, 5)
                            
                            VStack(alignment: .leading) {
                                Text("å…§å®¹å­—é«”å¤§å°: \(Int(contentFontSize))")
                                    .foregroundColor(Color.fromString(contentFontColor))
                                    .font(.system(size: contentFontSize))
                                
                                Slider(value: $contentFontSize, in: 12...28, step: 1)
                            }
                            .padding(.bottom, 5)
                            
                            // æ¨™é¡Œé¡è‰²
                            HStack {
                                Text("æ¨™é¡Œå­—é«”é¡è‰²")
                                Spacer()
                                Menu {
                                    ForEach(availableColors, id: \.self) { color in
                                        Button(color) {
                                            titleFontColor = color
                                        }
                                    }
                    } label: {
                                    HStack {
                                        Text(titleFontColor)
                                            .foregroundColor(Color.fromString(titleFontColor))
                                        Image(systemName: "chevron.up.chevron.down")
                                            .foregroundColor(.blue)
                                    }
                                }
                            }
                            .padding(.bottom, 5)
                            
                            // å…§å®¹é¡è‰²
                            HStack {
                                Text("å…§å®¹å­—é«”é¡è‰²")
                                Spacer()
                                Menu {
                                    ForEach(availableColors, id: \.self) { color in
                                        Button(color) {
                                            contentFontColor = color
                                        }
                                    }
                                } label: {
                                    HStack {
                                        Text(contentFontColor)
                                            .foregroundColor(Color.fromString(contentFontColor))
                                        Image(systemName: "chevron.up.chevron.down")
                                            .foregroundColor(.blue)
                                    }
                                }
                            }
                        }
                        .padding()
                    }
                    .padding(.horizontal)
                    
                    // ç›®æ¨™è¨­ç½®
                    GroupBox(label: Text("ç›®æ¨™è¨­ç½®").font(.headline)) {
                        VStack(spacing: 15) {
                            HStack {
                                Text("æœˆæ”¯å‡ºä¸Šé™")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $monthlyExpenseLimit, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                            
                            HStack {
                                Text("æ¯æ—¥é‹å‹•æ™‚é–“")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $dailyExerciseGoal, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                            
                            HStack {
                                Text("æ¯æ—¥ç¡çœ æ™‚é–“")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $dailySleepGoal, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                            
                            HStack {
                                Text("æ¯æ—¥å·¥ä½œæ™‚é–“")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $dailyWorkGoal, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                            
                            HStack {
                                Text("æ¯æ—¥é—œä¿‚ç¶“ç‡Ÿ")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $dailyRelationshipGoal, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                            
                            HStack {
                                Text("æ¯æ—¥å­¸ç¿’æ™‚é–“")
                                    .foregroundColor(.green)
                                Spacer()
                                TextField("", value: $dailyStudyGoal, formatter: NumberFormatter())
                                    .textFieldStyle(.roundedBorder)
                                    .frame(width: 100)
                            }
                        }
                        .padding()
                    }
                    .padding(.horizontal)
                    
                    // å¤©æ°£è¨­ç½®
                    GroupBox(label: Text("å¤©æ°£è¨­ç½®").font(.headline)) {
                        VStack(alignment: .leading) {
                            Text("OpenWeatherMap API Key")
                                .foregroundColor(.green)
                            TextField("API Key", text: $weatherApiKey)
                                .font(.system(size: 14))
                                .textFieldStyle(.roundedBorder)
                        }
                        .padding()
                    }
                    .padding(.horizontal)
                    
                    // å®‰å…¨è¨­ç½®
                    GroupBox(label: Text("å®‰å…¨è¨­ç½®").font(.headline)) {
                        Toggle("ä½¿ç”¨æŒ‡ç´‹è§£é–", isOn: $useBiometricAuth)
                            .padding()
                    }
                    .padding(.horizontal)
                }
                .padding(.vertical)
            }
            .navigationTitle("åå¥½è¨­ç½®")
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("å®Œæˆ") {
                        dismiss()
                    }
                }
            }
        }
    }
}

// MARK: - é¢œè‰²è¾…åŠ©å‡½æ•°
extension Color {
    static func fromString(_ colorName: String) -> Color {
        switch colorName.lowercased() {
        case "red": return .red
        case "green": return .green
        case "blue": return .blue
        case "orange": return .orange
        case "purple": return .purple
        case "yellow": return .yellow
        case "white": return .white
        case "black": return .black
        case "gray": return .gray
        default: return .primary
        }
    }
}

extension NSColor {
    static func fromString(_ colorName: String) -> NSColor {
        switch colorName.lowercased() {
        case "red": return .systemRed
        case "green": return .systemGreen
        case "blue": return .systemBlue
        case "orange": return .systemOrange
        case "purple": return .systemPurple
        case "yellow": return .systemYellow
        case "white": return .white
        case "black": return .black
        default: return .labelColor
        }
    }
}

// MARK: - ä½¿ç”¨èªªæ˜è¦–åœ–
struct HelpView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack {
            // æ¨™é¡Œå’Œé—œé–‰æŒ‰éˆ•
            HStack {
                Text("ä½¿ç”¨èªªæ˜")
                    .font(.system(size: 28))
                    .fontWeight(.bold)
                Spacer()
                Button("å®Œæˆ") {
                    dismiss()
                }
                .font(.system(size: 20))
            }
            .padding()
            
            // å…§å®¹
            ScrollView {
                VStack(alignment: .leading, spacing: 25) {
                    Group {
                        helpSection(title: "åŸºæœ¬æ“ä½œ",
                                  items: ["é»æ“Šå³ä¸Šè§’ã€Œ+ã€æŒ‰éˆ•æ–°å¢æ—¥è¨˜",
                                         "å·¦æ»‘æ—¥è¨˜é …ç›®å¯ä»¥åˆªé™¤",
                                         "é»æ“Šæ—¥è¨˜é …ç›®å¯ä»¥æŸ¥çœ‹è©³ç´°å…§å®¹",
                                         "åœ¨æ—¥æ›†ä¸­é¸æ“‡æ—¥æœŸå¯ä»¥æŸ¥çœ‹è©²æ—¥çš„æ—¥è¨˜"])
                        
                        helpSection(title: "å¤©æ°£è¨˜éŒ„",
                                  items: ["æ–°å¢æ—¥è¨˜æ™‚å¯ä»¥æ‰‹å‹•é¸æ“‡å¤©æ°£",
                                         "é»æ“Šã€Œç²å–å¤©æ°£ã€å¯ä»¥è‡ªå‹•ç²å–ç•¶å‰ä½ç½®çš„å¤©æ°£",
                                         "å¤©æ°£è³‡è¨ŠåŒ…å«æº«åº¦ç¯„åœå’Œå¤©æ°£æè¿°"])
                        
                        helpSection(title: "å¤©æ°£ API è¨­ç½®",
                                  items: ["æœ¬ç¨‹å¼ä½¿ç”¨ OpenWeatherMap æä¾›çš„å…è²»å¤©æ°£ API",
                                         "1. å‰å¾€ OpenWeatherMap ç¶²ç«™è¨»å†Šå¸³è™Ÿï¼šhttps://openweathermap.org/",
                                         "2. è¨»å†Šå®Œæˆå¾Œï¼Œç™»å…¥ä¸¦é€²å…¥ API Keys é é¢ï¼šhttps://home.openweathermap.org/api_keys",
                                         "3. é»æ“Šã€ŒGenerateã€æŒ‰éˆ•å‰µå»ºæ–°çš„ API Key",
                                         "4. è¤‡è£½ç”Ÿæˆçš„ API Key",
                                         "5. åœ¨æœ¬ç¨‹å¼çš„ã€Œåå¥½è¨­ç½®ã€ä¸­ï¼Œå°‡ API Key è²¼ä¸Šåˆ°ã€Œå¤©æ°£è¨­ç½®ã€æ¬„ä½",
                                         "6. API Key ç”Ÿæ•ˆå¯èƒ½éœ€è¦ç­‰å¾…å¹¾å°æ™‚",
                                         "æ³¨æ„ï¼šå…è²»ç‰ˆæ¯åˆ†é˜å¯å‘¼å« 60 æ¬¡ï¼Œå°æ–¼ä¸€èˆ¬ä½¿ç”¨å·²ç¶“è¶³å¤ "])
                        
                        helpSection(title: "åˆ†é¡è¨˜éŒ„",
                                  items: ["æ”¯æ´å…­ç¨®åˆ†é¡è¨˜éŒ„ï¼šæ”¯å‡ºã€é‹å‹•ã€ç¡çœ ã€å·¥ä½œã€é—œä¿‚ã€å­¸ç¿’",
                                         "æ¯å€‹åˆ†é¡éƒ½å¯ä»¥æ·»åŠ å¤šå€‹è¨˜éŒ„",
                                         "åˆ†é¡è¨˜éŒ„åŒ…å«åç¨±ã€é¡åˆ¥ã€æ•¸é‡å’Œå‚™è¨»",
                                         "éƒ¨åˆ†åˆ†é¡æä¾›é è¨­çš„é¡åˆ¥é¸é …"])
                        
                        helpSection(title: "æœå°‹åŠŸèƒ½",
                                  items: ["ä½¿ç”¨Command+Fæˆ–é»æ“Šæœå°‹æŒ‰éˆ•é–‹å•Ÿæœå°‹",
                                         "å¯ä»¥æœå°‹æ—¥æœŸã€å¤©æ°£ã€è¨˜äº‹å’Œæ‰€æœ‰åˆ†é¡è¨˜éŒ„",
                                         "ä½¿ç”¨ä¸Šä¸‹ç®­é ­æˆ–æŒ‰éˆ•åœ¨æœå°‹çµæœä¸­å°èˆª"])
                        
                        helpSection(title: "æ•¸æ“šç®¡ç†",
                                  items: ["æ”¯æ´åŒ¯å‡ºæ—¥è¨˜æ•¸æ“šç‚ºJSONæ ¼å¼",
                                         "å¯ä»¥åŒ¯å…¥ä¹‹å‰åŒ¯å‡ºçš„æ•¸æ“š",
                                         "å¯ä»¥é¸æ“‡æ—¥æœŸç¯„åœé€²è¡ŒåŒ¯å‡º"])
                        
                        helpSection(title: "å€‹äººåŒ–è¨­å®š",
                                  items: ["å¯ä»¥èª¿æ•´æ¨™é¡Œå’Œå…§å®¹çš„å­—é«”å¤§å°",
                                         "å¯ä»¥æ›´æ”¹æ¨™é¡Œå’Œå…§å®¹çš„é¡è‰²",
                                         "æ”¯æ´Face ID/Touch IDè§£é–åŠŸèƒ½",
                                         "å¯ä»¥è¨­ç½®é–‹ç™¼è€…æ¨¡å¼è·³éèªè­‰"])
                    }
                }
                .padding()
            }
        }
    }
    
    private func helpSection(title: String, items: [String]) -> some View {
        VStack(alignment: .leading, spacing: 15) {
            Text(title)
                .font(.system(size: 24))
                .fontWeight(.bold)
            
            ForEach(items, id: \.self) { item in
                if item.hasPrefix("http") {
                    Link(item, destination: URL(string: item)!)
                        .font(.system(size: 21))
                        .foregroundColor(.blue)
                        .padding(.leading, 25)
                } else {
                    HStack(alignment: .top, spacing: 10) {
                        Text("â€¢")
                            .foregroundColor(.blue)
                            .font(.system(size: 21))
                        Text(item)
                            .font(.system(size: 21))
                    }
                }
            }
        }
    }
}

// æ·»åŠ è‡ªå®šç¾©æ¸¸æ¨™ä¿®é£¾ç¬¦
struct CursorModifier: ViewModifier {
    let cursor: NSCursor
    
    func body(content: Content) -> some View {
        content.onHover { inside in
            if inside {
                cursor.push()
            } else {
                NSCursor.pop()
            }
        }
    }
}

extension View {
    func customCursor(_ cursor: NSCursor) -> some View {
        modifier(CursorModifier(cursor: cursor))
    }
}

// MARK: - å¸¶è‡ªå‹•å®ŒæˆåŠŸèƒ½çš„åç¨±è¼¸å…¥å€å¡Š
private struct NameSectionWithAutocomplete: View {
    let type: DiaryEntryType
    @Binding var name: String
    let suggestions: [String]
    @Binding var showingSuggestions: Bool
    @Binding var selectedSuggestionIndex: Int
    let onNameChanged: () -> Void
    let onSuggestionSelected: (String) -> Void
    let onTabPressed: () -> Void
    @FocusState private var isNameFocused: Bool
    
    var nameLabel: String {
        switch type {
        case .expense: return "åç¨±"
        case .exercise: return "åç¨±"
        case .sleep: return "å“è³ª"
        case .work: return "åç¨±"
        case .relationship: return "å§“å"
        case .study: return "åç¨±"
        }
    }
    
    var body: some View {
        Section {
            VStack(alignment: .leading, spacing: 0) {
                HStack {
                    Image(systemName: type.icon)
                        .foregroundColor(.blue)
                        .font(.system(size: 20))
                    Text(nameLabel)
                        .foregroundColor(.secondary)
                        .font(.system(size: 20))
                    Spacer()
                    
                    TextField("", text: $name)
                        .textFieldStyle(.plain)
                        .font(.system(size: 20))
                        .multilineTextAlignment(.trailing)
                        .onChange(of: name) { oldValue, newValue in
                            onNameChanged()
                        }
                        .focused($isNameFocused)
                        .onSubmit {
                            showingSuggestions = false
                        }
                        .onKeyPress(.tab) {
                            onTabPressed()
                            return .handled
                        }
                        .help("è¼¸å…¥\(nameLabel)ï¼ŒæŒ‰Tabå¯è‡ªå‹•å¡«å¯«")
                }
                
                if showingSuggestions && isNameFocused {
                    ScrollView {
                        LazyVStack(alignment: .leading, spacing: 8) {
                            ForEach(Array(suggestions.enumerated()), id: \.element) { index, suggestion in
                                Text(suggestion)
                                    .font(.system(size: 18))
                                    .padding(.vertical, 4)
                                    .padding(.horizontal, 8)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(index == selectedSuggestionIndex ? Color.blue.opacity(0.2) : Color.clear)
                                    .cornerRadius(4)
                                    .contentShape(Rectangle())
                                    .onTapGesture {
                                        onSuggestionSelected(suggestion)
                                    }
                                    .onHover { isHovered in
                                        if isHovered {
                                            selectedSuggestionIndex = index
                                        }
                                    }
                                    .customCursor(.pointingHand)
                            }
                        }
                    }
                    .frame(maxHeight: 150)
                    .background(Color(NSColor.windowBackgroundColor))
                    .overlay(
                        RoundedRectangle(cornerRadius: 5)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
                    .padding(.top, 4)
                }
            }
        }
    }
}

// MARK: - å‹•ç•«å¸¸æ•¸
struct AnimationConstants {
    static let standard = Animation.easeInOut(duration: 0.3)
    static let quick = Animation.easeOut(duration: 0.2)
    static let slow = Animation.easeInOut(duration: 0.5)
    static let spring = Animation.spring(response: 0.3, dampingFraction: 0.6)
    static let springSmall = Animation.spring(response: 0.2, dampingFraction: 0.75)
}

// MARK: - è‡ªå®šç¾©å‹•ç•«æŒ‰éˆ•æ¨£å¼
struct ScaleButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1)
            .animation(.spring(response: 0.2), value: configuration.isPressed)
    }
}

// MARK: - è‡ªå®šä¹‰æ—¥æœŸé€‰æ‹©å™¨
struct CustomDatePickerView: View {
    @Binding var selectedDate: Date
    let timeInterval: Calendar.Component = .day // å›ºå®šä¸ºæŒ‰å¤©å¢å‡
    @State private var showingCalendar: Bool = false
    var titleFontColor: String = "Green" // é»˜è®¤å€¼
    var contentFontColor: String = "White" // é»˜è®¤å€¼
    @Environment(\.modelContext) private var modelContext
    var selectedDiary: Binding<DiaryEntry?>?
    
    // æ·»åŠ åˆå§‹åŒ–æ–¹æ³•ï¼Œå…è®¸ä¸ä¼ å…¥selectedDiary
    init(selectedDate: Binding<Date>, titleFontColor: String, contentFontColor: String) {
        self._selectedDate = selectedDate
        self.titleFontColor = titleFontColor
        self.contentFontColor = contentFontColor
        self.selectedDiary = nil
    }
    
    // å®Œæ•´åˆå§‹åŒ–æ–¹æ³•
    init(selectedDate: Binding<Date>, titleFontColor: String, contentFontColor: String, selectedDiary: Binding<DiaryEntry?>) {
        self._selectedDate = selectedDate
        self.titleFontColor = titleFontColor
        self.contentFontColor = contentFontColor
        self.selectedDiary = selectedDiary
    }
    
    var body: some View {
        HStack(spacing: 5) {
            HStack(spacing: 0) {
                Text(dateFormatter.string(from: selectedDate))
                    .frame(minWidth: 120)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .font(.system(size: 20))
                    .foregroundColor(Color.fromString(contentFontColor)) // ä½¿ç”¨ç”¨æˆ·é¦–é€‰çš„å†…å®¹å­—ä½“é¢œè‰²
                    .background(
                        RoundedRectangle(cornerRadius: 4)
                            .fill(Color(NSColor.controlBackgroundColor))
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: 4)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
                
                VStack(spacing: 0) {
                    Button(action: incrementDate) {
                        Image(systemName: "chevron.up")
                            .frame(width: 20, height: 12)
                            .contentShape(Rectangle())
                    }
                    .buttonStyle(.borderless)
                    .padding(.vertical, 2)
                    .customCursor(.pointingHand)
                    .help("å¢åŠ ä¸€å¤©")
                    
                    Divider()
                        .frame(height: 1)
                    
                    Button(action: decrementDate) {
                        Image(systemName: "chevron.down")
                            .frame(width: 20, height: 12)
                            .contentShape(Rectangle())
                    }
                    .buttonStyle(.borderless)
                    .padding(.vertical, 2)
                    .customCursor(.pointingHand)
                    .help("æ¸›å°‘ä¸€å¤©")
                }
                .frame(width: 20)
                .overlay(
                    RoundedRectangle(cornerRadius: 4)
                        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                )
            }
            .fixedSize()
            
            // æ·»åŠ æ—¥å†æŒ‰é’®
            Button(action: {
                showingCalendar = true
            }) {
                Image(systemName: "calendar")
                    .frame(width: 24, height: 24)
                    .foregroundColor(Color.fromString(titleFontColor)) // ä½¿ç”¨æ ‡é¢˜å­—ä½“é¢œè‰²
                    .padding(2)
            }
            .buttonStyle(.borderless)
            .background(
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color(NSColor.controlBackgroundColor))
                    .overlay(
                        RoundedRectangle(cornerRadius: 4)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
            )
            .customCursor(.pointingHand)
            .help("é–‹å•Ÿæ—¥æ›†")
            .popover(isPresented: $showingCalendar, arrowEdge: .bottom) {
                VStack {
                    DatePicker("", selection: $selectedDate, displayedComponents: [.date])
                        .datePickerStyle(.graphical)
                        .labelsHidden()
                        .padding()
                        .frame(minWidth: 300)
                        .onChange(of: selectedDate) { _, _ in
                            updateSelectedDiary()
                        }
                    
                    Button("ç¢ºå®š") {
                        showingCalendar = false
                    }
                    .buttonStyle(.borderedProminent)
                    .padding(.bottom)
                }
                .padding(5)
            }
        }
    }
    
    private var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy/M/d"
        return formatter
    }
    
    private func incrementDate() {
        withAnimation {
            selectedDate = Calendar.current.date(byAdding: timeInterval, value: 1, to: selectedDate) ?? selectedDate
            updateSelectedDiary()
        }
    }

    private func decrementDate() {
        withAnimation {
            selectedDate = Calendar.current.date(byAdding: timeInterval, value: -1, to: selectedDate) ?? selectedDate
            updateSelectedDiary()
        }
    }
    
    private func updateSelectedDiary() {
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°selectedDiary
        guard let selectedDiaryBinding = selectedDiary else { return }
        
        // ç²å–æ‰€é¸æ—¥æœŸçš„èµ·å§‹å’ŒçµæŸæ™‚é–“é»
        let calendar = Calendar.current
        let startOfDay = calendar.startOfDay(for: selectedDate)
        let endOfDay = calendar.date(byAdding: .day, value: 1, to: startOfDay)!
        
        logInfo("CustomDatePicker: æ›´æ–°æ—¥è¨˜ï¼Œæ—¥æœŸ \(selectedDate.formatted())")
        
        // æ¸…é™¤ç•¶å‰é¸æ“‡çš„æ—¥è¨˜ï¼Œé¿å…è³‡æ–™æ®˜ç•™
        selectedDiaryBinding.wrappedValue = nil
        
        // æŸ¥è©¢æ‰€æœ‰æ—¥è¨˜
        do {
            // ç²å–æ‰€æœ‰æ—¥è¨˜
            let allDiaries = try modelContext.fetch(FetchDescriptor<DiaryEntry>())
            
            // éæ¿¾ç•¶å¤©çš„æ—¥è¨˜
            let diariesForSelectedDate = allDiaries.filter { diary in
                let diaryDate = diary.date
                return diaryDate >= startOfDay && diaryDate < endOfDay
            }
            
            if let newDiary = diariesForSelectedDate.first {
                logInfo("CustomDatePicker: æ‰¾åˆ°æ—¥æœŸ \(selectedDate.formatted()) çš„æ—¥è¨˜ï¼ŒID: \(newDiary.id)")
                selectedDiaryBinding.wrappedValue = newDiary
                logInfo("CustomDatePicker: å·²è¨­ç½®æ—¥è¨˜ï¼ŒID: \(newDiary.id), è¨˜äº‹é•·åº¦: \(newDiary.thoughts.count) å­—ç¬¦")
            } else {
                logInfo("CustomDatePicker: æœªæ‰¾åˆ°æ—¥æœŸ \(selectedDate.formatted()) çš„æ—¥è¨˜")
                selectedDiaryBinding.wrappedValue = nil
            }
        } catch {
            logInfo("CustomDatePicker: æŸ¥è©¢æ—¥è¨˜å¤±æ•—: \(error)")
            selectedDiaryBinding.wrappedValue = nil
        }
    }
}

// MARK: - è¦–åœ–æ“´å±•
extension View {
    // æš‚æ—¶ä¸éœ€è¦safeToolbaræ–¹æ³•ï¼Œç›´æ¥ä½¿ç”¨åŸç”Ÿtoolbarå³å¯
}

// MARK: - Modifiers
struct ListToolbarModifier: ViewModifier {
    let toggleSearchField: () -> Void
    let showSearchField: Bool
    let switchToToday: () -> Void
    @Binding var isExporting: Bool
    @Binding var showingDateRangeSheet: Bool
    @Binding var showingPreferencesSheet: Bool
    @Binding var showingHelpSheet: Bool
    @Binding var showingNewDiarySheet: Bool
    @Binding var showingBackupSelectionSheet: Bool
    
    func body(content: Content) -> some View {
        content.toolbar {
            ToolbarItem(placement: .automatic) {
                Button(action: toggleSearchField) {
                    Image(systemName: showSearchField ? "magnifyingglass.circle.fill" : "magnifyingglass.circle")
                        .font(.title2)
                }
                .customCursor(.pointingHand)
                .help("æœå°‹æ—¥è¨˜")
            }
            
            ToolbarItem(placement: .automatic) {
                Button(action: switchToToday) {
                    Image(systemName: "calendar.circle")
                        .font(.title2)
                }
                .customCursor(.pointingHand)
                .help("åˆ‡æ›åˆ°ä»Šæ—¥")
            }
            
            ToolbarItem(placement: .automatic) {
                Button(action: { 
                    isExporting = true
                    showingDateRangeSheet = true 
                }) {
                    Image(systemName: "square.and.arrow.up")
                        .font(.title2)
                }
                .customCursor(.pointingHand)
                .help("åŒ¯å‡ºå‚™ä»½")
            }
            
            ToolbarItem(placement: .primaryAction) {
                Button(action: { showingPreferencesSheet = true }) {
                    Image(systemName: "gear")
                        .font(.title2)
                }
                .customCursor(.pointingHand)
                .help("åå¥½è¨­ç½®")
            }
            
            ToolbarItem(placement: .primaryAction) {
                Button(action: { showingHelpSheet = true }) {
                    Image(systemName: "questionmark.circle")
                        .font(.title2)
                }
                .customCursor(.pointingHand)
                .help("ä½¿ç”¨èªªæ˜")
            }
            
            ToolbarItem(placement: .primaryAction) {
                Button(action: { 
                    isExporting = false
                    showingBackupSelectionSheet = true 
                }) {
                    Image(systemName: "arrow.down.doc")
                        .font(.title2)
                }
                .customCursor(.pointingHand)
                .help("ä»å¤‡ä»½æ¢å¤æ—¥è®°")
            }
        }
    }
}

// DiaryEntryType è½¬æ¢å™¨
class DiaryEntryTypeTransformer: ValueTransformer {
    static let shared = DiaryEntryTypeTransformer()
    
    override class func transformedValueClass() -> AnyClass {
        return NSString.self
    }
    
    override class func allowsReverseTransformation() -> Bool {
        return true
    }
    
    override func transformedValue(_ value: Any?) -> Any? {
        return "Deprecated"
    }
    
    override func reverseTransformedValue(_ value: Any?) -> Any? {
        return nil
    }
}

// æ³¨å†Œ DiaryEntryType è½¬æ¢å™¨
extension DiaryEntryTypeTransformer {
    static func register() {
    }
}

// æ·»åŠ é™æ€æ–¹æ³•ä»¥ä¾¿åœ¨BackupSelectionViewä¸­ä½¿ç”¨
extension ContentView {
    static func findLocalBackupsStatic() -> [URL] {
        let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let fileManager = FileManager.default
        
        print("é–‹å§‹æœç´¢å‚™ä»½æ–‡ä»¶")
        print("æ–‡æª”ç›®éŒ„è·¯å¾‘: \(documentsDirectory.path)")
        
        do {
            // ç¢ºèªç›®éŒ„å­˜åœ¨
            var isDirectory: ObjCBool = false
            if !fileManager.fileExists(atPath: documentsDirectory.path, isDirectory: &isDirectory) || !isDirectory.boolValue {
                print("éŒ¯èª¤: æ–‡æª”ç›®éŒ„ä¸å­˜åœ¨æˆ–ä¸æ˜¯ç›®éŒ„")
                return []
            }
            
            // åˆ—å‡ºç›®éŒ„ä¸­çš„æ‰€æœ‰æ–‡ä»¶
            let allFiles = try fileManager.contentsOfDirectory(atPath: documentsDirectory.path)
            print("æ–‡æª”ç›®éŒ„ä¸­çš„æ‰€æœ‰æ–‡ä»¶: \(allFiles)")
            
            // ç²å–æ–‡æª”ç›®éŒ„ä¸­çš„æ‰€æœ‰æ–‡ä»¶ï¼ŒåŒ…æ‹¬ä¿®æ”¹æ—¥æœŸå±¬æ€§
            let fileURLs = try fileManager.contentsOfDirectory(
                at: documentsDirectory,
                includingPropertiesForKeys: [.contentModificationDateKey]
            )
            
            print("æ‰¾åˆ°ç¸½å…± \(fileURLs.count) å€‹æ–‡ä»¶")
            
            // éæ¿¾å‡ºå‚™ä»½æ–‡ä»¶ï¼ˆ.jsonæ ¼å¼ä¸”æ–‡ä»¶ååŒ…å«"diary_backup_"ï¼‰
            let backupFiles = fileURLs.filter { url in
                let filename = url.lastPathComponent
                let isBackup = filename.hasSuffix(".json") && filename.contains("diary_backup_")
                if isBackup {
                    print("æ‰¾åˆ°å‚™ä»½æ–‡ä»¶: \(filename)")
                }
                return isBackup
            }
            
            print("éæ¿¾å¾Œæ‰¾åˆ° \(backupFiles.count) å€‹å‚™ä»½æ–‡ä»¶")
            
            // æŒ‰ä¿®æ”¹æ™‚é–“æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
            let sortedFiles = try backupFiles.sorted { url1, url2 in
                let attrs1 = try url1.resourceValues(forKeys: [.contentModificationDateKey])
                let attrs2 = try url2.resourceValues(forKeys: [.contentModificationDateKey])
                
                guard let date1 = attrs1.contentModificationDate,
                      let date2 = attrs2.contentModificationDate else {
                    return false
                }
                
                return date1 > date2
            }
            
            print("æ’åºå¾Œçš„å‚™ä»½æ–‡ä»¶:")
            for file in sortedFiles {
                print("- \(file.lastPathComponent)")
            }
            
            return sortedFiles
        } catch {
            print("æŸ¥æ‰¾å‚™ä»½æ–‡ä»¶æ™‚å‡ºéŒ¯: \(error)")
            return []
        }
    }
}

// MARK: - BackupSelectionView
struct BackupSelectionView: View {
    @Environment(\.dismiss) private var dismiss
    @State private var backupFiles: [URL] = []
    @State private var alertMessage = ""
    @State private var showingAlert = false
    @State private var isImporting = false
    
    // å¼•ç”¨å†…å®¹è§†å›¾ä¸­çš„æ¢å¤å‡½æ•°
    var restoreSelectedEntries: (URL, [UUID]) -> Void
    
    init(restoreSelectedEntries: @escaping (URL, [UUID]) -> Void) {
        self.restoreSelectedEntries = restoreSelectedEntries
    }
    
    var body: some View {
        NavigationView {
            VStack {
                Text("é¸æ“‡å‚™ä»½æ–‡ä»¶")
                    .font(.title)
                    .padding()
                
                // é¡¯ç¤ºæœ¬åœ°å‚™ä»½æ–‡ä»¶åˆ—è¡¨ï¼Œå³ä½¿ç‚ºç©ºä¹Ÿé¡¯ç¤ºåˆ—è¡¨
                VStack {
                    if backupFiles.isEmpty {
                        Text("æœªåœ¨æ–‡æª”ç›®éŒ„æ‰¾åˆ°å‚™ä»½æ–‡ä»¶")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                            .padding()
                    } else {
                        Text("æ‰¾åˆ° \(backupFiles.count) å€‹æœ¬åœ°å‚™ä»½æ–‡ä»¶:")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                    
                    List {
                        if backupFiles.isEmpty {
                            // é¡¯ç¤ºç©ºåˆ—è¡¨é …
                            Text("ç„¡å¯ç”¨çš„æœ¬åœ°å‚™ä»½")
                                .foregroundColor(.secondary)
                                .italic()
                        } else {
                            // é¡¯ç¤ºæ‰¾åˆ°çš„å‚™ä»½æ–‡ä»¶
                            ForEach(backupFiles, id: \.self) { fileURL in
                                Button(action: {
                                    print("å˜—è©¦æ¢å¾©æ–‡ä»¶: \(fileURL.path)")
                                    // ç°¡åŒ–ç‰ˆæœ¬ï¼šç›´æ¥æ¢å¾©æ•´å€‹æ–‡ä»¶ï¼Œä¸é¸æ“‡å–®å€‹æ¢ç›®
                                    restoreSelectedEntries(fileURL, [])
                                    dismiss()
                                }) {
                                    HStack {
                                        Image(systemName: "doc.text")
                                            .foregroundColor(.blue)
                                        
                                        VStack(alignment: .leading) {
                                            Text(fileURL.lastPathComponent)
                                                .lineLimit(1)
                                                .font(.headline)
                                            
                                            if let fileAttributes = try? FileManager.default.attributesOfItem(atPath: fileURL.path),
                                               let modificationDate = fileAttributes[.modificationDate] as? Date,
                                               let fileSize = fileAttributes[.size] as? UInt64 {
                                                Text("ä¿®æ”¹æ™‚é–“: \(formattedDate(modificationDate)) - \(formatFileSize(fileSize))")
                                                    .font(.caption)
                                                    .foregroundColor(.secondary)
                                            }
                                        }
                                    }
                                    .padding(.vertical, 4)
                                }
                            }
                        }
                    }
                    .frame(minHeight: 200)
                    
                    // å¾å…¶ä»–ä½ç½®åŒ¯å…¥çš„æŒ‰éˆ•
                    Button(action: {
                        isImporting = true
                    }) {
                        Label("å¾å…¶ä»–ä½ç½®åŒ¯å…¥å‚™ä»½", systemImage: "square.and.arrow.down")
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue.opacity(0.1))
                            .cornerRadius(8)
                    }
                    .buttonStyle(.plain)
                    .padding()
                }
            }
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("å–æ¶ˆ") {
                        dismiss()
                    }
                }
            }
            .alert(isPresented: $showingAlert) {
                Alert(
                    title: Text("æç¤º"),
                    message: Text(alertMessage),
                    dismissButton: .default(Text("ç¢ºå®š"))
                )
            }
            .fileImporter(
                isPresented: $isImporting,
                allowedContentTypes: [.json],
                allowsMultipleSelection: false
            ) { result in
                switch result {
                case .success(let urls):
                    guard let selectedURL = urls.first else { return }
                    
                    print("é¸æ“‡çš„æ–‡ä»¶: \(selectedURL.path)")
                    
                    // æª¢æŸ¥æ–‡ä»¶æ˜¯å¦å¯ä»¥è¨ªå•
                    if selectedURL.startAccessingSecurityScopedResource() {
                        defer { selectedURL.stopAccessingSecurityScopedResource() }
                        
                        // ä½¿ç”¨éœæ…‹æ–¹æ³•é©—è­‰å‚™ä»½æ–‡ä»¶
                        if ContentView.selectBackupFile(url: selectedURL) {
                            // æ¢å¾©é¸å®šçš„å‚™ä»½
                            restoreSelectedEntries(selectedURL, [])
                            dismiss()
                        } else {
                            alertMessage = "æ‰€é¸æ–‡ä»¶ä¸æ˜¯æœ‰æ•ˆçš„æ—¥è¨˜å‚™ä»½æ–‡ä»¶"
                            showingAlert = true
                        }
                    } else {
                        alertMessage = "ç„¡æ³•è¨ªå•é¸å®šçš„æ–‡ä»¶"
                        showingAlert = true
                    }
                    
                case .failure(let error):
                    print("æ–‡ä»¶é¸æ“‡éŒ¯èª¤: \(error)")
                    alertMessage = "é¸æ“‡æ–‡ä»¶å¤±æ•—: \(error.localizedDescription)"
                    showingAlert = true
                }
            }
            .onAppear {
                // è¼‰å…¥æœ¬åœ°å‚™ä»½æ–‡ä»¶
                print("BackupSelectionViewå‡ºç¾ï¼Œé–‹å§‹åŠ è¼‰å‚™ä»½æ–‡ä»¶")
                DispatchQueue.main.async {
                    backupFiles = ContentView.findLocalBackupsStatic()
                    print("åŠ è¼‰å®Œæˆï¼Œé¡¯ç¤º \(backupFiles.count) å€‹å‚™ä»½æ–‡ä»¶")
                    
                    // å¦‚æœæ²’æœ‰æ‰¾åˆ°å‚™ä»½æ–‡ä»¶ï¼Œä½†æˆ‘å€‘èªç‚ºæ‡‰è©²æœ‰å‚™ä»½ï¼Œæª¢æŸ¥æ–‡æª”ç›®éŒ„
                    if backupFiles.isEmpty {
                        let docsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
                        print("å‚™ä»½æ–‡ä»¶ç‚ºç©ºï¼Œå†æ¬¡ç¢ºèªæ–‡æª”ç›®éŒ„: \(docsURL.path)")
                        
                        do {
                            let contents = try FileManager.default.contentsOfDirectory(atPath: docsURL.path)
                            print("æ–‡æª”ç›®éŒ„å…§å®¹: \(contents)")
                        } catch {
                            print("è®€å–æ–‡æª”ç›®éŒ„å¤±æ•—: \(error)")
                        }
                    }
                }
            }
        }
    }
    
    // æ ¼å¼åŒ–æ—¥æœŸ
    private func formattedDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
    
    // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
    private func formatFileSize(_ size: UInt64) -> String {
        let byteCountFormatter = ByteCountFormatter()
        byteCountFormatter.allowedUnits = [.useKB, .useMB]
        byteCountFormatter.countStyle = .file
        return byteCountFormatter.string(fromByteCount: Int64(size))
    }
}

// MARK: - å¯¦ç”¨å·¥å…·å‡½æ•¸
/// æ—¥èªŒè¨˜éŒ„å‡½æ•¸ï¼Œæ–¹ä¾¿è¿½è¹¤å’Œè¨ºæ–·å•é¡Œ
func logInfo(_ message: String, file: String = #fileID, function: String = #function, line: Int = #line) {
    let filename = URL(fileURLWithPath: file).lastPathComponent
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "HH:mm:ss.SSS"
    let timestamp = dateFormatter.string(from: Date())
    print("[\(timestamp)] [\(filename):\(line)] \(function): \(message)")
}

// ç‚ºæª”æ¡ˆåŒ¯å‡ºåŠŸèƒ½æ·»åŠ  Document é¡å‹
struct JSONDocument: FileDocument {
    static var readableContentTypes: [UTType] { [.json] }
    
    var data: Data
    
    init(data: Data) {
        self.data = data
    }
    
    init(configuration: ReadConfiguration) throws {
        guard let data = configuration.file.regularFileContents else {
            throw CocoaError(.fileReadCorruptFile)
        }
        self.data = data
    }
    
    func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
        return FileWrapper(regularFileWithContents: data)
    }
}

extension ContentView {
    // ... existing code ...
    
    static func selectBackupFile(url: URL) -> Bool {
        print("é–‹å§‹é©—è­‰å‚™ä»½æ–‡ä»¶: \(url.path)")
        
        // æª¢æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        guard FileManager.default.fileExists(atPath: url.path) else {
            print("æ–‡ä»¶ä¸å­˜åœ¨: \(url.path)")
            return false
        }
        
        // æª¢æŸ¥æ–‡ä»¶æ˜¯å¦å¯è®€
        guard FileManager.default.isReadableFile(atPath: url.path) else {
            print("æ–‡ä»¶ä¸å¯è®€: \(url.path)")
            return false
        }
        
        // æª¢æŸ¥æ–‡ä»¶å¤§å°
        do {
            let attributes = try FileManager.default.attributesOfItem(atPath: url.path)
            if let fileSize = attributes[.size] as? UInt64 {
                print("å‚™ä»½æ–‡ä»¶å¤§å°: \(fileSize) å­—ç¯€")
                if fileSize == 0 {
                    print("éŒ¯èª¤: å‚™ä»½æ–‡ä»¶ç‚ºç©º")
                    return false
                }
            }
        } catch {
            print("ç„¡æ³•ç²å–æ–‡ä»¶å±¬æ€§: \(error)")
        }
        
        do {
            // è®€å–æ–‡ä»¶æ•¸æ“š
            let data = try Data(contentsOf: url)
            print("æˆåŠŸè®€å–æ–‡ä»¶æ•¸æ“šï¼Œå¤§å°: \(data.count) å­—ç¯€")
            
            // é è¦½JSONå…§å®¹
            if let preview = String(data: data.prefix(200), encoding: .utf8) {
                print("JSONé è¦½: \(preview)...")
            }
            
            // å˜—è©¦è§£ç¢¼å‚™ä»½æ•¸æ“šä»¥ç¢ºä¿æ ¼å¼æ­£ç¢º
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601
            
            // å˜—è©¦è§£ç¢¼
            do {
                // åªæª¢æŸ¥æ–‡ä»¶æ ¼å¼ï¼Œä¸éœ€è¦å®Œå…¨è§£ç¢¼
                let backup = try decoder.decode(DiaryBackup.self, from: data)
                print("æˆåŠŸé©—è­‰å‚™ä»½æ–‡ä»¶ï¼ŒåŒ…å« \(backup.entries.count) æ¢æ—¥è¨˜")
                return true
            } catch {
                print("JSONè§£ç¢¼å¤±æ•—: \(error)")
                
                // å˜—è©¦è¨ºæ–·å…·é«”å•é¡Œ
                if let decodingError = error as? DecodingError {
                    switch decodingError {
                    case .dataCorrupted(let context):
                        print("æ•¸æ“šæå£: \(context.debugDescription)")
                    case .keyNotFound(let key, let context):
                        print("æ‰¾ä¸åˆ°éµ '\(key.stringValue)': \(context.debugDescription)")
                    case .typeMismatch(let type, let context):
                        print("é¡å‹ä¸åŒ¹é… \(type): \(context.debugDescription)")
                    case .valueNotFound(let type, let context):
                        print("æ‰¾ä¸åˆ°å€¼ \(type): \(context.debugDescription)")
                    @unknown default:
                        print("æœªçŸ¥è§£ç¢¼éŒ¯èª¤")
                    }
                }
                
                return false
            }
        } catch {
            print("ç„¡æ³•è®€å–å‚™ä»½æ–‡ä»¶: \(error)")
            return false
        }
    }
}

// æé†’è¡¨å–®è¦–åœ–

// æ—¥æ›†äº‹ä»¶å¹«åŠ©é¡
class CustomCalendarEventHelper {
    // å¾æ–‡æœ¬ä¸­æå–äº‹ä»¶è©³æƒ…
    static func extractEventDetails(from text: String) -> (title: String, date: Date)? {
        let dateFormatter = DateFormatter()
        dateFormatter.locale = Locale(identifier: "zh_TW")
        dateFormatter.dateFormat = "yyyy/MM/dd HH:mm"
        
        // åŒ¹é… "äº‹ä»¶åç¨± yyyy/MM/dd HH:mm" æ ¼å¼çš„æ–‡æœ¬
        let pattern = "([^\\s]+)\\s+(\\d{4}/\\d{1,2}/\\d{1,2}\\s+\\d{1,2}:\\d{1,2})"
        let regex = try? NSRegularExpression(pattern: pattern, options: [])
        
        if let regex = regex,
           let match = regex.firstMatch(in: text, options: [], range: NSRange(location: 0, length: text.count)) {
            // æå–äº‹ä»¶åç¨±å’Œæ—¥æœŸæ™‚é–“å­—ç¬¦ä¸²
            if let titleRange = Range(match.range(at: 1), in: text),
               let dateRange = Range(match.range(at: 2), in: text) {
                let title = String(text[titleRange])
                let dateString = String(text[dateRange])
                
                // è§£ææ—¥æœŸ
                if let date = dateFormatter.date(from: dateString) {
                    return (title: title, date: date)
                }
            }
        }
        
        return nil
    }
    
    // å‰µå»ºæ—¥æ›†äº‹ä»¶ä¸¦è¿”å›è¦æ·»åŠ åˆ°è¨˜äº‹ä¸­çš„æ–‡æœ¬
    static func createCalendarEvent(title: String, date: Date, completion: @escaping (String) -> Void) {
        let eventStore = EKEventStore()
        
        eventStore.requestAccess(to: .event) { granted, error in
            DispatchQueue.main.async {
                var reminderNote = ""
                
                if granted {
                    let event = EKEvent(eventStore: eventStore)
                    event.title = title
                    event.startDate = date
                    event.endDate = date.addingTimeInterval(3600) // é è¨­ä¸€å°æ™‚
                    event.calendar = eventStore.defaultCalendarForNewEvents
                    
                    do {
                        try eventStore.save(event, span: .thisEvent)
                        
                        // æ ¼å¼åŒ–æ—¥æœŸ
                        let dateFormatter = DateFormatter()
                        dateFormatter.locale = Locale(identifier: "zh_TW")
                        dateFormatter.dateFormat = "yyyy/MM/dd HH:mm"
                        
                        // åœ¨è¨˜äº‹æœ«å°¾æ·»åŠ æé†’æ¨™è¨˜
                        reminderNote = "\nğŸ“Œæé†’äº‹é …ï¼š\(dateFormatter.string(from: date)) \(title)"
                    } catch {
                        print("å‰µå»ºæ—¥æ›†äº‹ä»¶å¤±æ•—ï¼š\(error.localizedDescription)")
                    }
                }
                
                completion(reminderNote)
            }
        }
    }
}

